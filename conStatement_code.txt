		switch (c) {
		case 'f':
			refpath = optarg;
			break;
		case 'F':
			othpath = optarg;
			break;
		}

----------------------------------------------------------------------------------
	if (!refpath || !othpath) {
		fprintf(stderr, "usage: %s -f reffile -F othfile\n", argv[0]);
		exit(FAILED);
	}

----------------------------------------------------------------------------------
	if (!(reffile = fopen(refpath, "r"))) {
		fprintf(stderr, "cannot open %s\n", refpath);
		exit(FAILED);
	}

----------------------------------------------------------------------------------
	if (!(othfile = fopen(othpath, "r"))) {
		fprintf(stderr, "cannot open %s\n", othpath);
		exit(FAILED);
	}

----------------------------------------------------------------------------------
	if (!(x = jas_seq2d_input(reffile))) {
		fprintf(stderr, "cannot input reference\n");
		exit(FAILED);
	}

----------------------------------------------------------------------------------
	if (!(y = jas_seq2d_input(othfile))) {
		fprintf(stderr, "cannot input other\n");
		exit(FAILED);
	}

----------------------------------------------------------------------------------
	if (!jas_matrix_cmp(x, y)) {
		fprintf(stderr, "equal\n");
		exit(0);
	} else {
		fprintf(stderr, "not equal\n");
		exit(1);
	}

----------------------------------------------------------------------------------
	if ((cmdname = strrchr(argv[0], '/'))) {
		++cmdname;
	} else {
		cmdname = argv[0];
	}

----------------------------------------------------------------------------------
	if (jas_init()) {
		abort();
	}

----------------------------------------------------------------------------------
		switch (c) {
		case 'w':
			cmdopts.tmout = atof(jas_optarg) * 1000;
			break;
		case 'l':
			cmdopts.loop = 1;
			break;
		case 't':
			cmdopts.title = jas_optarg;
			break;
		case 'v':
			cmdopts.verbose = 1;
			break;
		case 'm':
			cmdopts.max_mem = strtoull(jas_optarg, 0, 10);
			break;
		case 'V':
			printf("%s\n", JAS_VERSION);
			fprintf(stderr, "libjasper %s\n", jas_getversion());
			cleanupandexit(EXIT_SUCCESS);
			break;
		default:
		case 'h':
			usage();
			break;
		}

----------------------------------------------------------------------------------
	if (jas_optind < argc) {
		/* The images are to be read from one or more explicitly named
		  files. */
		cmdopts.numfiles = argc - jas_optind;
		cmdopts.filenames = &argv[jas_optind];
	} else {
		/* The images are to be read from standard input. */
		static char *null = 0;
		cmdopts.filenames = &null;
		cmdopts.numfiles = 1;
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "displayfunc()\n");
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "reshapefunc(%d, %d)\n", w, h);
		dumpstate();
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "keyboardfunc(%d, %d, %d)\n", key, x, y);
	}

----------------------------------------------------------------------------------
	switch (key) {
	case ' ':
		nextimage();
		break;
	case '\b':
		previmage();
		break;
	case '>':
		zoom(BIGZOOMAMOUNT, BIGZOOMAMOUNT);
		glutPostRedisplay();
		break;
	case '.':
		zoom(SMALLZOOMAMOUNT, SMALLZOOMAMOUNT);
		glutPostRedisplay();
		break;
	case '<':
		zoom(1.0 / BIGZOOMAMOUNT, 1.0 / BIGZOOMAMOUNT);
		glutPostRedisplay();
		break;
	case ',':
		zoom(1.0 / SMALLZOOMAMOUNT, 1.0 / SMALLZOOMAMOUNT);
		glutPostRedisplay();
		break;
	case 'c':
		nextcmpt();
		break;
	case 'C':
		prevcmpt();
		break;
	case 'h':
		fprintf(stderr, "h             help\n");
		fprintf(stderr, ">             zoom in (large)\n");
		fprintf(stderr, ",             zoom in (small)\n");
		fprintf(stderr, "<             zoom out (large)\n");
		fprintf(stderr, ".             zoom out (small)\n");
		fprintf(stderr, "down arrow    pan down\n");
		fprintf(stderr, "up arrow      pan up\n");
		fprintf(stderr, "left arrow    pan left\n");
		fprintf(stderr, "right arrow   pan right\n");
		fprintf(stderr, "space         next image\n");
		fprintf(stderr, "backspace     previous image\n");
		fprintf(stderr, "q             quit\n");
		break;
	case 'q':
		cleanupandexit(EXIT_SUCCESS);
		break;
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "specialfunc(%d, %d, %d)\n", key, x, y);
	}

----------------------------------------------------------------------------------
	switch (key) {
	case GLUT_KEY_UP:
		{
			float panamount;
			panamount = (glutGetModifiers() & GLUT_ACTIVE_SHIFT) ?
			  BIGPANAMOUNT : SMALLPANAMOUNT;
			pan(0.0, panamount * (gs.toprighty - gs.botlefty));
			glutPostRedisplay();
		}
		break;
	case GLUT_KEY_DOWN:
		{
			float panamount;
			panamount = (glutGetModifiers() & GLUT_ACTIVE_SHIFT) ?
			  BIGPANAMOUNT : SMALLPANAMOUNT;
			pan(0.0, -panamount * (gs.toprighty - gs.botlefty));
			glutPostRedisplay();
		}
		break;
	case GLUT_KEY_LEFT:
		{
			float panamount;
			panamount = (glutGetModifiers() & GLUT_ACTIVE_SHIFT) ?
			  BIGPANAMOUNT : SMALLPANAMOUNT;
			pan(-panamount * (gs.toprightx - gs.botleftx), 0.0);
			glutPostRedisplay();
		}
		break;
	case GLUT_KEY_RIGHT:
		{
			float panamount;
			panamount = (glutGetModifiers() & GLUT_ACTIVE_SHIFT) ?
			  BIGPANAMOUNT : SMALLPANAMOUNT;
			pan(panamount * (gs.toprightx - gs.botleftx), 0.0);
			glutPostRedisplay();
		}
		break;
	default:
		break;
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "timerfunc(%d)\n", value);
	}

----------------------------------------------------------------------------------
	if (value == gs.activetmid) {
		nextimage();
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "start of panzoom\n");
		dumpstate();
		fprintf(stderr, "reginh=%d reginv=%d\n", reginh, reginv);
	}

----------------------------------------------------------------------------------
	if (dx || dy) {
		gs.botleftx += dx;
		gs.botlefty += dy;
		gs.toprightx += dx;
		gs.toprighty += dy;
	}

----------------------------------------------------------------------------------
	if (sx != 1.0 || sy != 1.0) {
		cx = (gs.botleftx + gs.toprightx) / 2.0;
		cy = (gs.botlefty + gs.toprighty) / 2.0;
		w = gs.toprightx - gs.botleftx;
		h = gs.toprighty - gs.botlefty;
		gs.botleftx = cx - 0.5 * w / sx;
		gs.botlefty = cy - 0.5 * h / sy;
		gs.toprightx = cx + 0.5 * w / sx;
		gs.toprighty = cy + 0.5 * h / sy;
	}

----------------------------------------------------------------------------------
	if (reginh) {
		if (gs.botleftx < 0) {
			dx = -gs.botleftx;
			gs.botleftx += dx;
			gs.toprightx += dx;
		} else if (gs.toprightx > gs.vp.width) {
			dx = gs.vp.width - gs.toprightx;
			gs.botleftx += dx;
			gs.toprightx += dx;
		}
	}

----------------------------------------------------------------------------------
	if (gs.botleftx < 0 || gs.toprightx > gs.vp.width) {
		float w;
		w = gs.toprightx - gs.botleftx;
		gs.botleftx = 0.5 * gs.vp.width - 0.5 * w;
		gs.toprightx = 0.5 * gs.vp.width + 0.5 * w;
	}

----------------------------------------------------------------------------------
	if (reginv) {
		if (gs.botlefty < 0) {
			dy = -gs.botlefty;
			gs.botlefty += dy;
			gs.toprighty += dy;
		} else if (gs.toprighty > gs.vp.height) {
			dy = gs.vp.height - gs.toprighty;
			gs.botlefty += dy;
			gs.toprighty += dy;
		}
	}

----------------------------------------------------------------------------------
	if (gs.botlefty < 0 || gs.toprighty > gs.vp.height) {
		float h;
		h = gs.toprighty - gs.botlefty;
		gs.botlefty = 0.5 * gs.vp.height - 0.5 * h;
		gs.toprighty = 0.5 * gs.vp.height + 0.5 * h;
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "end of panzoom\n");
		dumpstate();
	}

----------------------------------------------------------------------------------
	if (gs.monomode) {
		if (gs.cmptno == jas_image_numcmpts(gs.image) - 1) {
			if (gs.altimage) {
				gs.monomode = 0;
			} else {
				gs.cmptno = 0;
			}
		} else {
			++gs.cmptno;
		}
	} else {
		gs.monomode = 1;
		gs.cmptno = 0;
	}

----------------------------------------------------------------------------------
	if (gs.monomode) {
		if (!gs.cmptno) {
			gs.monomode = 0;
		} else {
			--gs.cmptno;
		}
	} else {
		gs.monomode = 1;
		gs.cmptno = jas_image_numcmpts(gs.image) - 1;
	}

----------------------------------------------------------------------------------
		if (gs.filenum >= cmdopts.numfiles) {
			if (cmdopts.loop) {
				gs.filenum = 0;
			} else {
				cleanupandexit(EXIT_SUCCESS);
			}
		}

----------------------------------------------------------------------------------
		if (!loadimage()) {
			return;
		}

----------------------------------------------------------------------------------
		if (gs.filenum < 0) {
			if (cmdopts.loop) {
				gs.filenum = cmdopts.numfiles - 1;
			} else {
				cleanupandexit(EXIT_SUCCESS);
			}
		}

----------------------------------------------------------------------------------
		if (!loadimage()) {
			return;
		}

----------------------------------------------------------------------------------
	if (pathname && pathname[0] != '\0') {
		if (cmdopts.verbose) {
			fprintf(stderr, "opening file %s\n", pathname);
		}
		/* The input image is to be read from a file. */
		if (!(in = jas_stream_fopen(pathname, "rb"))) {
			fprintf(stderr, "error: cannot open file %s\n", pathname);
			goto error;
		}
	} else {
		/* The input image is to be read from standard input. */
		in = streamin;
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "decoding image\n");
	}

----------------------------------------------------------------------------------
	if (!(gs.image = jas_image_decode(in, -1, 0))) {
		fprintf(stderr, "error: cannot load image data\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (in != streamin) {
		jas_stream_close(in);
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "creating color profile\n");
	}

----------------------------------------------------------------------------------
	if (!(outprof = jas_cmprof_createfromclrspc(JAS_CLRSPC_SRGB)))
		goto error;

----------------------------------------------------------------------------------
	if (!(gs.altimage = jas_image_chclrspc(gs.image, outprof, JAS_CMXFORM_INTENT_PER)))
		goto error;

----------------------------------------------------------------------------------
	if (gs.altimage) {
		gs.monomode = 0;
	} else {
		gs.monomode = 1;
		gs.cmptno = 0;
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "num of components %d\n", jas_image_numcmpts(gs.image));
		fprintf(stderr, "dimensions %"PRIiFAST32" %"PRIiFAST32"\n",
		  jas_image_width(gs.image), jas_image_height(gs.image));
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "preparing image for viewing\n");
	}

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
		fprintf(stderr, "done preparing image for viewing\n");
	}

----------------------------------------------------------------------------------
	if (vw != glutGet(GLUT_WINDOW_WIDTH) ||
	  vh != glutGet(GLUT_WINDOW_HEIGHT)) {
		glutReshapeWindow(vw, vh);
	}

----------------------------------------------------------------------------------
	if (cmdopts.title) {
		glutSetWindowTitle(cmdopts.title);

----------------------------------------------------------------------------------
	if (cmdopts.tmout != 0) {
		glutTimerFunc(cmdopts.tmout, timerfunc, gs.nexttmid);

----------------------------------------------------------------------------------
	if (gs.image) {
		jas_image_destroy(gs.image);

----------------------------------------------------------------------------------
	if (gs.altimage) {
		jas_image_destroy(gs.altimage);

----------------------------------------------------------------------------------
	if (!(buf = realloc(p->data, w * h * 4 * sizeof(GLshort)))) {
		return -1;

----------------------------------------------------------------------------------
	if ((cmptlut[0] = jas_image_getcmptbytype(image,
	  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R))) < 0 ||

----------------------------------------------------------------------------------
		if (jas_image_cmptwidth(image, cmptlut[i]) != width ||
		  jas_image_cmptheight(image, cmptlut[i]) != height)
			goto error;

----------------------------------------------------------------------------------
			if (x >= 0 && x < width && y >= 0 && y < height) {
				for (k = 0; k < 3; ++k) {

----------------------------------------------------------------------------------
					if (v[k] < 0) {
						v[k] = 0;
					} else if (v[k] > 65535) {

----------------------------------------------------------------------------------
	if (cmptno < 0 || cmptno >= image->numcmpts_) {
		fprintf(stderr, "bad parameter\n");
		goto error;

----------------------------------------------------------------------------------
			if (v < 0) {
				v = 0;

----------------------------------------------------------------------------------
	if (cmdopts.verbose) {
//		fprintf(stderr, "vtlx=%f, vtly=%f, vsx=%f, vsy=%f\n",

----------------------------------------------------------------------------------
	if (gs.monomode) {
		if (cmdopts.verbose) {
			fprintf(stderr, "component %d\n", gs.cmptno);
		}
		jas_image_render2(gs.image, gs.cmptno, 0.0, 0.0,

----------------------------------------------------------------------------------
		if (cmdopts.verbose) {
			fprintf(stderr, "color\n");
		}

----------------------------------------------------------------------------------
	switch (jas_image_colorspace(gs.image)) {
	case JAS_IMAGE_CS_RGB:
	case JAS_IMAGE_CS_YCBCR:
		color = 1;
		numcmpts = 3;
		break;
	case JAS_IMAGE_CS_GRAY:
	default:
		numcmpts = 1;
		color = 0;
		break;
	}

----------------------------------------------------------------------------------
			if (!gs.monomode && color) {
				for (k = 0; k < numcmpts; ++k) {

----------------------------------------------------------------------------------
				switch (jas_image_colorspace(gs.image)) {
				case JAS_IMAGE_CS_RGB:
					break;
				case JAS_IMAGE_CS_YCBCR:
					u[0] = (1/1.772) * (v[0] + 1.402 * v[2]);
					u[1] = (1/1.772) * (v[0] - 0.34413 * v[1] - 0.71414 * v[2]);
					u[2] = (1/1.772) * (v[0] + 1.772 * v[1]);
					v[0] = u[0];
					v[1] = u[1];
					v[2] = u[2];
					break;
				}

----------------------------------------------------------------------------------
	if (v[k] < 0) {
		v[k] = 0;
	} else if (v[k] > 65535) {

----------------------------------------------------------------------------------
	if (jas_init()) {
		abort();
	}

----------------------------------------------------------------------------------
		switch (id) {
		case OPT_MAXONLY:
			maxonly = 1;
			break;
		case OPT_MINONLY:
			minonly = 1;
			break;
		case OPT_METRIC:
			metricname = jas_optarg;
			break;
		case OPT_ORIG:
			origpath = jas_optarg;
			break;
		case OPT_RECON:
			reconpath = jas_optarg;
			break;
		case OPT_VERBOSE:
			verbose = 1;
			break;
		case OPT_DIFFIMAGE:
			diffpath = jas_optarg;
			break;
		case OPT_VERSION:
			printf("%s\n", JAS_VERSION);
			exit(EXIT_SUCCESS);
			break;
		case OPT_MAXMEM:
			max_mem = strtoull(jas_optarg, 0, 10);
			break;
		case OPT_HELP:
		default:
			usage();
			break;
		}

----------------------------------------------------------------------------------
	if (verbose) {
		cmdinfo();
	}

----------------------------------------------------------------------------------
	if (!origpath || !reconpath) {
		usage();
	}

----------------------------------------------------------------------------------
	if (metricname) {
		if ((metric = (jas_taginfo_nonull(jas_taginfos_lookup(metrictab,
		  metricname))->id)) < 0) {
			usage();
		}
	}

----------------------------------------------------------------------------------
	if (!(origstream = jas_stream_fopen(origpath, "rb"))) {
		fprintf(stderr, "cannot open %s\n", origpath);
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
	if (!(reconstream = jas_stream_fopen(reconpath, "rb"))) {
		fprintf(stderr, "cannot open %s\n", reconpath);
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
	if (!(origimage = jas_image_decode(origstream, -1, 0))) {
		fprintf(stderr, "cannot load original image\n");
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
	if (!(reconimage = jas_image_decode(reconstream, -1, 0))) {
		fprintf(stderr, "cannot load reconstructed image\n");
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
	if (jas_image_numcmpts(reconimage) != numcomps) {
		fprintf(stderr, "number of components differ (%d != %d)\n",
		  numcomps, jas_image_numcmpts(reconimage));
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
		if (jas_image_cmptwidth(reconimage, compno) != width ||
		 jas_image_cmptheight(reconimage, compno) != height) {
			fprintf(stderr, "image dimensions differ\n");
			return EXIT_FAILURE;

----------------------------------------------------------------------------------
		if (jas_image_cmptprec(reconimage, compno) != depth) {
			fprintf(stderr, "precisions differ\n");

----------------------------------------------------------------------------------
		if (!(origdata = jas_matrix_create(height, width))) {
			fprintf(stderr, "internal error\n");

----------------------------------------------------------------------------------
		if (!(recondata = jas_matrix_create(height, width))) {
			fprintf(stderr, "internal error\n");

----------------------------------------------------------------------------------
		if (jas_image_readcmpt(origimage, compno, 0, 0, width, height,
		  origdata)) {

----------------------------------------------------------------------------------
		if (jas_image_readcmpt(reconimage, compno, 0, 0, width, height,
		  recondata)) {
			fprintf(stderr, "cannot read component data\n");
			return EXIT_FAILURE;

----------------------------------------------------------------------------------
		if (diffpath) {
			if (!(diffstream = jas_stream_fopen(diffpath, "rwb"))) {

----------------------------------------------------------------------------------
			if (!(diffimage = makediffimage(origdata, recondata))) {
				fprintf(stderr, "cannot make diff image\n");
				return EXIT_FAILURE;

----------------------------------------------------------------------------------
			if (jas_image_encode(diffimage, diffstream, fmtid, 0)) {
				fprintf(stderr, "cannot save\n");

----------------------------------------------------------------------------------
		if (metric != metricid_none) {
			d = getdistortion(origdata, recondata, depth, metric);

----------------------------------------------------------------------------------
			if (d > maxdist) {
				maxdist = d;

----------------------------------------------------------------------------------
			if (d < mindist) {
				mindist = d;

----------------------------------------------------------------------------------
			if (!maxonly && !minonly) {
				if (metric == metricid_pae || metric == metricid_equal) {

----------------------------------------------------------------------------------
	if (metric != metricid_none && (maxonly || minonly)) {
		if (maxonly) {
			d = maxdist;
		} else if (minonly) {

----------------------------------------------------------------------------------
		if (metric == metricid_pae || metric == metricid_equal) {
			printf("%ld\n", (long) ceil(d));
		} else {

----------------------------------------------------------------------------------
	switch (metric) {
	case metricid_psnr:
	default:
		d = psnr(orig, recon, depth);
		break;
	case metricid_mae:
		d = msen(orig, recon, 1);
		break;
	case metricid_mse:
		d = msen(orig, recon, 2);
		break;
	case metricid_rmse:
		d = sqrt(msen(orig, recon, 2));
		break;
	case metricid_pae:
		d = pae(orig, recon);
		break;
	case metricid_equal:
		d = (pae(orig, recon) == 0) ? 0 : 1;
		break;
	}

----------------------------------------------------------------------------------
			if (d > s) {
				s = d;
			}

----------------------------------------------------------------------------------
			if (n == 1) {
				s += fabs(d);

----------------------------------------------------------------------------------
	if (!(diffimage = jas_image_create(3, compparms, JAS_CLRSPC_SRGB))) {
		fprintf(stderr, "cannot create image\n");

----------------------------------------------------------------------------------
		if (!(diffdata[i] = jas_matrix_create(height, width))) {
			fprintf(stderr, "cannot create matrix\n");

----------------------------------------------------------------------------------
			if (a > b) {
				jas_matrix_set(diffdata[0], j, k, 255);

----------------------------------------------------------------------------------
		if (jas_image_writecmpt(diffimage, i, 0, 0, width, height, diffdata[i])) {
			fprintf(stderr, "cannot write image component\n");

----------------------------------------------------------------------------------
	if (diffimage) {
		jas_image_destroy(diffimage);

----------------------------------------------------------------------------------
	if (argc < 2) {
		fprintf(stderr, "bad usage :P\n");
		exit(1);
	}

----------------------------------------------------------------------------------
	if ((cmdname = strrchr(argv[0], '/'))) {
		++cmdname;
	} else {
		cmdname = argv[0];
	}

----------------------------------------------------------------------------------
	if (jas_init()) {
		abort();
	}

----------------------------------------------------------------------------------
	if (!(cmdopts = cmdopts_parse(argc, argv))) {
		fprintf(stderr, "error: cannot parse command line\n");
		exit(EXIT_FAILURE);
	}

----------------------------------------------------------------------------------
	if (cmdopts->version) {
		printf("%s\n", JAS_VERSION);
		fprintf(stderr, "libjasper %s\n", jas_getversion());
		exit(EXIT_SUCCESS);
	}

----------------------------------------------------------------------------------
	if (cmdopts->verbose) {
		cmdinfo();
	}

----------------------------------------------------------------------------------
	if (cmdopts->infile) {
		/* The input image is to be read from a file. */
		if (!(in = jas_stream_fopen(cmdopts->infile, "rb"))) {
			fprintf(stderr, "error: cannot open input image file %s\n",
			  cmdopts->infile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The input image is to be read from standard input. */
		if (!(in = jas_stream_fdopen(0, "rb"))) {
			fprintf(stderr, "error: cannot open standard input\n");
			exit(EXIT_FAILURE);
		}
	}

----------------------------------------------------------------------------------
	if (cmdopts->outfile) {
		/* The output image is to be written to a file. */
		if (!(out = jas_stream_fopen(cmdopts->outfile, "w+b"))) {
			fprintf(stderr, "error: cannot open output image file %s\n",
			  cmdopts->outfile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The output image is to be written to standard output. */
		if (!(out = jas_stream_fdopen(1, "w+b"))) {
			fprintf(stderr, "error: cannot open standard output\n");
			exit(EXIT_FAILURE);
		}
	}

----------------------------------------------------------------------------------
	if (cmdopts->infmt < 0) {
		if ((cmdopts->infmt = jas_image_getfmt(in)) < 0) {
			fprintf(stderr, "error: input image has unknown format\n");
			exit(EXIT_FAILURE);
		}
	}

----------------------------------------------------------------------------------
	if (!(image = jas_image_decode(in, cmdopts->infmt, cmdopts->inopts))) {
		fprintf(stderr, "error: cannot load image data\n");
		exit(EXIT_FAILURE);
	}

----------------------------------------------------------------------------------
	if (cmdopts->cmptno >= 0 && cmdopts->cmptno < numcmpts) {
		for (i = numcmpts - 1; i >= 0; --i) {
			if (i != cmdopts->cmptno) {
				jas_image_delcmpt(image, i);
			}
		}
	}

----------------------------------------------------------------------------------
	if (cmdopts->srgb) {
		jas_image_t *newimage;
		jas_cmprof_t *outprof;
		jas_eprintf("forcing conversion to sRGB\n");
		if (!(outprof = jas_cmprof_createfromclrspc(JAS_CLRSPC_SRGB))) {
			jas_eprintf("cannot create sRGB profile\n");
			exit(EXIT_FAILURE);
		}
		if (!(newimage = jas_image_chclrspc(image, outprof, JAS_CMXFORM_INTENT_PER))) {
			jas_eprintf("cannot convert to sRGB\n");
			exit(EXIT_FAILURE);
		}
		jas_image_destroy(image);
		jas_cmprof_destroy(outprof);
		image = newimage;
	}

----------------------------------------------------------------------------------
	if (jas_image_encode(image, out, cmdopts->outfmt, cmdopts->outopts)) {
		fprintf(stderr, "error: cannot encode image\n");
		exit(EXIT_FAILURE);
	}

----------------------------------------------------------------------------------
	if (cmdopts->verbose) {
		fprintf(stderr, "decoding time = %f\n", dectime);
		fprintf(stderr, "encoding time = %f\n", enctime);
	}

----------------------------------------------------------------------------------
	if (jas_stream_close(out)) {
		fprintf(stderr, "error: cannot close output image file\n");
		exit(EXIT_FAILURE);
	}

----------------------------------------------------------------------------------
	if (!(cmdopts = malloc(sizeof(cmdopts_t)))) {
		fprintf(stderr, "error: insufficient memory\n");
		exit(EXIT_FAILURE);
	}

----------------------------------------------------------------------------------
		switch (c) {
		case CMDOPT_HELP:
			cmdusage();
			break;
		case CMDOPT_VERBOSE:
			cmdopts->verbose = 1;
			break;
		case CMDOPT_VERSION:
			cmdopts->version = 1;
			break;
		case CMDOPT_DEBUG:
			cmdopts->debug = atoi(jas_optarg);
			break;
		case CMDOPT_INFILE:
			cmdopts->infile = jas_optarg;
			break;
		case CMDOPT_INFMT:
			if ((cmdopts->infmt = jas_image_strtofmt(jas_optarg)) < 0) {
				fprintf(stderr, "warning: ignoring invalid input format %s\n",
				  jas_optarg);
				cmdopts->infmt = -1;
			}
			break;
		case CMDOPT_INOPT:
			addopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);
			cmdopts->inopts = cmdopts->inoptsbuf;
			break;
		case CMDOPT_OUTFILE:
			cmdopts->outfile = jas_optarg;
			break;
		case CMDOPT_OUTFMT:
			if ((cmdopts->outfmt = jas_image_strtofmt(jas_optarg)) < 0) {
				fprintf(stderr, "error: invalid output format %s\n", jas_optarg);
				badusage();
			}
			break;
		case CMDOPT_OUTOPT:
			addopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);
			cmdopts->outopts = cmdopts->outoptsbuf;
			break;
		case CMDOPT_CMPTNO:
			cmdopts->cmptno = atoi(jas_optarg);
			break;
		case CMDOPT_SRGB:
			cmdopts->srgb = 1;
			break;
		case CMDOPT_MAXMEM:
			cmdopts->max_mem = strtoull(jas_optarg, 0, 10);
			break;
		default:
			badusage();
			break;
		}

----------------------------------------------------------------------------------
	if (cmdopts->version) {
		goto done;
	}

----------------------------------------------------------------------------------
	if (cmdopts->outfmt < 0 && cmdopts->outfile) {
		if ((cmdopts->outfmt = jas_image_fmtfromname(cmdopts->outfile)) < 0) {
			fprintf(stderr,
			  "error: cannot guess image format from output file name\n");
		}
	}

----------------------------------------------------------------------------------
	if (cmdopts->outfmt < 0) {
		fprintf(stderr, "error: no output format specified\n");
		badusage();
	}

----------------------------------------------------------------------------------
	if (m > JAS_CAST(size_t, maxlen)) {
		return 1;
	}

----------------------------------------------------------------------------------
	if (n > 0) {
		strcat(optstr, "\n");
	}

----------------------------------------------------------------------------------
		if (!(fmtinfo = jas_image_lookupfmtbyid(fmtid))) {
			break;
		}

----------------------------------------------------------------------------------
	if (jas_cmxform_apply(xform, &inpixmap, &outpixmap))
		abort();

----------------------------------------------------------------------------------
	if (jas_init()) {
		abort();
	}

----------------------------------------------------------------------------------
		switch (id) {
		case OPT_VERBOSE:
			verbose = 1;
			break;
		case OPT_VERSION:
			printf("%s\n", JAS_VERSION);
			exit(EXIT_SUCCESS);
			break;
		case OPT_DEBUG:
			debug = atoi(jas_optarg);
			break;
		case OPT_INFILE:
			infile = jas_optarg;
			break;
		case OPT_MAXSAMPLES:
			max_samples = strtoull(jas_optarg, 0, 10);
			max_samples_valid = true;
			break;
		case OPT_MAXMEM:
			max_mem = strtoull(jas_optarg, 0, 10);
			break;
		case OPT_DECOPT:
			if (dec_opt_spec[0] != '\0') {
				strncat(dec_opt_spec, " ",
				  sizeof(dec_opt_spec) - 1 - strlen(dec_opt_spec));
			}
			strncat(dec_opt_spec, jas_optarg,
			  sizeof(dec_opt_spec) - 1 - strlen(dec_opt_spec));
			break;
		case OPT_HELP:
		default:
			usage();
			break;
		}

----------------------------------------------------------------------------------
	if (infile) {
		/* The image is to be read from a file. */
		if (!(instream = jas_stream_fopen(infile, "rb"))) {
			fprintf(stderr, "cannot open input image file %s\n", infile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The image is to be read from standard input. */
		if (!(instream = jas_stream_fdopen(0, "rb"))) {
			fprintf(stderr, "cannot open standard input\n");
			exit(EXIT_FAILURE);
		}
	}

----------------------------------------------------------------------------------
	if ((fmtid = jas_image_getfmt(instream)) < 0) {
		fprintf(stderr, "unknown image format\n");
	}

----------------------------------------------------------------------------------
	if (max_samples_valid) {
#if defined(JAS_HAVE_SNPRINTF)
		snprintf(optstr, sizeof(optstr), "max_samples=%-zu", max_samples);
#else
		sprintf(optstr, "max_samples=%-zu", max_samples);
#endif
		strncat(dec_opt_spec, optstr,
		  sizeof(dec_opt_spec) - 1 - strlen(dec_opt_spec));
	}

----------------------------------------------------------------------------------
	if (!(image = jas_image_decode(instream, fmtid, dec_opt_spec))) {
		jas_stream_close(instream);
		fprintf(stderr, "cannot load image\n");
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
	if (!(fmtname = jas_image_fmttostr(fmtid))) {
		jas_eprintf("format name lookup failed\n");
		return EXIT_FAILURE;
	}

----------------------------------------------------------------------------------
	if (!(numcmpts = jas_image_numcmpts(image))) {
		fprintf(stderr, "warning: image has no components\n");
	}

----------------------------------------------------------------------------------
	if (numcmpts) {
		width = jas_image_cmptwidth(image, 0);
		height = jas_image_cmptheight(image, 0);
		depth = jas_image_cmptprec(image, 0);
	} else {
		width = 0;
		height = 0;
		depth = 0;
	}

----------------------------------------------------------------------------------
	if (optstr) {
		jas_eprintf("warning: ignoring RAS encoder options\n");
	}

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(jas_image_clrspc(image))) {
	case JAS_CLRSPC_FAM_RGB:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SRGB)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 3;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R))) < 0 ||
		  (enc->cmpts[1] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G))) < 0 ||
		  (enc->cmpts[2] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	case JAS_CLRSPC_FAM_GRAY:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SGRAY)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 1;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	default:
		jas_eprintf("error: unsupported color space\n");
		return -1;
		break;
	}

----------------------------------------------------------------------------------
		if (jas_image_cmptwidth(image, enc->cmpts[cmptno]) != width ||
		  jas_image_cmptheight(image, enc->cmpts[cmptno]) != height ||
		  jas_image_cmptprec(image, enc->cmpts[cmptno]) != depth ||
		  jas_image_cmptsgnd(image, enc->cmpts[cmptno]) != false ||
		  jas_image_cmpttlx(image, enc->cmpts[cmptno]) != 0 ||
		  jas_image_cmpttly(image, enc->cmpts[cmptno]) != 0) {
			jas_eprintf("The RAS format cannot be used to represent an image with this geometry.\n");
			return -1;

----------------------------------------------------------------------------------
	if (enc->numcmpts == 3) {


----------------------------------------------------------------------------------
		if (enc->numcmpts > 1) {
			for (i = 0; i < enc->numcmpts; ++i) {

----------------------------------------------------------------------------------
				if (jas_image_cmptprec(image, enc->cmpts[i]) != 8) {
					return -1;
				}

----------------------------------------------------------------------------------
	if (ras_puthdr(out, &hdr)) {
		return -1;

----------------------------------------------------------------------------------
	if (ras_putdata(out, &hdr, image, enc->numcmpts, enc->cmpts)) {
		return -1;

----------------------------------------------------------------------------------
	switch (hdr->type) {
	case RAS_TYPE_STD:
		ret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);
		break;
	default:
		ret = -1;
		break;
	}

----------------------------------------------------------------------------------
		if (!(data[i] = jas_matrix_create(jas_image_height(image),
		  jas_image_width(image)))) {

----------------------------------------------------------------------------------
			if (jas_image_readcmpt(image, cmpts[i], 0, y,
					jas_image_width(image), 1, data[i])) {
				goto error;
			}

----------------------------------------------------------------------------------
			if (RAS_ISRGB(hdr)) {
				v = RAS_RED((jas_matrix_getv(data[0], x))) |

----------------------------------------------------------------------------------
				if (jas_stream_putc(out, c) == EOF) {
					goto error;

----------------------------------------------------------------------------------
		if (nz > 0) {
			c = (z >> (8 - nz)) & RAS_ONES(nz);

----------------------------------------------------------------------------------
			if (jas_stream_putc(out, c) == EOF) {
				goto error;

----------------------------------------------------------------------------------
		if (pad % 2) {
			if (jas_stream_putc(out, 0) == EOF) {

----------------------------------------------------------------------------------
		if (data[i]) {
			jas_matrix_destroy(data[i]);
		}

----------------------------------------------------------------------------------
	if (ras_putint(out, RAS_MAGIC) || ras_putint(out, hdr->width) ||
	  ras_putint(out, hdr->height) || ras_putint(out, hdr->depth) ||

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, c) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		return -1;
	}

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(ras_decopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_ALLOWTRUNC:
			opts->allow_trunc = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_MAXSIZE:
			opts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (ras_dec_parseopts(optstr, &opts)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (ras_gethdr(in, &hdr)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (hdr.magic != RAS_MAGIC || hdr.width <= 0 || hdr.height <= 0 ||
	  hdr.depth <= 0 || hdr.depth > 32) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul3(hdr.width, hdr.height, (hdr.depth + 7) / 8,
	  &num_samples)) {

----------------------------------------------------------------------------------
	if (opts.max_samples > 0 && num_samples > opts.max_samples) {
		jas_eprintf(
		  "maximum number of samples would be exceeded (%zu > %zu)\n",
		  num_samples, opts.max_samples);
		goto error;

----------------------------------------------------------------------------------
	if (hdr.type == RAS_TYPE_OLD) {
		hdr.length = RAS_ROWSIZE(&hdr) * hdr.height;

----------------------------------------------------------------------------------
	if (RAS_ISRGB(&hdr)) {
		clrspc = JAS_CLRSPC_SRGB;

----------------------------------------------------------------------------------
	if (!(image = jas_image_create(numcmpts, cmptparms, JAS_CLRSPC_UNKNOWN))) {
		goto error;

----------------------------------------------------------------------------------
	if (ras_getcmap(in, &hdr, &cmap)) {
		goto error;

----------------------------------------------------------------------------------
	if (ras_getdata(in, &hdr, &cmap, image)) {
		goto error;

----------------------------------------------------------------------------------
	if (clrspc == JAS_CLRSPC_SRGB) {
		jas_image_setcmpttype(image, 0,

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);
	}

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (n < RAS_MAGICLEN) {
		return -1;

----------------------------------------------------------------------------------
	if (magic != RAS_MAGIC) {
		return -1;

----------------------------------------------------------------------------------
	switch (hdr->type) {
	case RAS_TYPE_OLD:
	case RAS_TYPE_STD:
		ret = ras_getdatastd(in, hdr, cmap, image);
		break;
	case RAS_TYPE_RLE:
		jas_eprintf("error: RLE encoding method not supported\n");
		ret = -1;
		break;
	default:
		jas_eprintf("error: encoding method not supported\n");
		ret = -1;
		break;
	}

----------------------------------------------------------------------------------
		if (!(data[i] = jas_matrix_create(1, jas_image_width(image)))) {
			goto error;

----------------------------------------------------------------------------------
				if ((c = jas_stream_getc(in)) == EOF) {
					goto error;

----------------------------------------------------------------------------------
			if (jas_image_numcmpts(image) == 3) {
				jas_matrix_setv(data[0], x, (RAS_GETRED(v)));

----------------------------------------------------------------------------------
		if (pad) {
			if ((c = jas_stream_getc(in)) == EOF) {

----------------------------------------------------------------------------------
			if (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,
			  data[i])) {
				goto error;
			}

----------------------------------------------------------------------------------
		if (data[i]) {
			jas_matrix_destroy(data[i]);

----------------------------------------------------------------------------------
	switch (hdr->maptype) {
	case RAS_MT_NONE:
		break;
	case RAS_MT_EQUALRGB:
		{
		jas_eprintf("warning: palettized images not fully supported\n");
		numcolors = 1 << hdr->depth;
		if (numcolors > RAS_CMAP_MAXSIZ) {
			return -1;
		}
		actualnumcolors = hdr->maplength / 3;
		for (i = 0; i < numcolors; i++) {
			cmap->data[i] = 0;
		}
		if ((hdr->maplength % 3) || hdr->maplength < 0 ||
		  hdr->maplength > 3 * numcolors) {
			return -1;
		}
		for (i = 0; i < 3; i++) {
			for (j = 0; j < actualnumcolors; j++) {
				if ((c = jas_stream_getc(in)) == EOF) {
					return -1;
				}
				x = 0;
				switch (i) {
				case 0:
					x = RAS_RED(c);
					break;
				case 1:
					x = RAS_GREEN(c);
					break;
				case 2:
					x = RAS_BLUE(c);
					break;
				}
				cmap->data[j] |= x;
			}
		}
		}
		break;
	default:
		return -1;
		break;
	}

----------------------------------------------------------------------------------
	if (ras_getint(in, &hdr->magic) || ras_getint(in, &hdr->width) ||
	  ras_getint(in, &hdr->height) || ras_getint(in, &hdr->depth) ||

----------------------------------------------------------------------------------
	if (hdr->magic != RAS_MAGIC) {
		return -1;
	}

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (n < JPG_MAGICLEN) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, c) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (sinfo->error) {
		return 0;
	}

----------------------------------------------------------------------------------
		if (jas_image_readcmpt(sinfo->image, cmpts[cmptno], 0, sinfo->row, width, 1, sinfo->data)) {
			;
		}

----------------------------------------------------------------------------------
	if (jpg_parseencopts(optstr, &encopts)) {
		goto error;
	}

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(jas_image_clrspc(image))) {
	case JAS_CLRSPC_FAM_RGB:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SRGB)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 3;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R))) < 0 ||
		  (enc->cmpts[1] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G))) < 0 ||
		  (enc->cmpts[2] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))) < 0) {
			jas_eprintf("error: missing color component\n");
			goto error;
		}
		break;
	case JAS_CLRSPC_FAM_YCBCR:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SYCBCR)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 3;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y))) < 0 ||
		  (enc->cmpts[1] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB))) < 0 ||
		  (enc->cmpts[2] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))) < 0) {
			jas_eprintf("error: missing color component\n");
			goto error;
		}
		break;
	case JAS_CLRSPC_FAM_GRAY:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SGRAY)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 1;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y))) < 0) {
			jas_eprintf("error: missing color component\n");
			goto error;
		}
		break;
	default:
		jas_eprintf("error: JPG format does not support color space\n");
		goto error;
		break;
	}

----------------------------------------------------------------------------------
		if (jas_image_cmptwidth(image, enc->cmpts[cmptno]) != width ||
		  jas_image_cmptheight(image, enc->cmpts[cmptno]) != height ||
		  jas_image_cmpttlx(image, enc->cmpts[cmptno]) != 0 ||
		  jas_image_cmpttly(image, enc->cmpts[cmptno]) != 0 ||
		  jas_image_cmpthstep(image, enc->cmpts[cmptno]) != 1 ||
		  jas_image_cmptvstep(image, enc->cmpts[cmptno]) != 1 ||
		  jas_image_cmptprec(image, enc->cmpts[cmptno]) != 8 ||
		  jas_image_cmptsgnd(image, enc->cmpts[cmptno]) != false) {
			jas_eprintf("error: The JPG encoder cannot handle an image with this geometry.\n");
			goto error;

----------------------------------------------------------------------------------
	if (!(output_file = tmpfile())) {
		goto error;

----------------------------------------------------------------------------------
	if (encopts.qual >= 0) {
		jpeg_set_quality(&cinfo, encopts.qual, TRUE);

----------------------------------------------------------------------------------
		if ((numscanlines = jpg_get_pixel_rows(&cinfo, src_mgr)) <= 0) {
			break;

----------------------------------------------------------------------------------
	if (output_file) {
		fclose(output_file);

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(colorspace)) {
	case JAS_CLRSPC_FAM_RGB:
		return JCS_RGB;
		break;
	case JAS_CLRSPC_FAM_YCBCR:
		return JCS_YCbCr;
		break;
	case JAS_CLRSPC_FAM_GRAY:
		return JCS_GRAYSCALE;
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		goto error;

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(jpg_opttab,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_QUAL:
			qual_str = jas_tvparser_getval(tvp);
			if (sscanf(qual_str, "%d", &encopts->qual) != 1) {
				jas_eprintf("ignoring bad quality specifier %s\n",
					jas_tvparser_getval(tvp));
				encopts->qual = -1;
			}
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (ret < 0) {
		goto error;

----------------------------------------------------------------------------------
	if (tvp) {
		jas_tvparser_destroy(tvp);

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		return -1;
	}

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_MAXSIZE:
			opts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);
			break;
		case OPT_VERSION:
			opts->print_version = true;
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (jpg_dec_parseopts(optstr, &opts)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (opts.print_version) {
		printf("%d %s\n", JPEG_LIB_VERSION, jas_libjpeg_turbo_version);
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(input_file = tmpfile())) {
		jas_eprintf("cannot make temporary file\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (jpg_copystreamtofile(input_file, in)) {
		jas_eprintf("cannot copy stream\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (ret != JPEG_HEADER_OK) {
		jas_eprintf("jpeg_read_header did not return JPEG_HEADER_OK\n");
	}

----------------------------------------------------------------------------------
	if (opts.max_samples > 0) {
		if (!jas_safe_size_mul3(cinfo.image_width, cinfo.image_height,
		  cinfo.num_components, &num_samples)) {
			goto error;
		}
		if (num_samples > opts.max_samples) {
			jas_eprintf("image is too large (%zu > %zu)\n", num_samples,
			  opts.max_samples);
			goto error;
		}
	}

----------------------------------------------------------------------------------
	if (!(image = jpg_mkimage(&cinfo))) {
		jas_eprintf("jpg_mkimage failed\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(dest_mgr->data = jas_matrix_create(1, cinfo.output_width))) {
		jas_eprintf("jas_matrix_create failed\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (dest_mgr->error) {
		jas_eprintf("error during decoding\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (dest_mgr->data) {
		jas_matrix_destroy(dest_mgr->data);
	}

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);
	}

----------------------------------------------------------------------------------
	if (input_file) {
		fclose(input_file);
	}

----------------------------------------------------------------------------------
	if (!(image = jas_image_create0())) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (cinfo->image_width > JAS_IMAGE_COORD_MAX ||
		  cinfo->image_height > JAS_IMAGE_COORD_MAX) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (jas_image_addcmpt(image, cmptno, &cmptparm)) {
			goto error;

----------------------------------------------------------------------------------
	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);

----------------------------------------------------------------------------------
		if (fputc(c, out) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (jas_stream_error(in)) {
		return -1;

----------------------------------------------------------------------------------
	if (dinfo->error) {
		return;

----------------------------------------------------------------------------------
		if (jas_image_writecmpt(dinfo->image, cmptno, 0, dinfo->row, width, 1,
		  dinfo->data)) {

----------------------------------------------------------------------------------
	if (optstr) {
		jas_eprintf("warning: ignoring BMP encoder options\n");
	}

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(clrspc)) {
	case JAS_CLRSPC_FAM_RGB:
		if (clrspc != JAS_CLRSPC_SRGB)
			jas_eprintf("warning: inaccurate color\n");
		break;
	case JAS_CLRSPC_FAM_GRAY:
		if (clrspc != JAS_CLRSPC_SGRAY)
			jas_eprintf("warning: inaccurate color\n");
		break;
	default:
		jas_eprintf("error: BMP format does not support color space\n");
		return -1;
		break;
	}

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(clrspc)) {
	case JAS_CLRSPC_FAM_RGB:
		enc->numcmpts = 3;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R))) < 0 ||
		  (enc->cmpts[1] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G))) < 0 ||
		  (enc->cmpts[2] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	case JAS_CLRSPC_FAM_GRAY:
		enc->numcmpts = 1;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
		if (jas_image_cmptwidth(image, enc->cmpts[cmptno]) != width ||
		  jas_image_cmptheight(image, enc->cmpts[cmptno]) != height ||
		  jas_image_cmptprec(image, enc->cmpts[cmptno]) != depth ||
		  jas_image_cmptsgnd(image, enc->cmpts[cmptno]) != false ||
		  jas_image_cmpttlx(image, enc->cmpts[cmptno]) != 0 ||
		  jas_image_cmpttly(image, enc->cmpts[cmptno]) != 0) {
			jas_eprintf("The BMP format cannot be used to represent an image with this geometry.\n");
			return -1;

----------------------------------------------------------------------------------
	if (depth != 1 && depth != 4 && depth != 8) {
		return -1;

----------------------------------------------------------------------------------
	if (numpad) {
		numpad = 4 - numpad;

----------------------------------------------------------------------------------
	if (!(info = bmp_info_create())) {
		return -1;

----------------------------------------------------------------------------------
	if (bmp_puthdr(out, &hdr)) {
		goto error;

----------------------------------------------------------------------------------
	if (bmp_putinfo(out, info)) {
		goto error;

----------------------------------------------------------------------------------
	if (bmp_putdata(out, info, image, enc->cmpts)) {
		goto error;

----------------------------------------------------------------------------------
	if (info) {
		bmp_info_destroy(info);

----------------------------------------------------------------------------------
	if (bmp_putint16(out, hdr->magic) || bmp_putint32(out, hdr->siz) ||
	  bmp_putint32(out, 0) || bmp_putint32(out, hdr->off)) {

----------------------------------------------------------------------------------
	if (bmp_putint32(out, info->len) ||
	  bmp_putint32(out, info->width) ||
	  bmp_putint32(out, info->height) ||
	  bmp_putint16(out, info->numplanes) ||
	  bmp_putint16(out, info->depth) ||
	  bmp_putint32(out, info->enctype) ||
	  bmp_putint32(out, info->siz) ||
	  bmp_putint32(out, info->hres) ||
	  bmp_putint32(out, info->vres) ||
	  bmp_putint32(out, info->numcolors) ||
	  bmp_putint32(out, info->mincolors)) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, i) == EOF ||
		  jas_stream_putc(out, i) == EOF ||

----------------------------------------------------------------------------------
	if (BMP_HASPAL(info) && numcmpts == 3) {
		jas_eprintf("no palettized image support for BMP format\n");
		return -1;

----------------------------------------------------------------------------------
		if (!(bufs[i] = jas_matrix_create(1, info->width))) {
			ret = -1;

----------------------------------------------------------------------------------
	if (numpad) {
		numpad = 4 - numpad;

----------------------------------------------------------------------------------
			if (jas_image_readcmpt(image, cmptno, 0, i, info->width,
			  1, bufs[cmpts[cmptno]])) {

----------------------------------------------------------------------------------
			if (numcmpts == 3) {
				red = (jas_matrix_getv(bufs[0], j));
				grn = (jas_matrix_getv(bufs[1], j));

----------------------------------------------------------------------------------
				if (jas_stream_putc(out, blu) == EOF ||
				  jas_stream_putc(out, grn) == EOF ||

----------------------------------------------------------------------------------
				if (jas_stream_putc(out, v) == EOF) {
					ret = -1;
					goto bmp_putdata_done;

----------------------------------------------------------------------------------
			if (jas_stream_putc(out, 0) == EOF) {
				ret = -1;

----------------------------------------------------------------------------------
		if (bufs[i]) {
			jas_matrix_destroy(bufs[i]);

----------------------------------------------------------------------------------
	if (jas_stream_putc(in, val & 0xff) == EOF || jas_stream_putc(in, (val >> 8) &
	  0xff) == EOF) {

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, v & 0xff) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (--n <= 0) {
			break;

----------------------------------------------------------------------------------
	if (!(info = jas_malloc(sizeof(bmp_info_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (info->palents) {
		jas_free(info->palents);
	}

----------------------------------------------------------------------------------
		if (palent->red != palent->grn || palent->red != palent->blu) {
			return 0;
		}

----------------------------------------------------------------------------------
	if (info->depth == 24) {
		numcmpts = 3;
	} else if (info->depth == 8) {
		numcmpts = bmp_isgrayscalepal(info->palents, info->numcolors) ?
		  1 : 3;
	} else {
		numcmpts = 0;
		abort();
	}

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		return -1;
	}

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_MAXSIZE:
			opts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (bmp_dec_parseopts(optstr, &opts)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (bmp_gethdr(in, &hdr)) {
		jas_eprintf("cannot get header\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(info = bmp_getinfo(in))) {
		jas_eprintf("cannot get info\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
		jas_eprintf("corrupt bit stream\n");
		goto error;

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul3(info->width, info->height, info->numplanes,
	  &num_samples)) {

----------------------------------------------------------------------------------
	if (opts.max_samples > 0 && num_samples > opts.max_samples) {
		jas_eprintf("maximum number of pixels exceeded (%zu)\n",
		  opts.max_samples);
		goto error;

----------------------------------------------------------------------------------
	if (!bmp_issupported(&hdr, info)) {
		jas_eprintf("error: unsupported BMP encoding\n");

----------------------------------------------------------------------------------
	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
		jas_eprintf("error: possibly bad bitmap offset?\n");

----------------------------------------------------------------------------------
	if (n > 0) {
		jas_eprintf("skipping unknown data in BMP file\n");

----------------------------------------------------------------------------------
		if (bmp_gobble(in, n)) {
			goto error;

----------------------------------------------------------------------------------
	if (!(image = jas_image_create(numcmpts, cmptparms,
	  JAS_CLRSPC_UNKNOWN))) {

----------------------------------------------------------------------------------
	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,

----------------------------------------------------------------------------------
	if (bmp_getdata(in, info, image)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (info) {
		bmp_info_destroy(info);

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (n < 2) {
		return -1;

----------------------------------------------------------------------------------
	if (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {
		return 0;

----------------------------------------------------------------------------------
	if (bmp_getint16(in, &hdr->magic) || hdr->magic != BMP_MAGIC ||
	  bmp_getint32(in, &hdr->siz) || bmp_getint16(in, &hdr->reserved1) ||

----------------------------------------------------------------------------------
	if (!(info = bmp_info_create())) {
		goto error;
		return 0;

----------------------------------------------------------------------------------
	if (bmp_getint32(in, &info->len) || info->len != 40 ||
	  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||

----------------------------------------------------------------------------------
	if (info->height < 0) {
		info->topdown = 1;
		info->height = -info->height;

----------------------------------------------------------------------------------
	if (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||
	  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {

----------------------------------------------------------------------------------
	if (info->depth != 8 && info->depth != 24) {
		jas_eprintf(
		  "BMP decoder only supports images with depth 8 or 24 "
		  "(depth %d)\n", info->depth);
		goto error;

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(info->width, info->height, &num_pixels)) {
		jas_eprintf("image dimensions too large\n");

----------------------------------------------------------------------------------
	if (info->enctype != BMP_ENC_RGB) {
		jas_eprintf("unsupported BMP encoding\n");

----------------------------------------------------------------------------------
	if (info->numcolors > 256 && info->numcolors > num_pixels) {
		jas_eprintf("palette size is greater than 256 and "

----------------------------------------------------------------------------------
	if (info->numcolors > 0) {
		if (!(info->palents = jas_alloc2(info->numcolors,
		  sizeof(bmp_palent_t)))) {
			goto error;
		}
	} else {

----------------------------------------------------------------------------------
		if ((palent->blu = jas_stream_getc(in)) == EOF ||
		  (palent->grn = jas_stream_getc(in)) == EOF ||
		  (palent->red = jas_stream_getc(in)) == EOF ||
		  (palent->res = jas_stream_getc(in)) == EOF) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (info) {
		bmp_info_destroy(info);

----------------------------------------------------------------------------------
		if (!(cmpts[i] = jas_matrix_create(1, info->width))) {
			ret = -1;

----------------------------------------------------------------------------------
	if (numpad) {
		numpad = 4 - numpad;

----------------------------------------------------------------------------------
			if (haspal) {
				if ((ind = jas_stream_getc(in)) == EOF) {

----------------------------------------------------------------------------------
				if (ind > mxind) {
					ret = -1;
					goto bmp_getdata_done;

----------------------------------------------------------------------------------
				if (ind < info->numcolors) {
					palent = &info->palents[ind];

----------------------------------------------------------------------------------
				if ((blu = jas_stream_getc(in)) == EOF ||
				  (grn = jas_stream_getc(in)) == EOF ||

----------------------------------------------------------------------------------
			if (numcmpts == 3) {
				jas_matrix_setv(cmpts[0], j, red);
				jas_matrix_setv(cmpts[1], j, grn);

----------------------------------------------------------------------------------
				if (jas_stream_getc(in) == EOF) {
					ret = -1;

----------------------------------------------------------------------------------
			if (jas_image_writecmpt(image, cmptno, 0, y, info->width,
			  1, cmpts[cmptno])) {

----------------------------------------------------------------------------------
		if (cmpts[i]) {
			jas_matrix_destroy(cmpts[i]);
		}

----------------------------------------------------------------------------------
	if ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = (hi << 8) | lo;

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if (--n <= 0) {
			break;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
		if (jas_stream_getc(in) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(jas_image_clrspc(image))) {
	case JAS_CLRSPC_FAM_GRAY:
		if ((enc->cmpt = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	default:
		jas_eprintf("error: PGX format does not support color space\n");
		return -1;
		break;
	}

----------------------------------------------------------------------------------
	if (jas_image_numcmpts(image) > 1 || prec > 16) {
		jas_eprintf("The PGX format cannot be used to represent an image with this geometry.\n");
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 10) {
		pgx_dumphdr(stderr, &hdr);
	}

----------------------------------------------------------------------------------
	if (pgx_puthdr(out, &hdr)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (pgx_putdata(out, &hdr, image, enc->cmpt)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_stream_error(out)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(data = jas_matrix_create(1, hdr->width))) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (jas_image_readcmpt(image, cmpt, 0, y, hdr->width, 1, data)) {
			goto error;
		}

----------------------------------------------------------------------------------
			if (pgx_putword(out, hdr->bigendian, hdr->prec, word)) {
				goto error;
			}

----------------------------------------------------------------------------------
	if (data) {
		jas_matrix_destroy(data);
	}

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, (val >> (8 * j)) & 0xff) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		return -1;
	}

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(pgx_decopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_ALLOWTRUNC:
			opts->allow_trunc = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_MAXSIZE:
			opts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (pgx_dec_parseopts(optstr, &opts)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_gethdr(in, &hdr)) {
		jas_eprintf("cannot get header\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 10) {
		pgx_dumphdr(stderr, &hdr);
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(hdr.width, hdr.height, &num_samples)) {
		jas_eprintf("image too large\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (opts.max_samples > 0 && num_samples > opts.max_samples) {
		jas_eprintf(
		  "maximum number of samples would be exceeded (%zu > %zu)\n",
		  num_samples, opts.max_samples);
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(image = jas_image_create0())) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jas_image_addcmpt(image, 0, &cmptparm)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_getdata(in, &hdr, image)) {
		jas_eprintf("cannot get data\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);
	}

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (n < PGX_MAGICLEN) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (magic != PGX_MAGIC) {
		return -1;
	}

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		goto error;
	}

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (hdr->magic != PGX_MAGIC) {
		jas_eprintf("invalid PGX signature\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if ((c = pgx_getc(in)) == EOF || !isspace(c)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_getbyteorder(in, &hdr->bigendian)) {
		jas_eprintf("cannot get byte order\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_getsgnd(in, &hdr->sgnd)) {
		jas_eprintf("cannot get signedness\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_getuint32(in, &hdr->prec)) {
		jas_eprintf("cannot get precision\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_getuint32(in, &hdr->width)) {
		jas_eprintf("cannot get width\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (pgx_getuint32(in, &hdr->height)) {
		jas_eprintf("cannot get height\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(data = jas_matrix_create(1, hdr->width))) {
		goto error;
	}

----------------------------------------------------------------------------------
			if ((v = pgx_getword(in, hdr->bigendian, hdr->prec)) < 0) {
				goto error;
			}

----------------------------------------------------------------------------------
		if (jas_image_writecmpt(image, 0, 0, y, hdr->width, 1, data)) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (data) {
		jas_matrix_destroy(data);
	}

----------------------------------------------------------------------------------
	if (prec > 32) {
		goto error;
	}

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			goto error;
		}

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (c != '#') {
			return c;
		}

----------------------------------------------------------------------------------
			if ((c = jas_stream_getc(in)) == EOF) {
				return -1;
			}

----------------------------------------------------------------------------------
		if ((c = pgx_getc(in)) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if ((c = pgx_getc(in)) == EOF) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (buf[0] == 'M' && buf[1] == 'L') {
		*bigendian = true;
	} else if (buf[0] == 'L' && buf[1] == 'M') {
		*bigendian = false;
	} else {
		goto error;
	}

----------------------------------------------------------------------------------
	if (c == EOF) {
		goto error;
	}

----------------------------------------------------------------------------------
		if ((c = pgx_getc(in)) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (c == '+') {
		*sgnd = false;
	} else if (c == '-') {
		*sgnd = true;
	} else {
		*sgnd = false;
		if (jas_stream_ungetc(in, c)) {
			goto error;
		}
		return 0;
	}

----------------------------------------------------------------------------------
	if (c == EOF) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (c == '+' || c == '-') {
		*sgnd = (c == '-');
		while ((c = pgx_getc(in)) != EOF && !isspace(c)) {
			;
		}
		if (c == EOF) {
			goto error;
		}
	} else {
		*sgnd = false;
		if (jas_stream_ungetc(in, c)) {
			goto error;
		}
	}

----------------------------------------------------------------------------------
		if ((c = pgx_getc(in)) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
		if ((c = pgx_getc(in)) < 0) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (!isspace(c)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(dec = jp2_dec_create())) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(box = jp2_box_get(in))) {
		jas_eprintf("error: cannot get box\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (box->type != JP2_BOX_JP) {
		jas_eprintf("error: expecting signature box\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf("incorrect magic number\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(box = jp2_box_get(in))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf("expecting file type box\n");
		goto error;
	}

----------------------------------------------------------------------------------
		if (jas_getdbglevel() >= 1) {
			jas_eprintf("got box type %s\n", box->info->name);
		}

----------------------------------------------------------------------------------
		switch (box->type) {
		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}

----------------------------------------------------------------------------------
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}

----------------------------------------------------------------------------------
		if (found) {
			break;
		}

----------------------------------------------------------------------------------
	if (!found) {
		jas_eprintf("error: no code stream found\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf("error: cannot decode code stream\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!dec->ihdr) {
		jas_eprintf("error: missing IHDR box\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf("warning: number of components mismatch\n");
	}

----------------------------------------------------------------------------------
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf("error: no components\n");

----------------------------------------------------------------------------------
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;

----------------------------------------------------------------------------------
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {

----------------------------------------------------------------------------------
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf("error: unsupported compression type\n");
		goto error;

----------------------------------------------------------------------------------
	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box

----------------------------------------------------------------------------------
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(
		  dec->image))) {

----------------------------------------------------------------------------------
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf("warning: component data type mismatch\n");
				}
			}
		} else {

----------------------------------------------------------------------------------
	if (!dec->colr) {
		jas_eprintf("error: no COLR box\n");
		goto error;

----------------------------------------------------------------------------------
	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf("error: failed to parse ICC profile\n");
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf("ICC Profile CS %08x\n", icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

----------------------------------------------------------------------------------
	if (dec->cmap && !dec->pclr) {
		jas_eprintf("warning: missing PCLR box or superfluous CMAP box\n");

----------------------------------------------------------------------------------
	if (!dec->cmap && dec->pclr) {
		jas_eprintf("warning: missing CMAP box or superfluous PCLR box\n");

----------------------------------------------------------------------------------
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {

----------------------------------------------------------------------------------
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf("error: invalid component number in CMAP box\n");
				goto error;

----------------------------------------------------------------------------------
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {

----------------------------------------------------------------------------------
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf("error: no memory\n");
		goto error;

----------------------------------------------------------------------------------
	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {

----------------------------------------------------------------------------------
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {

----------------------------------------------------------------------------------
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {

----------------------------------------------------------------------------------
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {

----------------------------------------------------------------------------------
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}

----------------------------------------------------------------------------------
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf("error: no components\n");

----------------------------------------------------------------------------------
	if (box) {
		jp2_box_destroy(box);

----------------------------------------------------------------------------------
	if (dec) {
		jp2_dec_destroy(dec);

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, buf, JP2_VALIDATELEN)) < 0) {
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (n < JP2_VALIDATELEN) {
		return -1;

----------------------------------------------------------------------------------
	if (((buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]) !=
	  JP2_BOX_JP)

----------------------------------------------------------------------------------
	if (!(dec = jas_malloc(sizeof(jp2_dec_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (dec->ihdr) {
		jp2_box_destroy(dec->ihdr);

----------------------------------------------------------------------------------
	if (dec->bpcc) {
		jp2_box_destroy(dec->bpcc);

----------------------------------------------------------------------------------
	if (dec->cdef) {
		jp2_box_destroy(dec->cdef);

----------------------------------------------------------------------------------
	if (dec->pclr) {
		jp2_box_destroy(dec->pclr);

----------------------------------------------------------------------------------
	if (dec->image) {
		jas_image_destroy(dec->image);

----------------------------------------------------------------------------------
	if (dec->cmap) {
		jp2_box_destroy(dec->cmap);

----------------------------------------------------------------------------------
	if (dec->colr) {
		jp2_box_destroy(dec->colr);

----------------------------------------------------------------------------------
	if (dec->chantocmptlut) {
		jas_free(dec->chantocmptlut);

----------------------------------------------------------------------------------
	if (type == 1 && assoc == 0) {
		return JAS_IMAGE_CT_OPACITY;

----------------------------------------------------------------------------------
	if (type == 0 && assoc >= 1 && assoc <= 65534) {
		switch (colorspace) {

----------------------------------------------------------------------------------
			switch (assoc) {
			case JP2_CDEF_RGB_R:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R);
				break;
			case JP2_CDEF_RGB_G:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G);
				break;
			case JP2_CDEF_RGB_B:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B);
				break;
			}

----------------------------------------------------------------------------------
			switch (assoc) {
			case JP2_CDEF_YCBCR_Y:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y);
				break;
			case JP2_CDEF_YCBCR_CB:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB);
				break;
			case JP2_CDEF_YCBCR_CR:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR);
				break;
			}

----------------------------------------------------------------------------------
			switch (assoc) {
			case JP2_CDEF_GRAY_Y:
				return JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y);
				break;
			}

----------------------------------------------------------------------------------
	if (colr->method == JP2_COLR_ENUM) {
		switch (colr->csid) {
		case JP2_COLR_SRGB:
			return JAS_CLRSPC_SRGB;

----------------------------------------------------------------------------------
	switch (cs) {
	case ICC_CS_RGB:
		return JAS_CLRSPC_GENRGB;
		break;
	case ICC_CS_YCBCR:
		return JAS_CLRSPC_GENYCBCR;
		break;
	case ICC_CS_GRAY:
		return JAS_CLRSPC_GENGRAY;
		break;
	}

----------------------------------------------------------------------------------
	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(boxinfo = jp2_boxinfolookup(type))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (box->ops->destroy) {
		(*box->ops->destroy)(box);
	}

----------------------------------------------------------------------------------
	if (bpcc->bpcs) {
		jas_free(bpcc->bpcs);
		bpcc->bpcs = 0;
	}

----------------------------------------------------------------------------------
	if (cdef->ents) {
		jas_free(cdef->ents);
		cdef->ents = 0;
	}

----------------------------------------------------------------------------------
	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf("warning: cannot handle large 64-bit box length\n");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}

----------------------------------------------------------------------------------
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf("cannot copy box data\n");
			goto error;
		}
		jas_stream_rewind(tmpstream);

		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf("cannot parse box data\n");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

----------------------------------------------------------------------------------
	if (box) {
		jp2_box_destroy(box);
	}

----------------------------------------------------------------------------------
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}

----------------------------------------------------------------------------------
	if (box->ops->dumpdata) {
		(*box->ops->dumpdata)(box, out);
	}

----------------------------------------------------------------------------------
	if (jp2_getuint32(in, &jp->magic)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (jp2_getuint32(in, &ftyp->compatcodes[i])) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||
	  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||
	  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||
	  jp2_getuint8(in, &ihdr->ipr)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
			return -1;

----------------------------------------------------------------------------------
	switch (colr->method) {
	case JP2_COLR_ENUM:
		fprintf(out, "csid=%d\n", (int)colr->csid);
		break;
	case JP2_COLR_ICC:
		jas_memdump(out, colr->iccp, colr->iccplen);
		break;
	}

----------------------------------------------------------------------------------
	if (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||
	  jp2_getuint8(in, &colr->approx)) {

----------------------------------------------------------------------------------
	switch (colr->method) {
	case JP2_COLR_ENUM:
		if (jp2_getuint32(in, &colr->csid)) {
			return -1;
		}
		break;
	case JP2_COLR_ICC:
		colr->iccplen = box->datalen - 3;
		if (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {
			return -1;
		}
		if (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {
			return -1;
		}
		break;
	}

----------------------------------------------------------------------------------
	if (colr->iccp) {
		jas_free(colr->iccp);
	}

----------------------------------------------------------------------------------
	if (jp2_getuint16(in, &cdef->numchans)) {
		return -1;

----------------------------------------------------------------------------------
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {

----------------------------------------------------------------------------------
	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (box->ops->putdata) {

----------------------------------------------------------------------------------
			if ((*box->ops->putdata)(box, tmpstream)) {
				goto error;
			}

----------------------------------------------------------------------------------
	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
		goto error;

----------------------------------------------------------------------------------
	if (jp2_putuint32(out, box->type)) {
		goto error;

----------------------------------------------------------------------------------
	if (extlen) {
		if (jp2_putuint64(out, box->len)) {

----------------------------------------------------------------------------------
	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
			goto error;
		}
		jas_stream_close(tmpstream);

----------------------------------------------------------------------------------
	if (tmpstream) {
		jas_stream_close(tmpstream);

----------------------------------------------------------------------------------
	if (jp2_putuint32(out, jp->magic)) {
		return -1;

----------------------------------------------------------------------------------
	if (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {
		return -1;

----------------------------------------------------------------------------------
		if (jp2_putuint32(out, ftyp->compatcodes[i])) {
			return -1;

----------------------------------------------------------------------------------
	if (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||
	  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||

----------------------------------------------------------------------------------
		if (jp2_putuint8(out, bpcc->bpcs[i])) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||
	  jp2_putuint8(out, colr->approx)) {

----------------------------------------------------------------------------------
	switch (colr->method) {
	case JP2_COLR_ENUM:
		if (jp2_putuint32(out, colr->csid)) {
			return -1;
		}
		break;
	case JP2_COLR_ICC:
		if (jas_stream_write(out, colr->iccp,
		  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))
			return -1;
		break;
	}

----------------------------------------------------------------------------------
	if (jp2_putuint16(out, cdef->numchans)) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (jp2_putuint16(out, ent->channo) ||
		  jp2_putuint16(out, ent->type) ||

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (val) {
		*val = c;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, val & 0xff) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||
	  jas_stream_putc(out, val & 0xff) == EOF) {

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||
	  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||
	  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||
	  jas_stream_putc(out, val & 0xff) == EOF) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||
	  jp2_putuint32(out, val & 0xffffffffUL)) {

----------------------------------------------------------------------------------
		if (boxinfo->type == type) {
			return boxinfo;
		}

----------------------------------------------------------------------------------
	if (cmap->ents) {
		jas_free(cmap->ents);

----------------------------------------------------------------------------------
	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||

----------------------------------------------------------------------------------
	if (pclr->lutdata) {
		jas_free(pclr->lutdata);
	}

----------------------------------------------------------------------------------
	if (pclr->bpc)
		jas_free(pclr->bpc);

----------------------------------------------------------------------------------
	if (jp2_getuint16(in, &pclr->numlutents) ||
	  jp2_getuint8(in, &pclr->numchans)) {

----------------------------------------------------------------------------------
	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (jp2_getuint8(in, &pclr->bpc[i])) {
			return -1;

----------------------------------------------------------------------------------
			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
			  (pclr->bpc[j] & 0x7f) + 1, &x)) {

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (s) {
		int sb;

----------------------------------------------------------------------------------
		if (sb) {
			*val = -*val;

----------------------------------------------------------------------------------
		if (cdefent->channo == JAS_CAST(unsigned int, channo)) {
			return cdefent;

----------------------------------------------------------------------------------
		if (jas_image_cmptsgnd(image, i) != sgnd ||
		  jas_image_cmptprec(image, i) != prec) {
			allcmptssame = 0;
			break;

----------------------------------------------------------------------------------
	if (!(box = jp2_box_create(JP2_BOX_JP))) {
		goto error;

----------------------------------------------------------------------------------
	if (jp2_box_put(box, out)) {
		goto error;

----------------------------------------------------------------------------------
	if (!(box = jp2_box_create(JP2_BOX_FTYP))) {
		goto error;

----------------------------------------------------------------------------------
	if (jp2_box_put(box, out)) {
		goto error;

----------------------------------------------------------------------------------
	if (!(tmpstream = jas_stream_memopen(0, 0))) {
		goto error;

----------------------------------------------------------------------------------
	if (!(box = jp2_box_create(JP2_BOX_IHDR))) {
		goto error;

----------------------------------------------------------------------------------
	if (jp2_box_put(box, tmpstream)) {
		goto error;

----------------------------------------------------------------------------------
	if (!allcmptssame) {
		if (!(box = jp2_box_create(JP2_BOX_BPCC))) {

----------------------------------------------------------------------------------
		if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,
		  sizeof(uint_fast8_t)))) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (jp2_box_put(box, tmpstream)) {
			goto error;

----------------------------------------------------------------------------------
	if (!(box = jp2_box_create(JP2_BOX_COLR))) {
		goto error;

----------------------------------------------------------------------------------
	switch (jas_image_clrspc(image)) {
	case JAS_CLRSPC_SRGB:
	case JAS_CLRSPC_SYCBCR:
	case JAS_CLRSPC_SGRAY:
		colr->method = JP2_COLR_ENUM;
		colr->csid = clrspctojp2(jas_image_clrspc(image));
		colr->pri = JP2_COLR_PRI;
		colr->approx = 0;
		break;
	default:
		colr->method = JP2_COLR_ICC;
		colr->pri = JP2_COLR_PRI;
		colr->approx = 0;
		/* Ensure that cmprof_ is not null. */
		if (!jas_image_cmprof(image)) {
			goto error;
		}
		if (!(iccprof = jas_iccprof_createfromcmprof(
		  jas_image_cmprof(image)))) {
			goto error;
		}
		if (!(iccstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_iccprof_save(iccprof, iccstream)) {
			goto error;
		}
		if ((pos = jas_stream_tell(iccstream)) < 0) {
			goto error;
		}
		colr->iccplen = pos;
		if (!(colr->iccp = jas_malloc(pos))) {
			goto error;
		}
		jas_stream_rewind(iccstream);
		if (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=
		  colr->iccplen) {
			goto error;
		}
		jas_stream_close(iccstream);
		iccstream = 0;
		jas_iccprof_destroy(iccprof);
		iccprof = 0;
		break;
	}

----------------------------------------------------------------------------------
	if (jp2_box_put(box, tmpstream)) {
		goto error;

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(jas_image_clrspc(image))) {
	case JAS_CLRSPC_FAM_RGB:
		if (jas_image_cmpttype(image, 0) ==
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&
		  jas_image_cmpttype(image, 1) ==
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&
		  jas_image_cmpttype(image, 2) ==
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))
			needcdef = 0;
		break;
	case JAS_CLRSPC_FAM_YCBCR:
		if (jas_image_cmpttype(image, 0) ==
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&
		  jas_image_cmpttype(image, 1) ==
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&
		  jas_image_cmpttype(image, 2) ==
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))
			needcdef = 0;
		break;
	case JAS_CLRSPC_FAM_GRAY:
		if (jas_image_cmpttype(image, 0) ==
		  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))
			needcdef = 0;
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (needcdef) {
		if (!(box = jp2_box_create(JP2_BOX_CDEF))) {

----------------------------------------------------------------------------------
		if (jp2_box_put(box, tmpstream)) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (!(box = jp2_box_create(JP2_BOX_JP2H))) {
		goto error;

----------------------------------------------------------------------------------
	if (jp2_box_put(box, out)) {
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_copy(out, tmpstream, len)) {
		goto error;

----------------------------------------------------------------------------------
	if (!(box = jp2_box_create(JP2_BOX_JP2C))) {
		goto error;

----------------------------------------------------------------------------------
	if (jp2_box_put(box, out)) {
		goto error;

----------------------------------------------------------------------------------
	if (jpc_encode(image, out, buf)) {
		goto error;

----------------------------------------------------------------------------------
	if (iccprof) {
		jas_iccprof_destroy(iccprof);

----------------------------------------------------------------------------------
	if (iccstream) {
		jas_stream_close(iccstream);

----------------------------------------------------------------------------------
	if (box) {
		jp2_box_destroy(box);

----------------------------------------------------------------------------------
	if (tmpstream) {
		jas_stream_close(tmpstream);

----------------------------------------------------------------------------------
	if (ctype & JAS_IMAGE_CT_OPACITY) {
		type = JP2_CDEF_TYPE_OPACITY;

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(colorspace)) {
	case JAS_CLRSPC_FAM_RGB:
		switch (JAS_IMAGE_CT_COLOR(ctype)) {
		case JAS_IMAGE_CT_RGB_R:
			type = JP2_CDEF_TYPE_COLOR;
			asoc = JP2_CDEF_RGB_R;
			break;
		case JAS_IMAGE_CT_RGB_G:
			type = JP2_CDEF_TYPE_COLOR;
			asoc = JP2_CDEF_RGB_G;
			break;
		case JAS_IMAGE_CT_RGB_B:
			type = JP2_CDEF_TYPE_COLOR;
			asoc = JP2_CDEF_RGB_B;
			break;
		}
		break;
	case JAS_CLRSPC_FAM_YCBCR:
		switch (JAS_IMAGE_CT_COLOR(ctype)) {
		case JAS_IMAGE_CT_YCBCR_Y:
			type = JP2_CDEF_TYPE_COLOR;
			asoc = JP2_CDEF_YCBCR_Y;
			break;
		case JAS_IMAGE_CT_YCBCR_CB:
			type = JP2_CDEF_TYPE_COLOR;
			asoc = JP2_CDEF_YCBCR_CB;
			break;
		case JAS_IMAGE_CT_YCBCR_CR:
			type = JP2_CDEF_TYPE_COLOR;
			asoc = JP2_CDEF_YCBCR_CR;
			break;
		}
		break;
	case JAS_CLRSPC_FAM_GRAY:
		type = JP2_CDEF_TYPE_COLOR;
		asoc = JP2_CDEF_GRAY_Y;
		break;
	}

----------------------------------------------------------------------------------
	switch (clrspc) {
	case JAS_CLRSPC_SRGB:
		return JP2_COLR_SRGB;
	case JAS_CLRSPC_SYCBCR:
		return JP2_COLR_SYCC;
	case JAS_CLRSPC_SGRAY:
		return JP2_COLR_SGRAY;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (!(stream = jas_malloc(sizeof(jas_stream_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(stream = jas_stream_create())) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {
		jas_stream_destroy(stream);
		return 0;
	}

----------------------------------------------------------------------------------
	if (bufsize <= 0) {
		obj->bufsize_ = 1024;
		obj->growable_ = 1;
	} else {
		obj->bufsize_ = bufsize;
		obj->growable_ = 0;
	}

----------------------------------------------------------------------------------
	if (buf) {
		obj->buf_ = (unsigned char *) buf;
	} else {
		obj->buf_ = jas_malloc(obj->bufsize_);
		obj->myalloc_ = 1;
	}

----------------------------------------------------------------------------------
	if (!obj->buf_) {
		jas_stream_close(stream);
		return 0;
	}

----------------------------------------------------------------------------------
	if (bufsize > 0 && buf) {
		/* If a buffer was supplied by the caller and its length is positive,
		  make the associated buffer data appear in the stream initially. */
		obj->len_ = bufsize;
	} else {
		/* The stream is initially empty. */
		obj->len_ = 0;
	}

----------------------------------------------------------------------------------
	if (!(stream = jas_stream_create())) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {
		jas_stream_destroy(stream);
		return 0;
	}

----------------------------------------------------------------------------------
	if (!bufsize) {
		obj->bufsize_ = 1024;
		obj->growable_ = 1;
	} else {
		obj->bufsize_ = bufsize;
		obj->growable_ = 0;
	}

----------------------------------------------------------------------------------
	if (buf) {
		obj->buf_ = JAS_CAST(unsigned char *, buf);
	} else {
		obj->buf_ = jas_malloc(obj->bufsize_);
		obj->myalloc_ = 1;
	}

----------------------------------------------------------------------------------
	if (!obj->buf_) {
		jas_stream_close(stream);
		return 0;
	}

----------------------------------------------------------------------------------
	if (bufsize > 0 && buf) {
		/* If a buffer was supplied by the caller and its length is positive,
		  make the associated buffer data appear in the stream initially. */
		obj->len_ = bufsize;
	} else {
		/* The stream is initially empty. */
		obj->len_ = 0;
	}

----------------------------------------------------------------------------------
	if (bufsize < 0) {
		jas_deprecated("negative buffer size for jas_stream_memopen");
	}

----------------------------------------------------------------------------------
	if (buf && bufsize <= 0) {
		// This was never a valid thing to do with the old API.
		jas_eprintf("Invalid use of jas_stream_memopen detected.\n");
		jas_deprecated("A user-provided buffer for "
		  "jas_stream_memopen cannot be growable.\n");
	}

----------------------------------------------------------------------------------
	if (bufsize <= 0) {
		new_bufsize = 0;
		new_buf = 0;
	} else {
		new_bufsize = bufsize;
		new_buf = buf;
	}

----------------------------------------------------------------------------------
	if (!(stream = jas_stream_create())) {
		return 0;
	}

----------------------------------------------------------------------------------
	if ((stream->openmode_ & JAS_STREAM_READ) &&
	  (stream->openmode_ & JAS_STREAM_WRITE)) {
		openflags = O_RDWR;
	} else if (stream->openmode_ & JAS_STREAM_READ) {

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_APPEND) {
		openflags |= O_APPEND;
	}

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_BINARY) {
		openflags |= O_BINARY;

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_CREATE) {
		openflags |= O_CREAT | O_TRUNC;

----------------------------------------------------------------------------------
	if (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {
		jas_stream_destroy(stream);

----------------------------------------------------------------------------------
	if ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {
		// Free the underlying file object, since it will not otherwise

----------------------------------------------------------------------------------
	if (!(stream = jas_stream_create())) {
		return 0;

----------------------------------------------------------------------------------
	if ((stream->openmode_ & JAS_STREAM_READ) &&
	  (stream->openmode_ & JAS_STREAM_WRITE)) {

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_APPEND) {
		openflags |= O_APPEND;
	}

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_BINARY) {
		openflags |= O_BINARY;

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_CREATE) {
		openflags |= O_CREAT | O_TRUNC;

----------------------------------------------------------------------------------
	if (!(stream = jas_stream_create())) {
		return 0;

----------------------------------------------------------------------------------
	if (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {
		jas_stream_destroy(stream);

----------------------------------------------------------------------------------
	if ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,
	  JAS_STREAM_PERMS)) < 0) {

----------------------------------------------------------------------------------
	if (unlink(obj->pathname)) {
		/* We will try unlinking the file again after it is closed. */
		obj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;

----------------------------------------------------------------------------------
	if (!(stream = jas_stream_create())) {
		return 0;

----------------------------------------------------------------------------------
	if (stream->openmode_ & JAS_STREAM_BINARY) {
		setmode(fd, O_BINARY);

----------------------------------------------------------------------------------
	if (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {
		jas_stream_destroy(stream);

----------------------------------------------------------------------------------
	if ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {
		JAS_DBGLOG(100, ("jas_stream_destroy freeing buffer %p\n",

----------------------------------------------------------------------------------
	if (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (cnt < 0) {
		jas_deprecated("negative count for jas_stream_read");

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(stream)) == EOF) {
			return n;

----------------------------------------------------------------------------------
	if (cnt < 0) {
		jas_deprecated("negative count for jas_stream_write");

----------------------------------------------------------------------------------
		if (jas_stream_putc(stream, *bufptr) == EOF) {
			return n;

----------------------------------------------------------------------------------
		if (jas_stream_putc_macro(stream, *s) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(stream)) == EOF) {
			break;

----------------------------------------------------------------------------------
		if (c == '\n') {
			break;

----------------------------------------------------------------------------------
	if (n < 0) {
		jas_deprecated("negative count for jas_stream_gobble");

----------------------------------------------------------------------------------
		if (jas_stream_getc(stream) == EOF) {
			return n - m;

----------------------------------------------------------------------------------
	if (n < 0) {
		jas_deprecated("negative count for jas_stream_pad");

----------------------------------------------------------------------------------
		if (jas_stream_putc(stream, c) == EOF)
			return n - m;

----------------------------------------------------------------------------------
	if (stream->ops_ == &jas_stream_memops) {
		return 1;

----------------------------------------------------------------------------------
		if ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {
			return 0;

----------------------------------------------------------------------------------
	if (stream->bufmode_ & JAS_STREAM_RDBUF) {
		if (origin == SEEK_CUR) {

----------------------------------------------------------------------------------
		if (jas_stream_flush(stream)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))
	  < 0) {

----------------------------------------------------------------------------------
	if (stream->bufmode_ & JAS_STREAM_RDBUF) {
		adjust = -stream->cnt_;
	} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {

----------------------------------------------------------------------------------
	if ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (bufmode != JAS_STREAM_UNBUF) {
		/* The full- or line-buffered mode is being employed. */

----------------------------------------------------------------------------------
		if (!buf) {
			/* The caller has not specified a buffer to employ, so allocate

----------------------------------------------------------------------------------
			if ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +
			  JAS_STREAM_MAXPUTBACK))) {

----------------------------------------------------------------------------------
	if (stream->bufmode_ & JAS_STREAM_RDBUF) {
		return 0;
	}

----------------------------------------------------------------------------------
	if ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {
		return EOF;

----------------------------------------------------------------------------------
	if ((stream->openmode_ & JAS_STREAM_READ) == 0) {
		return EOF;

----------------------------------------------------------------------------------
	if ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,
	  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {

----------------------------------------------------------------------------------
		if (stream->cnt_ < 0) {
			stream->flags_ |= JAS_STREAM_ERR;
		} else {

----------------------------------------------------------------------------------
	if ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {
		return EOF;
	}

----------------------------------------------------------------------------------
	if ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {
		return EOF;

----------------------------------------------------------------------------------
	if (len > 0) {
		n = (*stream->ops_->write_)(stream->obj_, (char *)

----------------------------------------------------------------------------------
		if (n != len) {
			stream->flags_ |= JAS_STREAM_ERR;
			return EOF;

----------------------------------------------------------------------------------
	if (c != EOF) {
		assert(stream->cnt_ > 0);

----------------------------------------------------------------------------------
		switch (*s) {
		case 'r':
			openmode |= JAS_STREAM_READ;
			break;
		case 'w':
			openmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;
			break;
		case 'b':
			openmode |= JAS_STREAM_BINARY;
			break;
		case 'a':
			openmode |= JAS_STREAM_APPEND;
			break;
		case '+':
			openmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;
			break;
		default:
			break;
		}

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc_macro(in)) == EOF) {
			/* The next character of input could not be read. */

----------------------------------------------------------------------------------
		if (jas_stream_putc_macro(out, c) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if (n > 16 && i > 0) {
			display = (i >= cnt) ? 1 : 0;

----------------------------------------------------------------------------------
		if (display) {
			fprintf(fp, "%08x:", i);

----------------------------------------------------------------------------------
			if ((c = jas_stream_getc(stream)) == EOF) {
				abort();

----------------------------------------------------------------------------------
		if (display) {
			for (j = 0; j < m; ++j) {

----------------------------------------------------------------------------------
				if (isprint(buf[j])) {
					fputc(buf[j], fp);
				} else {

----------------------------------------------------------------------------------
	if ((oldpos = jas_stream_tell(stream)) < 0) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_stream_seek(stream, 0, SEEK_END) < 0) {
		return -1;

----------------------------------------------------------------------------------
	if ((pos = jas_stream_tell(stream)) < 0) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {
		return -1;

----------------------------------------------------------------------------------
	if (!bufsize) {
		jas_eprintf(

----------------------------------------------------------------------------------
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
	  bufsize) {
		JAS_DBGLOG(100, ("mem_resize realloc failed\n"));
		return -1;

----------------------------------------------------------------------------------
	if (newpos > m->bufsize_ && m->growable_) {
		newbufsize = m->bufsize_;

----------------------------------------------------------------------------------
			if (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {
				JAS_DBGLOG(100, ("new buffer size would cause overflow\n"));

----------------------------------------------------------------------------------
		if (mem_resize(m, newbufsize)) {
			return -1;

----------------------------------------------------------------------------------
	if (m->pos_ > m->len_) {
		/* The current position is beyond the end of the file, so

----------------------------------------------------------------------------------
		if (n > 0) {
			memset(&m->buf_[m->len_], 0, n);

----------------------------------------------------------------------------------
		if (m->pos_ != m->len_) {
			/* The buffer is not big enough. */

----------------------------------------------------------------------------------
	if (ret > 0) {
		memcpy(&m->buf_[m->pos_], buf, ret);

----------------------------------------------------------------------------------
	if (m->pos_ > m->len_) {
		m->len_ = m->pos_;

----------------------------------------------------------------------------------
	switch (origin) {
	case SEEK_SET:
		newpos = offset;
		break;
	case SEEK_END:
		newpos = m->len_ - offset;
		break;
	case SEEK_CUR:
		newpos = m->pos_ + offset;
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (newpos < 0) {
		return -1;

----------------------------------------------------------------------------------
	if (m->myalloc_ && m->buf_) {
		JAS_DBGLOG(100, ("mem_close freeing buffer %p\n", m->buf_));

----------------------------------------------------------------------------------
	if (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {
		unlink(fileobj->pathname);

----------------------------------------------------------------------------------
	if (n != cnt) {
		result = (!ferror(fp) && feof(fp)) ? 0 : -1;

----------------------------------------------------------------------------------
		if (!strcmp(opt->name, name)) {
			return opt;
		}

----------------------------------------------------------------------------------
	if (!jas_optind) {
		jas_optind = JAS_MIN(1, argc);
	}

----------------------------------------------------------------------------------
		if (*cp == '-') {
			/* We are processing an option. */
			++jas_optind;
			if (*++cp == '-') {
				/* We are processing a long option. */
				++cp;
				if (*cp == '\0') {
					/* This is the end of the options. */
					return JAS_GETOPT_EOF;
				}
				if (!(opt = jas_optlookup(opts, cp))) {
					if (jas_opterr) {
						jas_eprintf("unknown long option %s\n", s);
					}
					return JAS_GETOPT_ERR;
				}
				hasarg = (opt->flags & JAS_OPT_HASARG) != 0;
				id = opt->id;
			} else {
				/* We are processing a short option. */
				if (strlen(cp) != 1 ||
				  !(opt = jas_optlookup(opts, cp))) {
					if (jas_opterr) {
						jas_eprintf("unknown short option %s\n", s);
					}
					return JAS_GETOPT_ERR;
				}
				hasarg = (opt->flags & JAS_OPT_HASARG) != 0;
				id = opt->id;
			}
			if (hasarg) {
				/* The option has an argument. */
				if (jas_optind >= argc) {
					if (jas_opterr) {
						jas_eprintf("missing argument for option %s\n", s);
					}
					return JAS_GETOPT_ERR;
				}
				jas_optarg = argv[jas_optind];
				++jas_optind;
			} else {
				/* The option does not have an argument. */
				jas_optarg = 0;
			}
			return id;
		} else {
			/* We are not processing an option. */
			return JAS_GETOPT_EOF;
		}

----------------------------------------------------------------------------------
	if (!(tvp = jas_malloc(sizeof(jas_tvparser_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(tvp->buf = jas_strdup(s))) {
		jas_tvparser_destroy(tvp);
		return 0;
	}

----------------------------------------------------------------------------------
	if (tvp->buf) {
		jas_free(tvp->buf);
	}

----------------------------------------------------------------------------------
	if (*p == '\0') {
		/* No more tags are present. */
		tvp->pos = p;
		return 1;
	}

----------------------------------------------------------------------------------
	if (!JAS_TVP_ISTAG(*p)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (*p == '\0') {
		/* The value field is empty. */
		tvp->tag = tag;
		tvp->val = "";
		tvp->pos = p;
		return 0;
	}

----------------------------------------------------------------------------------
	if (*p != '=') {
		if (*p != '\0' && !isspace(*p)) {
			return -1;
		}
		*p++ = '\0';
		tvp->tag = tag;
		tvp->val = "";
		tvp->pos = p;
		return 0;
	}

----------------------------------------------------------------------------------
	if (*p != '\0') {
		*p++ = '\0';
	}

----------------------------------------------------------------------------------
		if (!strcmp(taginfo->name, name)) {
			return taginfo;
		}

----------------------------------------------------------------------------------
	if (!size) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {
		jas_eprintf("requested memory size is too large\n");
		result = 0;
		mb = 0;
	} else if (!jas_safe_size_add(jas_mem, size, &mem) || mem > jas_max_mem) {
		jas_eprintf("maximum memory limit would be exceeded\n");
		result = 0;
		mb = 0;
	} else {
		JAS_DBGLOG(100, ("jas_malloc: ext_size=%zu\n", ext_size));
		if ((mb = malloc(ext_size))) {
			result = jas_mb_get_data(mb);
			mb->size = size;
			jas_mem = mem;
		} else {
			result = 0;
		}
	}

----------------------------------------------------------------------------------
	if (!ptr) {
		return jas_malloc(size);
	}

----------------------------------------------------------------------------------
	if (ptr && !size) {
		jas_free(ptr);
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {
		jas_eprintf("requested memory size is too large\n");
		return 0;
	}

----------------------------------------------------------------------------------
	if (size > old_size) {
		if (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {
			jas_eprintf("maximum memory limit would be exceeded\n");
			return 0;
		}
	} else {
		if (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {
			jas_eprintf("heap corruption detected\n");
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (!(mb = realloc(old_mb, ext_size))) {
		result = 0;
	} else {
		result = jas_mb_get_data(mb);
		mb->size = size;
		jas_mem = mem;
	}

----------------------------------------------------------------------------------
	if (ptr) {
		mb = jas_get_mb(ptr);
		size = mb->size;
		JAS_DBGLOG(101, ("jas_free(%p) (mb=%p; size=%zu)\n", ptr, mb, size));
		if (!jas_safe_size_sub(jas_mem, size, &jas_mem)) {
			jas_eprintf("heap corruption detected\n");
			abort();
		}
		JAS_DBGLOG(100, ("jas_free: free(%p)\n", mb));
		free(mb);
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(num_elements, element_size, &size)) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(array_size, element_size, &size) ||
	  !jas_safe_size_mul(size, num_arrays, &size)) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(num_elements, element_size, &size)) {
		return 0;

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(num_elements, element_size, &size)) {
		return 0;

----------------------------------------------------------------------------------
	if (!(ptr = jas_malloc(size))) {
		return 0;

----------------------------------------------------------------------------------
			if (i + j < len) {
				fprintf(out, " %02x", dp[i + j]);
			}

----------------------------------------------------------------------------------
	if (gettimeofday(&tmr->start, 0)) {
		abort();
	}

----------------------------------------------------------------------------------
	if (gettimeofday(&tmr->stop, 0)) {
		abort();
	}

----------------------------------------------------------------------------------
	if (getrusage(RUSAGE_SELF, &tmr->start) < 0) {
		abort();
	}

----------------------------------------------------------------------------------
	if (getrusage(RUSAGE_SELF, &tmr->stop) < 0) {
		abort();
	}

----------------------------------------------------------------------------------
	if (!(p = jas_malloc(n))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(image = jas_image_create0())) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,
	  sizeof(jas_image_cmpt_t *)))) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (!jas_safe_size_mul3(cmptparm->width, cmptparm->height,
		  (cmptparm->prec + 7), &rawsize)) {

----------------------------------------------------------------------------------
		if (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,
		  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,
		  cmptparm->width, cmptparm->height, cmptparm->prec,
		  cmptparm->sgnd, inmem))) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);

----------------------------------------------------------------------------------
	if (!(image = jas_malloc(sizeof(jas_image_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (!(newimage = jas_image_create0())) {
		goto error;

----------------------------------------------------------------------------------
	if (jas_image_growcmpts(newimage, image->numcmpts_)) {
		goto error;

----------------------------------------------------------------------------------
		if (!(newimage->cmpts_[cmptno] = jas_image_cmpt_copy(image->cmpts_[cmptno]))) {
			goto error;

----------------------------------------------------------------------------------
	if (image->cmprof_) {
		if (!(newimage->cmprof_ = jas_cmprof_copy(image->cmprof_)))

----------------------------------------------------------------------------------
	if (newimage) {
		jas_image_destroy(newimage);

----------------------------------------------------------------------------------
	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (!(newcmpt = jas_image_cmpt_create0())) {
		return 0;

----------------------------------------------------------------------------------
	if (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {
		goto error;

----------------------------------------------------------------------------------
	if (newcmpt) {
		jas_image_cmpt_destroy(newcmpt);

----------------------------------------------------------------------------------
	if (image->cmpts_) {
		for (i = 0; i < image->numcmpts_; ++i) {

----------------------------------------------------------------------------------
	if (image->cmprof_)
		jas_cmprof_destroy(image->cmprof_);

----------------------------------------------------------------------------------
	if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {
		goto error;

----------------------------------------------------------------------------------
	if (!jas_safe_intfast32_add(tlx, width, 0) ||
	  !jas_safe_intfast32_add(tly, height, 0)) {

----------------------------------------------------------------------------------
	if (!jas_safe_intfast32_mul3(width, height, depth, 0)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
		goto error;

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {
		goto error;

----------------------------------------------------------------------------------
	if (!cmpt->stream_) {
		goto error;

----------------------------------------------------------------------------------
	if (size > 0) {
		if (size - 1 > LONG_MAX) {

----------------------------------------------------------------------------------
		if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||
		  jas_stream_putc(cmpt->stream_, 0) == EOF ||
		  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (cmpt) {
		jas_image_cmpt_destroy(cmpt);

----------------------------------------------------------------------------------
	if (cmpt->stream_) {
		jas_stream_close(cmpt->stream_);

----------------------------------------------------------------------------------
	if (fmt < 0) {
		if ((fmt = jas_image_getfmt(in)) < 0)

----------------------------------------------------------------------------------
	if (!(fmtinfo = jas_image_lookupfmtbyid(fmt)))
		goto error;

----------------------------------------------------------------------------------
	if (!fmtinfo->ops.decode)
		goto error;

----------------------------------------------------------------------------------
	if (!(image = (*fmtinfo->ops.decode)(in, optstr)))
		goto error;

----------------------------------------------------------------------------------
	if (!jas_clrspc_isunknown(image->clrspc_) &&
	  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {

----------------------------------------------------------------------------------
		if (!(image->cmprof_ =
		  jas_cmprof_createfromclrspc(jas_image_clrspc(image))))
			goto error;

----------------------------------------------------------------------------------
	if (image)
		jas_image_destroy(image);

----------------------------------------------------------------------------------
	if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {
		return -1;

----------------------------------------------------------------------------------
	if (cmptno < 0 || cmptno >= image->numcmpts_) {
		return -1;

----------------------------------------------------------------------------------
	if (x >= cmpt->width_ || y >= cmpt->height_ ||
	  x + width > cmpt->width_ ||

----------------------------------------------------------------------------------
	if (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
		if (jas_matrix_resize(data, height, width)) {

----------------------------------------------------------------------------------
		if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)
		  * cmpt->cps_, SEEK_SET) < 0) {
			return -1;
		}

----------------------------------------------------------------------------------
				if ((c = jas_stream_getc(cmpt->stream_)) == EOF) {
					return -1;

----------------------------------------------------------------------------------
	if (cmptno < 0 || cmptno >= image->numcmpts_) {
		return -1;

----------------------------------------------------------------------------------
	if (x >= cmpt->width_ || y >= cmpt->height_ ||
	  x + width > cmpt->width_ ||

----------------------------------------------------------------------------------
	if (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(data) != height ||
	  jas_matrix_numcols(data) != width) {

----------------------------------------------------------------------------------
		if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)
		  * cmpt->cps_, SEEK_SET) < 0) {
			return -1;
		}

----------------------------------------------------------------------------------
				if (jas_stream_putc(cmpt->stream_,
				  (unsigned char) c) == EOF) {

----------------------------------------------------------------------------------
		if (fmtinfo->name) {
			jas_free(fmtinfo->name);
			fmtinfo->name = 0;

----------------------------------------------------------------------------------
		if (fmtinfo->ext) {
			jas_free(fmtinfo->ext);

----------------------------------------------------------------------------------
		if (fmtinfo->desc) {
			jas_free(fmtinfo->desc);

----------------------------------------------------------------------------------
	if (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) {
		return -1;

----------------------------------------------------------------------------------
	if (!(fmtinfo->name = jas_strdup(name))) {
		return -1;

----------------------------------------------------------------------------------
	if (!(fmtinfo->ext = jas_strdup(ext))) {
		jas_free(fmtinfo->name);

----------------------------------------------------------------------------------
	if (!(fmtinfo->desc = jas_strdup(desc))) {
		jas_free(fmtinfo->name);

----------------------------------------------------------------------------------
	if (!(fmtinfo = jas_image_lookupfmtbyname(name))) {
		return -1;

----------------------------------------------------------------------------------
	if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {
		return 0;

----------------------------------------------------------------------------------
		if (fmtinfo->ops.validate) {
			/* Is the input data valid for this format? */

----------------------------------------------------------------------------------
			if (!(*fmtinfo->ops.validate)(in)) {
				JAS_DBGLOG(20, ("test succeeded\n"));

----------------------------------------------------------------------------------
	if (!(ext = strrchr(name, '.'))) {
		return -1;

----------------------------------------------------------------------------------
		if (!strcmp(ext, fmtinfo->ext)) {
			return fmtinfo->id;

----------------------------------------------------------------------------------
		if (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||
		  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||

----------------------------------------------------------------------------------
	if (cmptno >= image->numcmpts_) {
		return;
	}

----------------------------------------------------------------------------------
	if (cmptno < image->numcmpts_) {
		memmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],

----------------------------------------------------------------------------------
	if (cmptno < 0) {
		cmptno = image->numcmpts_;
	}

----------------------------------------------------------------------------------
	if (image->numcmpts_ >= image->maxcmpts_) {
		if (jas_image_growcmpts(image, image->maxcmpts_ + 128)) {

----------------------------------------------------------------------------------
	if (!(newcmpt = jas_image_cmpt_create(cmptparm->tlx,
	  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,
	  cmptparm->width, cmptparm->height, cmptparm->prec,
	  cmptparm->sgnd, 1))) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (cmptno < image->numcmpts_) {
		memmove(&image->cmpts_[cmptno + 1], &image->cmpts_[cmptno],

----------------------------------------------------------------------------------
		if (fmtinfo->id == id) {
			return fmtinfo;
		}

----------------------------------------------------------------------------------
		if (!strcmp(fmtinfo->name, name)) {
			return fmtinfo;

----------------------------------------------------------------------------------
	if (image->numcmpts_ > 0) {
		/* Determine the bounding box for all of the components on the

----------------------------------------------------------------------------------
			if (image->tlx_ > cmpt->tlx_) {
				image->tlx_ = cmpt->tlx_;

----------------------------------------------------------------------------------
			if (image->tly_ > cmpt->tly_) {
				image->tly_ = cmpt->tly_;

----------------------------------------------------------------------------------
			if (image->brx_ < x) {
				image->brx_ = x;

----------------------------------------------------------------------------------
			if (image->bry_ < y) {
				image->bry_ = y;

----------------------------------------------------------------------------------
	if (!newcmpts) {
		return -1;

----------------------------------------------------------------------------------
	if (dstimage->numcmpts_ >= dstimage->maxcmpts_) {
		if (jas_image_growcmpts(dstimage, dstimage->maxcmpts_ + 128)) {

----------------------------------------------------------------------------------
	if (!(newcmpt = jas_image_cmpt_copy(srcimage->cmpts_[srccmptno]))) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (dstcmptno < dstimage->numcmpts_) {
		memmove(&dstimage->cmpts_[dstcmptno + 1], &dstimage->cmpts_[dstcmptno],

----------------------------------------------------------------------------------
		if (jas_image_readcmpt2(image, cmptno, 0, 0, n, 1, buf)) {
			abort();
		}

----------------------------------------------------------------------------------
		if (jas_image_readcmpt2(image, cmptno, width - n, height - 1, n, 1, buf)) {
			abort();

----------------------------------------------------------------------------------
	if (jas_image_addcmpt(image, newcmptno, &cmptparms)) {
		return -1;

----------------------------------------------------------------------------------
	if (newcmptno <= cmptno) {
		++cmptno;

----------------------------------------------------------------------------------
			if (v < 0) {
				v = 0;

----------------------------------------------------------------------------------
	if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,
	  SEEK_SET) < 0) {

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(cmpt->stream_)) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,
	  SEEK_SET) < 0) {

----------------------------------------------------------------------------------
		if (jas_stream_putc(cmpt->stream_, (unsigned char) c) == EOF) {
			return;
		}

----------------------------------------------------------------------------------
		if (image->cmpts_[cmptno]->type_ == ctype) {
			return cmptno;

----------------------------------------------------------------------------------
	if (cmptno < 0 || cmptno >= image->numcmpts_)
		goto error;

----------------------------------------------------------------------------------
	if (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||
	  width < 0 || height < 0 || x + width > cmpt->width_ ||

----------------------------------------------------------------------------------
		if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)
		  * cmpt->cps_, SEEK_SET) < 0)
			goto error;

----------------------------------------------------------------------------------
			if (getint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, &v))
				goto error;

----------------------------------------------------------------------------------
	if (cmptno < 0 || cmptno >= image->numcmpts_)
		goto error;

----------------------------------------------------------------------------------
	if (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||
	  width < 0 || height < 0 || x + width > cmpt->width_ ||

----------------------------------------------------------------------------------
		if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)
		  * cmpt->cps_, SEEK_SET) < 0)
			goto error;

----------------------------------------------------------------------------------
			if (putint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, v))
				goto error;

----------------------------------------------------------------------------------
	if (jas_image_addcmpt(image, newcmptno, &cmptparm))
		goto error;

----------------------------------------------------------------------------------
			if (bx > cmptbrx)
				bx = cmptbrx;

----------------------------------------------------------------------------------
			if (by > cmptbry)
				by = cmptbry;

----------------------------------------------------------------------------------
			if (d0 <= d1 && d0 <= d2 && d0 <= d3) {
				oldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;

----------------------------------------------------------------------------------
			if (jas_stream_seek(oldcmpt->stream_, oldcmpt->cps_ *
			  (oldy * oldcmpt->width_ + oldx), SEEK_SET) < 0)

----------------------------------------------------------------------------------
			if (getint(oldcmpt->stream_, oldcmpt->sgnd_,
			  oldcmpt->prec_, &v))

----------------------------------------------------------------------------------
			if (newcmpt->prec_ != oldcmpt->prec_ ||
			  newcmpt->sgnd_ != oldcmpt->sgnd_) {

----------------------------------------------------------------------------------
			if (putint(newcmpt->stream_, newcmpt->sgnd_,
			  newcmpt->prec_, v))
				goto error;

----------------------------------------------------------------------------------
		if (jas_image_cmpthstep(image, i) != hstep ||
		  jas_image_cmptvstep(image, i) != vstep) {

----------------------------------------------------------------------------------
	if (image->numcmpts_ > 0) {
		cmpt = image->cmpts_[0];
		tmptlx = cmpt->tlx_;

----------------------------------------------------------------------------------
			if (cmpt->tlx_ < tmptlx)
				tmptlx = cmpt->tlx_;

----------------------------------------------------------------------------------
			if (cmpt->tly_ < tmptly)
				tmptly = cmpt->tly_;

----------------------------------------------------------------------------------
			if (t > tmpbrx)
				tmpbrx = t;

----------------------------------------------------------------------------------
			if (t > tmpbry)
				tmpbry = t;

----------------------------------------------------------------------------------
	if (n < 0) {
		result = -n;

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF)
			return -1;

----------------------------------------------------------------------------------
	if (sgnd) {
		*val = decode_twos_comp(v, prec);

----------------------------------------------------------------------------------
	if (sgnd) {
		val = encode_twos_comp(val, prec);

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, c) != c)
			return -1;

----------------------------------------------------------------------------------
	if (newsgnd != oldsgnd) {
	}

----------------------------------------------------------------------------------
	if (newprec != oldprec) {
		if (newprec > oldprec) {

----------------------------------------------------------------------------------
	if (!(inimage = jas_image_copy(image)))
		goto error;

----------------------------------------------------------------------------------
	if (!jas_image_ishomosamp(inimage)) {
		minhstep = jas_image_cmpthstep(inimage, 0);

----------------------------------------------------------------------------------
			if (hstep < minhstep) {
				minhstep = hstep;

----------------------------------------------------------------------------------
			if (vstep < minvstep) {
				minvstep = vstep;

----------------------------------------------------------------------------------
			if (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep,
			  jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {

----------------------------------------------------------------------------------
	if (!(inprof = jas_image_cmprof(inimage))) {
		abort();
	}

----------------------------------------------------------------------------------
	if (!(outimage = jas_image_create0())) {
		goto error;

----------------------------------------------------------------------------------
		if (jas_image_addcmpt(outimage, -1, &cmptparm))
			goto error;

----------------------------------------------------------------------------------
		if (!ISCOLOR(jas_image_cmpttype(inimage, i))) {
			jas_image_copycmpt(outimage, -1, inimage, i);

----------------------------------------------------------------------------------
	if (!(tmpprof = jas_cmprof_copy(outprof)))
		goto error;

----------------------------------------------------------------------------------
	if (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD,
	  intent, 0))) {

----------------------------------------------------------------------------------
	if (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {
		abort();
	}

----------------------------------------------------------------------------------
		if (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {
			goto error;

----------------------------------------------------------------------------------
	if (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {
		abort();

----------------------------------------------------------------------------------
		if (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long))))
			goto error;

----------------------------------------------------------------------------------
			if (jas_image_readcmpt2(inimage, k, 0, i, width, 1,
			  incmptfmts[j].buf))

----------------------------------------------------------------------------------
			if (jas_image_writecmpt2(outimage, k, 0, i, width, 1,
			  outcmptfmts[j].buf))

----------------------------------------------------------------------------------
	if (xform)
		jas_cmxform_destroy(xform);

----------------------------------------------------------------------------------
	if (inimage)
		jas_image_destroy(inimage);

----------------------------------------------------------------------------------
	if (outimage)
		jas_image_destroy(outimage);

----------------------------------------------------------------------------------
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (numrows < 0 || numcols < 0) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(numrows, numcols, &size)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (matrix->maxrows_ > 0) {
		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
		  sizeof(jas_seqent_t *)))) {
			goto error;
		}
	}

----------------------------------------------------------------------------------
	if (matrix->datasize_ > 0) {
		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
		  sizeof(jas_seqent_t)))) {
			goto error;
		}
	}

----------------------------------------------------------------------------------
	if (matrix) {
		jas_matrix_destroy(matrix);
	}

----------------------------------------------------------------------------------
	if (matrix->data_) {
		assert(!(matrix->flags_ & JAS_MATRIX_REF));
		jas_free(matrix->data_);
		matrix->data_ = 0;
	}

----------------------------------------------------------------------------------
	if (matrix->rows_) {
		jas_free(matrix->rows_);
		matrix->rows_ = 0;
	}

----------------------------------------------------------------------------------
	if (mat0->data_) {
		if (!(mat0->flags_ & JAS_MATRIX_REF)) {
			jas_free(mat0->data_);
		}
		mat0->data_ = 0;
		mat0->datasize_ = 0;
	}

----------------------------------------------------------------------------------
	if (mat0->rows_) {
		jas_free(mat0->rows_);
		mat0->rows_ = 0;
	}

----------------------------------------------------------------------------------
	if (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {
		/*
			There is no way to indicate failure to the caller.
			So, we have no choice but to abort.
			Ideally, this function should have a non-void return type.
			In practice, a non-void return type probably would not help
			much anyways as the caller would just have to terminate anyways.
		*/
		abort();
	}

----------------------------------------------------------------------------------
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}

----------------------------------------------------------------------------------
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);

----------------------------------------------------------------------------------
				if (v < minval) {
					*data = minval;

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);

----------------------------------------------------------------------------------
	if (size > matrix->datasize_ || numrows > matrix->maxrows_) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);

----------------------------------------------------------------------------------
	if (fscanf(in, "%ld %ld", &tmp_xoff, &tmp_yoff) != 2) {
		return 0;

----------------------------------------------------------------------------------
	if (fscanf(in, "%ld %ld", &tmp_numcols, &tmp_numrows) != 2) {
		return 0;

----------------------------------------------------------------------------------
	if (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols,
	  yoff + numrows))) {

----------------------------------------------------------------------------------
	if (jas_matrix_numrows(matrix) != numrows ||
	  jas_matrix_numcols(matrix) != numcols) {
		abort();
	}

----------------------------------------------------------------------------------
			if (fscanf(in, "%ld", &x) != 1) {
				jas_matrix_destroy(matrix);

----------------------------------------------------------------------------------
			if (n + JAS_CAST(int, strlen(sbuf)) > MAXLINELEN) {
				fputs(buf, out);

----------------------------------------------------------------------------------
			if (j == jas_matrix_numcols(matrix) - 1) {
				fputs(buf, out);

----------------------------------------------------------------------------------
	if (!(prof = jas_malloc(sizeof(jas_iccprof_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(prof->attrtab = jas_iccattrtab_create()))
		goto error;

----------------------------------------------------------------------------------
	if (prof)
		jas_iccprof_destroy(prof);

----------------------------------------------------------------------------------
	if (!(newprof = jas_iccprof_create()))
		goto error;

----------------------------------------------------------------------------------
	if (!(newprof->attrtab = jas_iccattrtab_copy(prof->attrtab)))
		goto error;

----------------------------------------------------------------------------------
	if (newprof)
		jas_iccprof_destroy(newprof);

----------------------------------------------------------------------------------
	if (prof->attrtab)
		jas_iccattrtab_destroy(prof->attrtab);

----------------------------------------------------------------------------------
	if (prof->tagtab.ents)
		jas_free(prof->tagtab.ents);

----------------------------------------------------------------------------------
	if (!(prof = jas_iccprof_create())) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jas_iccprof_readhdr(in, &prof->hdr)) {
		jas_eprintf("cannot get header\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (jas_iccprof_gettagtab(in, &prof->tagtab)) {
		jas_eprintf("cannot get tab table\n");
		goto error;
	}

----------------------------------------------------------------------------------
		if (tagtabent->off == JAS_CAST(jas_iccuint32_t, prevoff)) {
			if (prevattrval) {
				if (!(attrval = jas_iccattrval_clone(prevattrval)))
					goto error;
				if (jas_iccprof_setattr(prof, tagtabent->tag, attrval))
					goto error;
				jas_iccattrval_destroy(attrval);
				attrval = 0;
			} else {
#if 0
				jas_eprintf("warning: skipping unknown tag type\n");
#endif
			}
			continue;
		}

----------------------------------------------------------------------------------
		if (reloff > 0) {
			if (jas_stream_gobble(in, reloff) != reloff)
				goto error;
			curoff += reloff;
		} else if (reloff < 0) {
			/* This should never happen since we read the tagged
			element data in a single pass. */
			abort();
		}

----------------------------------------------------------------------------------
		if (jas_iccgetuint32(in, &type)) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (jas_stream_gobble(in, 4) != 4) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (!jas_iccattrvalinfo_lookup(type)) {
#if 0
			jas_eprintf("warning: skipping unknown tag type\n");
#endif
			prevattrval = 0;
			continue;
		}

----------------------------------------------------------------------------------
		if (!(attrval = jas_iccattrval_create(type))) {
			goto error;
		}

----------------------------------------------------------------------------------
		if ((*attrval->ops->input)(attrval, in, len)) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (jas_iccprof_setattr(prof, tagtabent->tag, attrval)) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (prof)
		jas_iccprof_destroy(prof);

----------------------------------------------------------------------------------
	if (attrval)
		jas_iccattrval_destroy(attrval);

----------------------------------------------------------------------------------
	if (!(tagtab->ents = jas_alloc2(prof->attrtab->numattrs,
	  sizeof(jas_icctagtabent_t))))
		goto error;

----------------------------------------------------------------------------------
		if (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))
			goto error;

----------------------------------------------------------------------------------
			if (tagtabent->data == tmptagtabent->data) {
				sharedtagtabent = tmptagtabent;

----------------------------------------------------------------------------------
		if (sharedtagtabent) {
			tagtabent->off = sharedtagtabent->off;

----------------------------------------------------------------------------------
			if (i < JAS_CAST(int, tagtab->numents - 1)) {
				curoff = jas_iccpadtomult(curoff + tagtabent->len, 4);

----------------------------------------------------------------------------------
	if (jas_iccprof_writehdr(out, &prof->hdr))
		goto error;

----------------------------------------------------------------------------------
	if (jas_iccprof_puttagtab(out, &prof->tagtab))
		goto error;

----------------------------------------------------------------------------------
		if (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))
			goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint32(out, attrval->type) || jas_stream_pad(out,
		  4, 0) != 4)

----------------------------------------------------------------------------------
		if ((*attrval->ops->output)(attrval, out))
			goto error;

----------------------------------------------------------------------------------
		if (reloff > 0) {
			if (jas_stream_pad(out, reloff, 0) != reloff)

----------------------------------------------------------------------------------
	if (jas_iccputuint32(out, hdr->size) ||
	  jas_iccputuint32(out, hdr->cmmtype) ||

----------------------------------------------------------------------------------
	if (jas_iccputuint32(out, tagtab->numents))
		goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint32(out, tagtabent->tag) ||
		  jas_iccputuint32(out, tagtabent->off) ||

----------------------------------------------------------------------------------
	if (jas_iccgetuint32(in, &hdr->size) ||
	  jas_iccgetuint32(in, &hdr->cmmtype) ||
	  jas_iccgetuint32(in, &hdr->version) ||
	  jas_iccgetuint32(in, &hdr->clas) ||
	  jas_iccgetuint32(in, &hdr->colorspc) ||
	  jas_iccgetuint32(in, &hdr->refcolorspc) ||
	  jas_iccgettime(in, &hdr->ctime) ||
	  jas_iccgetuint32(in, &hdr->magic) ||
	  jas_iccgetuint32(in, &hdr->platform) ||
	  jas_iccgetuint32(in, &hdr->flags) ||
	  jas_iccgetuint32(in, &hdr->maker) ||
	  jas_iccgetuint32(in, &hdr->model) ||
	  jas_iccgetuint64(in, &hdr->attr) ||
	  jas_iccgetuint32(in, &hdr->intent) ||
	  jas_iccgetxyz(in, &hdr->illum) ||
	  jas_iccgetuint32(in, &hdr->creator) ||
	  jas_stream_gobble(in, 44) != 44)
		return -1;

----------------------------------------------------------------------------------
	if (tagtab->ents) {
		jas_free(tagtab->ents);

----------------------------------------------------------------------------------
	if (jas_iccgetuint32(in, &tagtab->numents))
		goto error;

----------------------------------------------------------------------------------
	if (!(tagtab->ents = jas_alloc2(tagtab->numents,
	  sizeof(jas_icctagtabent_t))))

----------------------------------------------------------------------------------
		if (jas_iccgetuint32(in, &tagtabent->tag) ||
		jas_iccgetuint32(in, &tagtabent->off) ||

----------------------------------------------------------------------------------
	if (tagtab->ents) {
		jas_free(tagtab->ents);
		tagtab->ents = 0;

----------------------------------------------------------------------------------
	if ((i = jas_iccattrtab_lookup(prof->attrtab, name)) < 0)
		goto error;

----------------------------------------------------------------------------------
	if (!(attrval = jas_iccattrval_clone(prof->attrtab->attrs[i].val)))
		goto error;

----------------------------------------------------------------------------------
	if ((i = jas_iccattrtab_lookup(prof->attrtab, name)) >= 0) {
		if (val) {

----------------------------------------------------------------------------------
			if (jas_iccattrtab_replace(prof->attrtab, i, name, val))
				goto error;

----------------------------------------------------------------------------------
		if (val) {
			if (jas_iccattrtab_add(prof->attrtab, -1, name, val))

----------------------------------------------------------------------------------
	if (srctagtabent->off > dsttagtabent->off) {
		return 1;

----------------------------------------------------------------------------------
		if (info->type == type) {
			return info;

----------------------------------------------------------------------------------
	if (jas_iccgetuint16(in, &time->year) ||
	  jas_iccgetuint16(in, &time->month) ||

----------------------------------------------------------------------------------
	if (jas_iccgetsint32(in, &xyz->x) ||
	  jas_iccgetsint32(in, &xyz->y) ||
	  jas_iccgetsint32(in, &xyz->z)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(tab = jas_malloc(sizeof(jas_iccattrtab_t))))
		goto error;

----------------------------------------------------------------------------------
	if (jas_iccattrtab_resize(tab, 32))
		goto error;

----------------------------------------------------------------------------------
	if (tab)
		jas_iccattrtab_destroy(tab);

----------------------------------------------------------------------------------
	if (!(newattrtab = jas_iccattrtab_create()))
		goto error;

----------------------------------------------------------------------------------
		if (jas_iccattrtab_add(newattrtab, i, attrtab->attrs[i].name,
		  attrtab->attrs[i].val))

----------------------------------------------------------------------------------
	if (tab->attrs) {
		while (tab->numattrs > 0) {

----------------------------------------------------------------------------------
		if (!info) abort();

----------------------------------------------------------------------------------
	if (!newattrs) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (i < 0) {
		i = attrtab->numattrs;

----------------------------------------------------------------------------------
	if (attrtab->numattrs >= attrtab->maxattrs) {
		if (jas_iccattrtab_resize(attrtab, attrtab->numattrs + 32)) {

----------------------------------------------------------------------------------
	if (!(tmpattrval = jas_iccattrval_clone(val)))
		goto error;

----------------------------------------------------------------------------------
	if (n > 0)
		memmove(&attrtab->attrs[i + 1], &attrtab->attrs[i],

----------------------------------------------------------------------------------
	if (tmpattrval)
		jas_iccattrval_destroy(tmpattrval);

----------------------------------------------------------------------------------
	if (!(newval = jas_iccattrval_clone(val)))
		goto error;

----------------------------------------------------------------------------------
	if ((n = attrtab->numattrs - i - 1) > 0)
		memmove(&attrtab->attrs[i], &attrtab->attrs[i + 1],

----------------------------------------------------------------------------------
	if (i < 0 || i >= attrtab->numattrs)
		goto error;

----------------------------------------------------------------------------------
	if (!(*val = jas_iccattrval_clone(attr->val)))
		goto error;

----------------------------------------------------------------------------------
		if (attr->name == name)
			return i;

----------------------------------------------------------------------------------
	if (!(info = jas_iccattrvalinfo_lookup(type)))
		goto error;

----------------------------------------------------------------------------------
	if (!(attrval = jas_iccattrval_create0()))
		goto error;

----------------------------------------------------------------------------------
	if (--attrval->refcnt <= 0) {
		if (attrval->ops->destroy)

----------------------------------------------------------------------------------
	if (attrval->ops->dump) {
		(*attrval->ops->dump)(attrval, out);

----------------------------------------------------------------------------------
	if (attrval->refcnt > 1) {
		if (!(newattrval = jas_iccattrval_create0()))

----------------------------------------------------------------------------------
		if (newattrval->ops->copy) {
			if ((*newattrval->ops->copy)(newattrval, attrval))

----------------------------------------------------------------------------------
	if (newattrval) {
		jas_free(newattrval);

----------------------------------------------------------------------------------
	if (!(attrval = jas_malloc(sizeof(jas_iccattrval_t))))
		return 0;

----------------------------------------------------------------------------------
	if (len != 4 * 3) abort();

----------------------------------------------------------------------------------
	if (jas_iccputuint32(out, xyz->x) ||
	  jas_iccputuint32(out, xyz->y) ||

----------------------------------------------------------------------------------
	if (curv->ents) {
		jas_free(curv->ents);
		curv->ents = 0;

----------------------------------------------------------------------------------
	if (jas_iccgetuint32(in, &curv->numents))
		goto error;

----------------------------------------------------------------------------------
	if (!(curv->ents = jas_alloc2(curv->numents, sizeof(jas_iccuint16_t))))
		goto error;

----------------------------------------------------------------------------------
		if (jas_iccgetuint16(in, &curv->ents[i]))
			goto error;

----------------------------------------------------------------------------------
	if (JAS_CAST(int, 4 + 2 * curv->numents) != cnt)
		goto error;

----------------------------------------------------------------------------------
	if (jas_iccputuint32(out, curv->numents))
		goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint16(out, curv->ents[i]))
			goto error;

----------------------------------------------------------------------------------
	if (curv->numents == 1) {
		fprintf(out, "gamma = %f\n", curv->ents[0] / 256.0);

----------------------------------------------------------------------------------
			if (i < 3 || i >= JAS_CAST(int, curv->numents) - 3) {
				fprintf(out, "entry[%d] = %f\n", i, curv->ents[i] / 65535.0);

----------------------------------------------------------------------------------
	if (txtdesc->ascdata) {
		jas_free(txtdesc->ascdata);

----------------------------------------------------------------------------------
	if (txtdesc->ucdata) {
		jas_free(txtdesc->ucdata);

----------------------------------------------------------------------------------
	if (jas_iccgetuint32(in, &txtdesc->asclen))
		goto error;

----------------------------------------------------------------------------------
	if (!(txtdesc->ascdata = jas_malloc(txtdesc->asclen)))
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_read(in, txtdesc->ascdata, txtdesc->asclen) !=
	  JAS_CAST(int, txtdesc->asclen))

----------------------------------------------------------------------------------
	if (jas_iccgetuint32(in, &txtdesc->uclangcode) ||
	  jas_iccgetuint32(in, &txtdesc->uclen))

----------------------------------------------------------------------------------
	if (!(txtdesc->ucdata = jas_alloc2(txtdesc->uclen, 2)))
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_read(in, txtdesc->ucdata, txtdesc->uclen * 2) !=
	  JAS_CAST(int, txtdesc->uclen * 2))

----------------------------------------------------------------------------------
	if (jas_iccgetuint16(in, &txtdesc->sccode))
		goto error;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF)
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_read(in, txtdesc->macdata, 67) != 67)
		goto error;

----------------------------------------------------------------------------------
	if (n > cnt) {
		return -1;

----------------------------------------------------------------------------------
	if (n < cnt) {
		if (jas_stream_gobble(in, cnt - n) != cnt - n)

----------------------------------------------------------------------------------
	if (txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67 != cnt)
		return -1;

----------------------------------------------------------------------------------
	if (jas_iccputuint32(out, txtdesc->asclen) ||
	  jas_stream_puts(out, txtdesc->ascdata) ||

----------------------------------------------------------------------------------
	if (txtdesc->maclen > 0) {
		if (jas_stream_write(out, txtdesc->macdata, 67) != 67)
			goto error;

----------------------------------------------------------------------------------
		if (jas_stream_pad(out, 67, 0) != 67)
			goto error;

----------------------------------------------------------------------------------
	if (txt->string) {
		jas_free(txt->string);

----------------------------------------------------------------------------------
	if (!(txt->string = jas_strdup(othtxt->string)))
		return -1;

----------------------------------------------------------------------------------
	if (!(txt->string = jas_malloc(cnt)))
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_read(in, txt->string, cnt) != cnt)
		goto error;

----------------------------------------------------------------------------------
	if (JAS_CAST(int, strlen(txt->string)) + 1 != cnt)
		goto error;

----------------------------------------------------------------------------------
	if (jas_stream_puts(out, txt->string) ||
	  jas_stream_putc(out, 0) == EOF)

----------------------------------------------------------------------------------
	if (lut8->clut) {
		jas_free(lut8->clut);

----------------------------------------------------------------------------------
	if (lut8->intabs) {
		jas_free(lut8->intabs);

----------------------------------------------------------------------------------
	if (lut8->intabsbuf) {
		jas_free(lut8->intabsbuf);

----------------------------------------------------------------------------------
	if (lut8->outtabs) {
		jas_free(lut8->outtabs);

----------------------------------------------------------------------------------
	if (lut8->outtabsbuf) {
		jas_free(lut8->outtabsbuf);

----------------------------------------------------------------------------------
	if (jas_iccgetuint8(in, &lut8->numinchans) ||
	  jas_iccgetuint8(in, &lut8->numoutchans) ||

----------------------------------------------------------------------------------
			if (jas_iccgetsint32(in, &lut8->e[i][j]))
				goto error;

----------------------------------------------------------------------------------
	if (jas_iccgetuint16(in, &lut8->numintabents) ||
	  jas_iccgetuint16(in, &lut8->numouttabents))

----------------------------------------------------------------------------------
	if (!(lut8->clut = jas_alloc2(clutsize, sizeof(jas_iccuint8_t))) ||
	  !(lut8->intabsbuf = jas_alloc3(lut8->numinchans,

----------------------------------------------------------------------------------
	if (!(lut8->outtabsbuf = jas_alloc3(lut8->numoutchans,
	  lut8->numouttabents, sizeof(jas_iccuint8_t))) ||
	  !(lut8->outtabs = jas_alloc2(lut8->numoutchans,
	  sizeof(jas_iccuint8_t *))))
		goto error;

----------------------------------------------------------------------------------
			if (jas_iccgetuint8(in, &lut8->intabs[i][j]))
				goto error;

----------------------------------------------------------------------------------
			if (jas_iccgetuint8(in, &lut8->outtabs[i][j]))
				goto error;

----------------------------------------------------------------------------------
		if (jas_iccgetuint8(in, &lut8->clut[i]))
			goto error;

----------------------------------------------------------------------------------
	if (JAS_CAST(int, 44 + lut8->numinchans * lut8->numintabents +
	  lut8->numoutchans * lut8->numouttabents +

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, lut8->numinchans) == EOF ||
	  jas_stream_putc(out, lut8->numoutchans) == EOF ||
	  jas_stream_putc(out, lut8->clutlen) == EOF ||
	  jas_stream_putc(out, 0) == EOF)
		goto error;

----------------------------------------------------------------------------------
			if (jas_iccputsint32(out, lut8->e[i][j]))
				goto error;

----------------------------------------------------------------------------------
	if (jas_iccputuint16(out, lut8->numintabents) ||
	  jas_iccputuint16(out, lut8->numouttabents))

----------------------------------------------------------------------------------
		if (jas_iccputuint8(out, lut8->intabsbuf[i]))
			goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint8(out, lut8->outtabsbuf[i]))
			goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint8(out, lut8->clut[i]))
			goto error;

----------------------------------------------------------------------------------
	if (lut16->clut) {
		jas_free(lut16->clut);

----------------------------------------------------------------------------------
	if (lut16->intabs) {
		jas_free(lut16->intabs);

----------------------------------------------------------------------------------
	if (lut16->intabsbuf) {
		jas_free(lut16->intabsbuf);

----------------------------------------------------------------------------------
	if (lut16->outtabs) {
		jas_free(lut16->outtabs);

----------------------------------------------------------------------------------
	if (lut16->outtabsbuf) {
		jas_free(lut16->outtabsbuf);

----------------------------------------------------------------------------------
	if (jas_iccgetuint8(in, &lut16->numinchans) ||
	  jas_iccgetuint8(in, &lut16->numoutchans) ||

----------------------------------------------------------------------------------
			if (jas_iccgetsint32(in, &lut16->e[i][j]))
				goto error;

----------------------------------------------------------------------------------
	if (jas_iccgetuint16(in, &lut16->numintabents) ||
	  jas_iccgetuint16(in, &lut16->numouttabents))

----------------------------------------------------------------------------------
	if (!(lut16->clut = jas_alloc2(clutsize, sizeof(jas_iccuint16_t))) ||
	  !(lut16->intabsbuf = jas_alloc3(lut16->numinchans,

----------------------------------------------------------------------------------
	if (!(lut16->outtabsbuf = jas_alloc3(lut16->numoutchans,
	  lut16->numouttabents, sizeof(jas_iccuint16_t))) ||
	  !(lut16->outtabs = jas_alloc2(lut16->numoutchans,
	  sizeof(jas_iccuint16_t *))))
		goto error;

----------------------------------------------------------------------------------
			if (jas_iccgetuint16(in, &lut16->intabs[i][j]))
				goto error;

----------------------------------------------------------------------------------
			if (jas_iccgetuint16(in, &lut16->outtabs[i][j]))
				goto error;

----------------------------------------------------------------------------------
		if (jas_iccgetuint16(in, &lut16->clut[i]))
			goto error;

----------------------------------------------------------------------------------
	if (JAS_CAST(int, 44 + 2 * (lut16->numinchans * lut16->numintabents +
          lut16->numoutchans * lut16->numouttabents +

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, lut16->numinchans) == EOF ||
	  jas_stream_putc(out, lut16->numoutchans) == EOF ||
	  jas_stream_putc(out, lut16->clutlen) == EOF ||
	  jas_stream_putc(out, 0) == EOF)
		goto error;

----------------------------------------------------------------------------------
			if (jas_iccputsint32(out, lut16->e[i][j]))
				goto error;

----------------------------------------------------------------------------------
	if (jas_iccputuint16(out, lut16->numintabents) ||
	  jas_iccputuint16(out, lut16->numouttabents))

----------------------------------------------------------------------------------
		if (jas_iccputuint16(out, lut16->intabsbuf[i]))
			goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint16(out, lut16->outtabsbuf[i]))
			goto error;

----------------------------------------------------------------------------------
		if (jas_iccputuint16(out, lut16->clut[i]))
			goto error;

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF)
			return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF)
		return -1;

----------------------------------------------------------------------------------
	if (jas_iccgetuint(in, 2, &tmp))
		return -1;

----------------------------------------------------------------------------------
	if (jas_iccgetuint(in, 4, &tmp))
		return -1;

----------------------------------------------------------------------------------
	if (jas_iccgetuint(in, 4, &tmp))
		return -1;

----------------------------------------------------------------------------------
	if (jas_iccgetuint(in, 8, &tmp))
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, c) == EOF)
			return -1;

----------------------------------------------------------------------------------
		if (isalpha(c) || isdigit(c)) {
			*bufptr++ = c;

----------------------------------------------------------------------------------
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
		goto error;

----------------------------------------------------------------------------------
	if (!(prof = jas_iccprof_load(in)))
		goto error;

----------------------------------------------------------------------------------
	if (in)
		jas_stream_close(in);

----------------------------------------------------------------------------------
	switch (clrspc) {
	case JAS_CLRSPC_SRGB:
		prof = jas_iccprof_createfrombuf(jas_iccprofdata_srgb,
		  jas_iccprofdata_srgblen);
		break;
	case JAS_CLRSPC_SGRAY:
		prof = jas_iccprof_createfrombuf(jas_iccprofdata_sgray,
		  jas_iccprofdata_sgraylen);
		break;
	default:
		prof = 0;
		break;
	}

----------------------------------------------------------------------------------
	switch (clrspc) {
	case JAS_CLRSPC_SYCBCR:
		if (!(prof = jas_cmprof_createsycc()))
			goto error;
		break;
	default:
		if (!(iccprof = jas_iccprof_createfromclrspc(clrspc)))
			goto error;
		if (!(prof = jas_cmprof_createfromiccprof(iccprof)))
			goto error;
		jas_iccprof_destroy(iccprof);
		iccprof = 0;
		if (!jas_clrspc_isgeneric(clrspc))
			prof->clrspc = clrspc;
		break;
	}

----------------------------------------------------------------------------------
	if (iccprof)
		jas_iccprof_destroy(iccprof);

----------------------------------------------------------------------------------
	if (!(prof = jas_cmprof_createfromclrspc(JAS_CLRSPC_SRGB)))
		goto error;

----------------------------------------------------------------------------------
	if (!(fwdpxform = jas_cmpxform_createshapmat()))
		goto error;

----------------------------------------------------------------------------------
	if (!(revpxform = jas_cmpxform_createshapmat()))
		goto error;

----------------------------------------------------------------------------------
		if (prof->pxformseqs[j]) {
			if (jas_cmpxformseq_insertpxform(prof->pxformseqs[j], 0,
			  fwdpxform))
				goto error;
		}

----------------------------------------------------------------------------------
		if (prof->pxformseqs[j]) {
			if (jas_cmpxformseq_insertpxform(prof->pxformseqs[j],
			  -1, revpxform))
				goto error;
		}

----------------------------------------------------------------------------------
	if (!(prof = jas_cmprof_create()))
		goto error;

----------------------------------------------------------------------------------
	if (!(prof->iccprof = jas_iccprof_copy(iccprof)))
		goto error;

----------------------------------------------------------------------------------
	if (prof->numchans == 1) {
		if (mono(prof->iccprof, 0, &fwdpxformseq))
			goto error;
		if (mono(prof->iccprof, 1, &revpxformseq))
			goto error;
	} else if (prof->numchans == 3) {
		if (triclr(prof->iccprof, 0, &fwdpxformseq))
			goto error;
		if (triclr(prof->iccprof, 1, &revpxformseq))
			goto error;
	}

----------------------------------------------------------------------------------
	if (prof->numchans > 1) {
		lut(prof->iccprof, 0, PER, &pxformseq);
		pxformseqs_set(prof, SEQFWD(PER), pxformseq);
		lut(prof->iccprof, 1, PER, &pxformseq);
		pxformseqs_set(prof, SEQREV(PER), pxformseq);
		lut(prof->iccprof, 0, CLR, &pxformseq);
		pxformseqs_set(prof, SEQREV(CLR), pxformseq);
		lut(prof->iccprof, 1, CLR, &pxformseq);
		pxformseqs_set(prof, SEQREV(CLR), pxformseq);
		lut(prof->iccprof, 0, SAT, &pxformseq);
		pxformseqs_set(prof, SEQREV(SAT), pxformseq);
		lut(prof->iccprof, 1, SAT, &pxformseq);
		pxformseqs_set(prof, SEQREV(SAT), pxformseq);
	}

----------------------------------------------------------------------------------
	if (fwdpxformseq) {
		jas_cmpxformseq_destroy(fwdpxformseq);
	}

----------------------------------------------------------------------------------
	if (revpxformseq) {
		jas_cmpxformseq_destroy(revpxformseq);
	}

----------------------------------------------------------------------------------
	if (prof) {
		jas_cmprof_destroy(prof);
	}

----------------------------------------------------------------------------------
	if (!(prof = jas_malloc(sizeof(jas_cmprof_t))))
		return 0;

----------------------------------------------------------------------------------
		if (prof->pxformseqs[i]) {
			jas_cmpxformseq_destroy(prof->pxformseqs[i]);
			prof->pxformseqs[i] = 0;
		}

----------------------------------------------------------------------------------
	if (prof->iccprof)
		jas_iccprof_destroy(prof->iccprof);

----------------------------------------------------------------------------------
	if (!(newprof = jas_cmprof_create()))
		goto error;

----------------------------------------------------------------------------------
		if (prof->pxformseqs[i]) {
			if (!(newprof->pxformseqs[i] = jas_cmpxformseq_copy(prof->pxformseqs[i])))
				goto error;
		}

----------------------------------------------------------------------------------
	if (newprof)
		jas_cmprof_destroy(newprof);

----------------------------------------------------------------------------------
	if (!(xform = jas_malloc(sizeof(jas_cmxform_t))))
		goto error;

----------------------------------------------------------------------------------
	if (!(xform->pxformseq = jas_cmpxformseq_create()))
		goto error;

----------------------------------------------------------------------------------
	switch (op) {
	case JAS_CMXFORM_OP_FWD:
		inpxformseq = fwdpxformseq(inprof, intent);
		outpxformseq = revpxformseq(outprof, intent);
		if (!inpxformseq || !outpxformseq)
			goto error;
		if (jas_cmpxformseq_append(xform->pxformseq, inpxformseq) ||
		  jas_cmpxformseq_appendcnvt(xform->pxformseq,
		  inprof->refclrspc, outprof->refclrspc) ||
		  jas_cmpxformseq_append(xform->pxformseq, outpxformseq))
			goto error;
		xform->numinchans = jas_clrspc_numchans(inprof->clrspc);
		xform->numoutchans = jas_clrspc_numchans(outprof->clrspc);
		break;
	case JAS_CMXFORM_OP_REV:
		outpxformseq = fwdpxformseq(outprof, intent);
		inpxformseq = revpxformseq(inprof, intent);
		if (!outpxformseq || !inpxformseq)
			goto error;
		if (jas_cmpxformseq_append(xform->pxformseq, outpxformseq) ||
		  jas_cmpxformseq_appendcnvt(xform->pxformseq,
		  outprof->refclrspc, inprof->refclrspc) ||
		  jas_cmpxformseq_append(xform->pxformseq, inpxformseq))
			goto error;
		xform->numinchans = jas_clrspc_numchans(outprof->clrspc);
		xform->numoutchans = jas_clrspc_numchans(inprof->clrspc);
		break;
	case JAS_CMXFORM_OP_PROOF:
		assert(prfprof);
		inpxformseq = fwdpxformseq(inprof, intent);
		prfpxformseq = fwdpxformseq(prfprof, prfintent);
		if (!inpxformseq || !prfpxformseq)
			goto error;
		outpxformseq = simpxformseq(outprof, intent);
		altoutpxformseq = 0;
		if (!outpxformseq) {
			outpxformseq = revpxformseq(outprof, intent);
			altoutpxformseq = fwdpxformseq(outprof, intent);
			if (!outpxformseq || !altoutpxformseq)
				goto error;
		}
		if (jas_cmpxformseq_append(xform->pxformseq, inpxformseq) ||
		  jas_cmpxformseq_appendcnvt(xform->pxformseq,
		  inprof->refclrspc, outprof->refclrspc))
			goto error;
		if (altoutpxformseq) {
			if (jas_cmpxformseq_append(xform->pxformseq, outpxformseq) ||
			  jas_cmpxformseq_append(xform->pxformseq, altoutpxformseq))
				goto error;
		} else {
			if (jas_cmpxformseq_append(xform->pxformseq, outpxformseq))
				goto error;
		}
		if (jas_cmpxformseq_appendcnvt(xform->pxformseq,
		  outprof->refclrspc, inprof->refclrspc) ||
		  jas_cmpxformseq_append(xform->pxformseq, prfpxformseq))
			goto error;
		xform->numinchans = jas_clrspc_numchans(inprof->clrspc);
		xform->numoutchans = jas_clrspc_numchans(prfprof->clrspc);
		break;
	case JAS_CMXFORM_OP_GAMUT:
		inpxformseq = fwdpxformseq(inprof, intent);
		outpxformseq = gampxformseq(outprof);
		if (!inpxformseq || !outpxformseq)
			goto error;
		if (jas_cmpxformseq_append(xform->pxformseq, inpxformseq) ||
		  jas_cmpxformseq_appendcnvt(xform->pxformseq,
		  inprof->refclrspc, outprof->refclrspc) ||
		  jas_cmpxformseq_append(xform->pxformseq, outpxformseq))
			goto error;
		xform->numinchans = jas_clrspc_numchans(inprof->clrspc);
		xform->numoutchans = 1;
		break;
	}

----------------------------------------------------------------------------------
	if (xform)
		jas_cmxform_destroy(xform);

----------------------------------------------------------------------------------
	if (xform->numinchans > in->numcmpts || xform->numoutchans > out->numcmpts)
		goto error;

----------------------------------------------------------------------------------
		if (fmt->width != width || fmt->height != height) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (fmt->width != width || fmt->height != height) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (pxform->numinchans > maxchans) {
			maxchans = pxform->numinchans;
		}

----------------------------------------------------------------------------------
		if (pxform->numoutchans > maxchans) {
			maxchans = pxform->numoutchans;
		}

----------------------------------------------------------------------------------
				if (jas_cmgetint(&dataptr, fmt->sgnd, fmt->prec, &v))
					goto error;

----------------------------------------------------------------------------------
			if (pxform->numoutchans > pxform->numinchans) {
				outbuf = (inbuf == &buf[0][0]) ? &buf[1][0] : &buf[0][0];
			} else {
				outbuf = inbuf;
			}

----------------------------------------------------------------------------------
			if ((*pxform->ops->apply)(pxform, inbuf, outbuf, m))
				goto error;

----------------------------------------------------------------------------------
				if (jas_cmputint(&dataptr, fmt->sgnd, fmt->prec, v))
					goto error;

----------------------------------------------------------------------------------
	if (xform->pxformseq)
		jas_cmpxformseq_destroy(xform->pxformseq);

----------------------------------------------------------------------------------
	if (!(pxformseq = jas_malloc(sizeof(jas_cmpxformseq_t))))
		goto error;

----------------------------------------------------------------------------------
	if (jas_cmpxformseq_resize(pxformseq, 16))
		goto error;

----------------------------------------------------------------------------------
	if (pxformseq)
		jas_cmpxformseq_destroy(pxformseq);

----------------------------------------------------------------------------------
	if (!(newpxformseq = jas_cmpxformseq_create()))
		goto error;

----------------------------------------------------------------------------------
	if (jas_cmpxformseq_append(newpxformseq, pxformseq))
		goto error;

----------------------------------------------------------------------------------
	if (newpxformseq)
		jas_cmpxformseq_destroy(newpxformseq);

----------------------------------------------------------------------------------
	if (pxformseq->pxforms)
		jas_free(pxformseq->pxforms);

----------------------------------------------------------------------------------
	if (i != pxformseq->numpxforms - 1)
		abort();

----------------------------------------------------------------------------------
	if (dstclrspc == srcclrspc)
		return 0;

----------------------------------------------------------------------------------
	if (i < 0)
		i = pxformseq->numpxforms;

----------------------------------------------------------------------------------
	if (pxformseq->numpxforms >= pxformseq->maxpxforms) {
		if (jas_cmpxformseq_resize(pxformseq, pxformseq->numpxforms +
		  16))
			goto error;
	}

----------------------------------------------------------------------------------
	if (!(tmppxform = jas_cmpxform_copy(pxform)))
		goto error;

----------------------------------------------------------------------------------
	if (n > 0) {
		memmove(&pxformseq->pxforms[i + 1], &pxformseq->pxforms[i],
		  n * sizeof(jas_cmpxform_t *));
	}

----------------------------------------------------------------------------------
	if (n > pxformseq->maxpxforms) {
		if (jas_cmpxformseq_resize(pxformseq, n))
			goto error;
	}

----------------------------------------------------------------------------------
		if (!(pxform = jas_cmpxform_copy(othpxform)))
			goto error;

----------------------------------------------------------------------------------
	if (!p) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(pxform = jas_malloc(sizeof(jas_cmpxform_t))))
		return 0;

----------------------------------------------------------------------------------
	if (--pxform->refcnt <= 0) {
		(*pxform->ops->destroy)(pxform);
		jas_free(pxform);
	}

----------------------------------------------------------------------------------
	if (!(pxform = jas_cmpxform_create0()))
		return 0;

----------------------------------------------------------------------------------
	if (!shapmat->mono) {
		while (--cnt >= 0) {
			a0 = *src++;
			a1 = *src++;
			a2 = *src++;
			if (!shapmat->order && shapmat->useluts) {
				a0 = jas_cmshapmatlut_lookup(&shapmat->luts[0], a0);
				a1 = jas_cmshapmatlut_lookup(&shapmat->luts[1], a1);
				a2 = jas_cmshapmatlut_lookup(&shapmat->luts[2], a2);
			}
			if (shapmat->usemat) {
				b0 = shapmat->mat[0][0] * a0
				  + shapmat->mat[0][1] * a1
				  + shapmat->mat[0][2] * a2
				  + shapmat->mat[0][3];
				b1 = shapmat->mat[1][0] * a0
				  + shapmat->mat[1][1] * a1
				  + shapmat->mat[1][2] * a2
				  + shapmat->mat[1][3];
				b2 = shapmat->mat[2][0] * a0
				  + shapmat->mat[2][1] * a1
				  + shapmat->mat[2][2] * a2
				  + shapmat->mat[2][3];
				a0 = b0;
				a1 = b1;
				a2 = b2;
			}
			if (shapmat->order && shapmat->useluts) {
				a0 = jas_cmshapmatlut_lookup(&shapmat->luts[0], a0);
				a1 = jas_cmshapmatlut_lookup(&shapmat->luts[1], a1);
				a2 = jas_cmshapmatlut_lookup(&shapmat->luts[2], a2);
			}
			*dst++ = a0;
			*dst++ = a1;
			*dst++ = a2;
		}
	} else {
		if (!shapmat->order) {
			while (--cnt >= 0) {
				a0 = *src++;
				if (shapmat->useluts)
					a0 = jas_cmshapmatlut_lookup(&shapmat->luts[0], a0);
				a2 = a0 * shapmat->mat[2][0];
				a1 = a0 * shapmat->mat[1][0];
				a0 = a0 * shapmat->mat[0][0];
				*dst++ = a0;
				*dst++ = a1;
				*dst++ = a2;
			}
		} else {
assert(0);
			while (--cnt >= 0) {
				a0 = *src++;
				src++;
				src++;
				a0 = a0 * shapmat->mat[0][0];
				if (shapmat->useluts)
					a0 = jas_cmshapmatlut_lookup(&shapmat->luts[0], a0);
				*dst++ = a0;
			}
		}
	}

----------------------------------------------------------------------------------
	if (lut->data) {
		jas_free(lut->data);
		lut->data = 0;
	}

----------------------------------------------------------------------------------
	if (x == 0.0)
		return 0.0;

----------------------------------------------------------------------------------
	if (curv->numents == 0) {
		lut->size = 2;
		if (!(lut->data = jas_alloc2(lut->size, sizeof(jas_cmreal_t))))
			goto error;
		lut->data[0] = 0.0;
		lut->data[1] = 1.0;
	} else if (curv->numents == 1) {
		lut->size = 256;
		if (!(lut->data = jas_alloc2(lut->size, sizeof(jas_cmreal_t))))
			goto error;
		gamma = curv->ents[0] / 256.0;
		for (i = 0; i < lut->size; ++i) {
			lut->data[i] = gammafn(i / (double) (lut->size - 1), gamma);
		}
	} else {
		lut->size = curv->numents;
		if (!(lut->data = jas_alloc2(lut->size, sizeof(jas_cmreal_t))))
			goto error;
		for (i = 0; i < lut->size; ++i) {
			lut->data[i] = curv->ents[i] / 65535.0;
		}
	}

----------------------------------------------------------------------------------
	if (lo < 0)
		return lut->data[0];

----------------------------------------------------------------------------------
	if (hi >= lut->size)
		return lut->data[lut->size - 1];

----------------------------------------------------------------------------------
	if (invlut->data) {
		jas_free(invlut->data);
		invlut->data = 0;
	}

----------------------------------------------------------------------------------
		if (lut->data[i - 1] > lut->data[i]) {
			assert(0);
			return -1;
		}

----------------------------------------------------------------------------------
	if (!(invlut->data = jas_alloc2(n, sizeof(jas_cmreal_t))))
		return -1;

----------------------------------------------------------------------------------
			if (sy == ay) {
				for (k = j + 1; k < lut->size; ++k) {
					by = lut->data[k];
					if (by != sy)
						break;
#if 0
assert(0);
#endif
				}
				if (k < lut->size) {
					--k;
					ax = ((double) j) / (lut->size - 1);
					bx = ((double) k) / (lut->size - 1);
					sx = (ax + bx) / 2.0;
				}
				break;
			}

----------------------------------------------------------------------------------
			if (j < lut->size - 1) {
				by = lut->data[j + 1];
				if (sy > ay && sy < by) {
					ax = ((double) j) / (lut->size - 1);
					bx = ((double) j + 1) / (lut->size - 1);
					sx = ax +
					  (sy - ay) / (by - ay) * (bx - ax);
					break;
				}
			}

----------------------------------------------------------------------------------
	if (JAS_ABS(d) < 1e-6)
		return -1;

----------------------------------------------------------------------------------
	if (refflag) {
		switch (iccclrspc) {
		case JAS_ICC_COLORSPC_XYZ:
			return JAS_CLRSPC_CIEXYZ;
		case JAS_ICC_COLORSPC_LAB:
			return JAS_CLRSPC_CIELAB;
		default:
			abort();
			break;
		}
	} else {
		switch (iccclrspc) {
		case JAS_ICC_COLORSPC_YCBCR:
			return JAS_CLRSPC_GENYCBCR;
		case JAS_ICC_COLORSPC_RGB:
			return JAS_CLRSPC_GENRGB;
		case JAS_ICC_COLORSPC_GRAY:
			return JAS_CLRSPC_GENGRAY;
		default:
			abort();
			break;
		}
	}

----------------------------------------------------------------------------------
	if (!(graytrc = jas_iccprof_getattr(iccprof, JAS_ICC_TAG_GRYTRC)) ||
	  graytrc->type != JAS_ICC_TYPE_CURV)
		goto error;

----------------------------------------------------------------------------------
	if (!(pxform = jas_cmpxform_createshapmat()))
		goto error;

----------------------------------------------------------------------------------
	if (!(pxformseq = jas_cmpxformseq_create()))
		goto error;

----------------------------------------------------------------------------------
	if (jas_cmpxformseq_insertpxform(pxformseq, -1, pxform))
		goto error;

----------------------------------------------------------------------------------
	if (!op) {
		shapmat->order = 0;

----------------------------------------------------------------------------------
		if (jas_cmshapmatlut_set(&shapmat->luts[0], &graytrc->data.curv))
			goto error;

----------------------------------------------------------------------------------
		if (jas_cmshapmatlut_set(&lut, &graytrc->data.curv))
			goto error;

----------------------------------------------------------------------------------
		if (jas_cmshapmatlut_invert(&shapmat->luts[0], &lut, lut.size))
			goto error;

----------------------------------------------------------------------------------
	if (!(trcs[0] = jas_iccprof_getattr(iccprof, JAS_ICC_TAG_REDTRC)) ||
	  !(trcs[1] = jas_iccprof_getattr(iccprof, JAS_ICC_TAG_GRNTRC)) ||

----------------------------------------------------------------------------------
		if (trcs[i]->type != JAS_ICC_TYPE_CURV ||
		  cols[i]->type != JAS_ICC_TYPE_XYZ)
			goto error;

----------------------------------------------------------------------------------
	if (!(pxform = jas_cmpxform_createshapmat()))
		goto error;

----------------------------------------------------------------------------------
	if (!(pxformseq = jas_cmpxformseq_create()))
		goto error;

----------------------------------------------------------------------------------
	if (jas_cmpxformseq_insertpxform(pxformseq, -1, pxform))
		goto error;

----------------------------------------------------------------------------------
	if (!op) {
		shapmat->order = 0;

----------------------------------------------------------------------------------
			if (jas_cmshapmatlut_set(&shapmat->luts[i], &trcs[i]->data.curv))
				goto error;

----------------------------------------------------------------------------------
		if (jas_cmshapmat_invmat(shapmat->mat, mat))
			goto error;

----------------------------------------------------------------------------------
			if (jas_cmshapmatlut_set(&lut, &trcs[i]->data.curv))
				goto error;

----------------------------------------------------------------------------------
			if (jas_cmshapmatlut_invert(&shapmat->luts[i], &lut, lut.size))
				goto error;

----------------------------------------------------------------------------------
		if (trcs[i]) {
			jas_iccattrval_destroy(trcs[i]);

----------------------------------------------------------------------------------
		if (cols[i]) {
			jas_iccattrval_destroy(cols[i]);

----------------------------------------------------------------------------------
	if (pxformseq) {
		jas_cmpxformseq_destroy(pxformseq);

----------------------------------------------------------------------------------
	if (pxform) {
		jas_cmpxform_destroy(pxform);

----------------------------------------------------------------------------------
	if (sgnd) {
		m = (1 << (prec - 1));

----------------------------------------------------------------------------------
		if (v < -m || v >= m)
			return -1;

----------------------------------------------------------------------------------
		if (v < 0 || v >= (1 << prec))
			return -1;

----------------------------------------------------------------------------------
	if (sgnd) {
		m = (1 << (prec - 1));

----------------------------------------------------------------------------------
		if (val < -m || val >= m)
			return -1;

----------------------------------------------------------------------------------
		if (val < 0 || val >= (1 << prec))
			return -1;

----------------------------------------------------------------------------------
	switch (jas_clrspc_fam(clrspc)) {
	case JAS_CLRSPC_FAM_XYZ:
	case JAS_CLRSPC_FAM_LAB:
	case JAS_CLRSPC_FAM_RGB:
	case JAS_CLRSPC_FAM_YCBCR:
		return 3;
		break;
	case JAS_CLRSPC_FAM_GRAY:
		return 1;
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (pnm_parseencopts(optstr ? optstr : "", &encopts)) {
		jas_eprintf("invalid PNM encoder options specified\n");
		return -1;
	}

----------------------------------------------------------------------------------
	switch (clrspc_fam) {
	case JAS_CLRSPC_FAM_RGB:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SRGB)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 3;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R))) < 0 ||
		  (enc->cmpts[1] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G))) < 0 ||
		  (enc->cmpts[2] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	case JAS_CLRSPC_FAM_GRAY:
		if (jas_image_clrspc(image) != JAS_CLRSPC_SGRAY)
			jas_eprintf("warning: inaccurate color\n");
		enc->numcmpts = 1;
		if ((enc->cmpts[0] = jas_image_getcmptbytype(image,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y))) < 0) {
			jas_eprintf("error: missing color component\n");
			return -1;
		}
		break;
	default:
		jas_eprintf("error: unsupported color space %d\n", clrspc_fam);
		return -1;
		break;
	}

----------------------------------------------------------------------------------
		if (jas_image_cmptwidth(image, enc->cmpts[cmptno]) != width ||
		  jas_image_cmptheight(image, enc->cmpts[cmptno]) != height ||
		  jas_image_cmptprec(image, enc->cmpts[cmptno]) != prec ||
		  jas_image_cmptsgnd(image, enc->cmpts[cmptno]) != sgnd ||
		  jas_image_cmpthstep(image, enc->cmpts[cmptno]) != jas_image_cmpthstep(image, 0) ||
		  jas_image_cmptvstep(image, enc->cmpts[cmptno]) != jas_image_cmptvstep(image, 0) ||
		  jas_image_cmpttlx(image, enc->cmpts[cmptno]) != jas_image_cmpttlx(image, 0) ||
		  jas_image_cmpttly(image, enc->cmpts[cmptno]) != jas_image_cmpttly(image, 0)) {
			jas_eprintf("The PNM format cannot be used to represent an image with this geometry.\n");
			return -1;

----------------------------------------------------------------------------------
	if (sgnd) {
		jas_eprintf("warning: support for signed sample data requires use of nonstandard extension to PNM format\n");

----------------------------------------------------------------------------------
	if (enc->numcmpts == 1) {
		hdr.magic = encopts.bin ? PNM_MAGIC_BINPGM : PNM_MAGIC_TXTPGM;

----------------------------------------------------------------------------------
	if (pnm_puthdr(out, &hdr)) {
		return -1;

----------------------------------------------------------------------------------
	if (pnm_putdata(out, &hdr, image, enc->numcmpts, enc->cmpts)) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_flush(out)) {
		return -1;

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		goto error;

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(pnm_opttab,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_TEXT:
			encopts->bin = false;
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}	

----------------------------------------------------------------------------------
	if (ret < 0) {
		goto error;

----------------------------------------------------------------------------------
	if (tvp) {
		jas_tvparser_destroy(tvp);

----------------------------------------------------------------------------------
	if (pnm_putuint16(out, hdr->magic)) {
		return -1;

----------------------------------------------------------------------------------
	if (hdr->sgnd) {
		maxval = -hdr->maxval;

----------------------------------------------------------------------------------
	if (jas_stream_error(out)) {
		return -1;

----------------------------------------------------------------------------------
		if (!(data[cmptno] = jas_matrix_create(1, hdr->width))) {
			goto done;

----------------------------------------------------------------------------------
			if (jas_image_readcmpt(image, cmpts[cmptno], 0, y, hdr->width, 1,
			  data[cmptno])) {

----------------------------------------------------------------------------------
				if (v < minval) {
					v = minval;
				}

----------------------------------------------------------------------------------
				if (v > ((int) hdr->maxval)) {
					v = hdr->maxval;

----------------------------------------------------------------------------------
				if (fmt == PNM_FMT_BIN) {
					if (hdr->sgnd) {

----------------------------------------------------------------------------------
						if (pnm_putsint(out, depth, &sv)) {
							goto done;
						}

----------------------------------------------------------------------------------
						if (pnm_putuint(out, depth, &uv)) {
							goto done;

----------------------------------------------------------------------------------
					if (linelen > 0 && linelen + n > PNM_MAXLINELEN) {
						jas_stream_printf(out, "\n");

----------------------------------------------------------------------------------
		if (fmt != PNM_FMT_BIN) {
			jas_stream_printf(out, "\n");

----------------------------------------------------------------------------------
		if (jas_stream_error(out)) {
			goto done;

----------------------------------------------------------------------------------
		if (data[cmptno]) {
			jas_matrix_destroy(data[cmptno]);

----------------------------------------------------------------------------------
		if (jas_stream_putc(out, c) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, (unsigned char)(val >> 8)) == EOF ||
	  jas_stream_putc(out, (unsigned char)(val & 0xff)) == EOF) {

----------------------------------------------------------------------------------
	switch (magic) {
	case PNM_MAGIC_TXTPPM:
	case PNM_MAGIC_BINPPM:
		type = PNM_TYPE_PPM;
		break;
	case PNM_MAGIC_TXTPGM:
	case PNM_MAGIC_BINPGM:
		type = PNM_TYPE_PGM;
		break;
	case PNM_MAGIC_TXTPBM:
	case PNM_MAGIC_BINPBM:
		type = PNM_TYPE_PBM;
		break;
	default:
		/* This should not happen. */
		type = PNM_TYPE_INVALID;
		break;
	}

----------------------------------------------------------------------------------
	switch (magic) {
	case PNM_MAGIC_TXTPBM:
	case PNM_MAGIC_TXTPGM:
	case PNM_MAGIC_TXTPPM:
		fmt = PNM_FMT_TXT;
		break;
	case PNM_MAGIC_BINPBM:
	case PNM_MAGIC_BINPGM:
	case PNM_MAGIC_BINPPM:
		fmt = PNM_FMT_BIN;
		break;
	default:
		/* This should not happen. */
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		return -1;
	}

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(pnm_decopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_ALLOWTRUNC:
			opts->allow_trunc = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_MAXSIZE:
			opts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (pnm_dec_parseopts(optstr, &opts)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (pnm_gethdr(in, &hdr)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul3(hdr.width, hdr.height, hdr.numcmpts,
	  &num_samples)) {
		jas_eprintf("image too large\n");
		goto error;

----------------------------------------------------------------------------------
	if (opts.max_samples > 0 && num_samples > opts.max_samples) {
		jas_eprintf(

----------------------------------------------------------------------------------
	if (!(image = jas_image_create(hdr.numcmpts, cmptparms,
	  JAS_CLRSPC_UNKNOWN))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (hdr.numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);

----------------------------------------------------------------------------------
	if (pnm_getdata(in, &hdr, image, opts.allow_trunc)) {
		goto error;

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, buf, 2)) < 0) {
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (n < 2) {
		return -1;

----------------------------------------------------------------------------------
	if (buf[0] == 'P' && isdigit(buf[1])) {
		return 0;

----------------------------------------------------------------------------------
	if (pnm_getint16(in, &hdr->magic) || pnm_getsintstr(in, &width) ||
	  pnm_getsintstr(in, &height)) {

----------------------------------------------------------------------------------
	if ((type = pnm_type(hdr->magic)) == PNM_TYPE_INVALID) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (type != PNM_TYPE_PBM) {
		if (pnm_getsintstr(in, &maxval)) {

----------------------------------------------------------------------------------
	if (maxval < 0) {
		hdr->maxval = -maxval;
		hdr->sgnd = true;

----------------------------------------------------------------------------------
	switch (type) {
	case PNM_TYPE_PBM:
	case PNM_TYPE_PGM:
		hdr->numcmpts = 1;
		break;
	case PNM_TYPE_PPM:
		hdr->numcmpts = 3;
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
		if (!(data[cmptno] = jas_matrix_create(1, hdr->width))) {
			goto done;

----------------------------------------------------------------------------------
		if (type == PNM_TYPE_PBM) {
			if (fmt == PNM_FMT_BIN) {

----------------------------------------------------------------------------------
					if ((c = jas_stream_getc(in)) == EOF) {
						goto done;
					}

----------------------------------------------------------------------------------
					if (pnm_getbitstr(in, &uv)) {
						goto done;

----------------------------------------------------------------------------------
					if (fmt == PNM_FMT_BIN) {
						/* The sample data is in binary format. */

----------------------------------------------------------------------------------
						if (hdr->sgnd) {
							/* The sample data is signed. */

----------------------------------------------------------------------------------
							if (pnm_getsint(in, depth, &sv)) {
								if (!allow_trunc) {

----------------------------------------------------------------------------------
							if (pnm_getuint(in, depth, &uv)) {
								if (!allow_trunc) {
									goto done;
								}
								jas_eprintf("bad sample data\n");

----------------------------------------------------------------------------------
						if (hdr->sgnd) {
							/* The sample data is signed. */

----------------------------------------------------------------------------------
							if (pnm_getsintstr(in, &sv)) {
								if (!allow_trunc) {

----------------------------------------------------------------------------------
							if (pnm_getuintstr(in, &uv)) {
								if (!allow_trunc) {
									goto done;
								}
								jas_eprintf("bad sample data\n");

----------------------------------------------------------------------------------
			if (jas_image_writecmpt(image, cmptno, 0, y, hdr->width, 1,
			  data[cmptno])) {

----------------------------------------------------------------------------------
		if (data[cmptno]) {
			jas_matrix_destroy(data[cmptno]);
		}

----------------------------------------------------------------------------------
	if (pnm_getuint(in, wordsize, &tmpval)) {
		return -1;

----------------------------------------------------------------------------------
	if ((tmpval & (1 << (wordsize - 1))) != 0) {
		jas_eprintf("PNM decoder does not fully support signed data\n");

----------------------------------------------------------------------------------
	if (val) {
		*val = tmpval;

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = tmpval;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if (c == '#') {
			for (;;) {

----------------------------------------------------------------------------------
				if ((c = pnm_getc(in)) == EOF) {
					return -1;
				}

----------------------------------------------------------------------------------
				if (c == '\n') {
					break;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) < 0) {
			return -1;

----------------------------------------------------------------------------------
	if (!isspace(c)) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (c == '-') {
		s = -1;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if ((c = pnm_getc(in)) < 0) {
			return -1;

----------------------------------------------------------------------------------
	if (!isspace(c)) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = (s >= 0) ? v : (-v);

----------------------------------------------------------------------------------
		if ((c = jas_stream_getc(in)) == EOF) {
			return -1;

----------------------------------------------------------------------------------
		if (c != '#') {
			return c;

----------------------------------------------------------------------------------
			if ((c = jas_stream_getc(in)) == EOF) {
				return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	switch (mctid) {
	case JPC_MCT_RCT:
		switch (cmptno) {
		case 0:
			synweight = jpc_dbltofix(sqrt(3.0));
			break;
		case 1:
			synweight = jpc_dbltofix(sqrt(0.6875));
			break;
		case 2:
			synweight = jpc_dbltofix(sqrt(0.6875));
			break;
		}
		break;
	case JPC_MCT_ICT:
		switch (cmptno) {
		case 0:
			synweight = jpc_dbltofix(sqrt(3.0000));
			break;
		case 1:
			synweight = jpc_dbltofix(sqrt(3.2584));
			break;
		case 2:
			synweight = jpc_dbltofix(sqrt(2.4755));
			break;
		}
		break;
#if 0
	default:
		synweight = JPC_FIX_ONE;
		break;
#endif
	}

----------------------------------------------------------------------------------
	if (!(cstate = jas_malloc(sizeof(jpc_cstate_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(ms = jpc_ms_create(0))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||
	  ms->id > JPC_MS_MAX) {
		jpc_ms_destroy(ms);
		return 0;

----------------------------------------------------------------------------------
	if (JPC_MS_HASPARMS(ms->id)) {
		/* Get the length of the marker segment. */

----------------------------------------------------------------------------------
		if (jpc_getuint16(in, &ms->len) || ms->len < 3) {
			jpc_ms_destroy(ms);

----------------------------------------------------------------------------------
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			jpc_ms_destroy(ms);

----------------------------------------------------------------------------------
		if (jas_stream_copy(tmpstream, in, ms->len) ||
		  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {

----------------------------------------------------------------------------------
		if ((*ms->ops->getparms)(ms, cstate, tmpstream)) {
			ms->ops = 0;
			jpc_ms_destroy(ms);

----------------------------------------------------------------------------------
		if (jas_getdbglevel() > 0) {
			jpc_ms_dump(ms, stderr);

----------------------------------------------------------------------------------
		if (JAS_CAST(jas_ulong, jas_stream_tell(tmpstream)) != ms->len) {
			jas_eprintf(

----------------------------------------------------------------------------------
		if (jas_getdbglevel() > 0) {
			jpc_ms_dump(ms, stderr);
		}

----------------------------------------------------------------------------------
	if (ms->id == JPC_MS_SIZ) {
		cstate->numcomps = ms->parms.siz.numcomps;

----------------------------------------------------------------------------------
	if (jpc_putuint16(out, ms->id)) {
		return -1;

----------------------------------------------------------------------------------
	if (ms->ops->putparms) {
		/* Create a temporary stream in which to buffer the

----------------------------------------------------------------------------------
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			return -1;

----------------------------------------------------------------------------------
		if ((*ms->ops->putparms)(ms, cstate, tmpstream)) {
			jas_stream_close(tmpstream);

----------------------------------------------------------------------------------
		if ((len = jas_stream_tell(tmpstream)) < 0) {
			jas_stream_close(tmpstream);

----------------------------------------------------------------------------------
		if (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 ||
		  jpc_putuint16(out, ms->len + 2) ||

----------------------------------------------------------------------------------
	if (ms->id == JPC_MS_SIZ) {
		cstate->numcomps = ms->parms.siz.numcomps;
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() > 0) {
		jpc_ms_dump(ms, stderr);

----------------------------------------------------------------------------------
	if (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (ms->ops && ms->ops->destroyparms) {
		(*ms->ops->destroyparms)(ms);

----------------------------------------------------------------------------------
	if (JPC_MS_HASPARMS(ms->id)) {
		fprintf(out, " len = %"PRIuFAST16";", ms->len + 2);

----------------------------------------------------------------------------------
		if (ms->ops->dumpparms) {
			(*ms->ops->dumpparms)(ms, out);

----------------------------------------------------------------------------------
	if (jpc_getuint16(in, &sot->tileno) ||
	  jpc_getuint32(in, &sot->len) ||

----------------------------------------------------------------------------------
	if (sot->tileno > 65534 || sot->len < 12 || sot->partno > 254 ||
	  sot->numparts < 1 || sot->numparts > 255) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_stream_eof(in)) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putuint16(out, sot->tileno) ||
	  jpc_putuint32(out, sot->len) ||

----------------------------------------------------------------------------------
	if (siz->comps) {
		jas_free(siz->comps);
	}

----------------------------------------------------------------------------------
	if (jpc_getuint16(in, &siz->caps) ||
	  jpc_getuint32(in, &siz->width) ||

----------------------------------------------------------------------------------
	if (!siz->width || !siz->height) {
		jas_eprintf("reference grid cannot have zero area\n");
		goto error;

----------------------------------------------------------------------------------
	if (!siz->tilewidth || !siz->tileheight) {
		jas_eprintf("tile cannot have zero area\n");

----------------------------------------------------------------------------------
	if (!siz->numcomps || siz->numcomps > 16384) {
		jas_eprintf("number of components not in permissible range\n");

----------------------------------------------------------------------------------
	if (siz->xoff >= siz->width) {
		jas_eprintf("XOsiz not in permissible range\n");

----------------------------------------------------------------------------------
	if (siz->yoff >= siz->height) {
		jas_eprintf("YOsiz not in permissible range\n");

----------------------------------------------------------------------------------
	if (siz->tilexoff > siz->xoff || siz->tilexoff + siz->tilewidth <= siz->xoff) {
		jas_eprintf("XTOsiz not in permissible range\n");

----------------------------------------------------------------------------------
	if (siz->tileyoff > siz->yoff || siz->tileyoff + siz->tileheight <= siz->yoff) {
		jas_eprintf("YTOsiz not in permissible range\n");

----------------------------------------------------------------------------------
	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
		goto error;

----------------------------------------------------------------------------------
		if (jpc_getuint8(in, &tmp) ||
		  jpc_getuint8(in, &siz->comps[i].hsamp) ||

----------------------------------------------------------------------------------
		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
			jas_eprintf("invalid XRsiz value %d\n", siz->comps[i].hsamp);
			goto error;

----------------------------------------------------------------------------------
		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
			jas_eprintf("invalid YRsiz value %d\n", siz->comps[i].vsamp);

----------------------------------------------------------------------------------
	if (jas_stream_eof(in)) {
		goto error;

----------------------------------------------------------------------------------
	if (siz->comps) {
		jas_free(siz->comps);

----------------------------------------------------------------------------------
	if (jpc_putuint16(out, siz->caps) ||
	  jpc_putuint32(out, siz->width) ||

----------------------------------------------------------------------------------
		if (jpc_putuint8(out, ((siz->comps[i].sgnd & 1) << 7) |
		  ((siz->comps[i].prec - 1) & 0x7f)) ||
		  jpc_putuint8(out, siz->comps[i].hsamp) ||
		  jpc_putuint8(out, siz->comps[i].vsamp)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &cod->csty)) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &cod->prg) ||
	  jpc_getuint16(in, &cod->numlyrs) ||

----------------------------------------------------------------------------------
	if (cod->numlyrs < 1 || cod->numlyrs > 65535) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jpc_cox_getcompparms(ms, cstate, in,
	  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {

----------------------------------------------------------------------------------
	if (jas_stream_eof(in)) {
		jpc_cod_destroyparms(ms);
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putuint8(out, cod->compparms.csty) ||
	  jpc_putuint8(out, cod->prg) ||

----------------------------------------------------------------------------------
	if (jpc_cox_putcompparms(ms, cstate, out,
	  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (cod->csty & JPC_COX_PRT) {
		for (i = 0; i < cod->compparms.numrlvls; ++i) {

----------------------------------------------------------------------------------
	if (cstate->numcomps <= 256) {
		if (jpc_getuint8(in, &tmp)) {
			return -1;
		}
		coc->compno = tmp;

----------------------------------------------------------------------------------
		if (jpc_getuint16(in, &coc->compno)) {
			return -1;

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &coc->compparms.csty)) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_cox_getcompparms(ms, cstate, in,
	  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {

----------------------------------------------------------------------------------
	if (jas_stream_eof(in)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (cstate->numcomps <= 256) {
		if (jpc_putuint8(out, coc->compno)) {

----------------------------------------------------------------------------------
		if (jpc_putuint16(out, coc->compno)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_putuint8(out, coc->compparms.csty)) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_cox_putcompparms(ms, cstate, out,
	  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &compparms->numdlvls) ||
	  jpc_getuint8(in, &compparms->cblkwidthval) ||
	  jpc_getuint8(in, &compparms->cblkheightval) ||
	  jpc_getuint8(in, &compparms->cblksty) ||
	  jpc_getuint8(in, &compparms->qmfbid)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (compparms->numdlvls > 32) {
		goto error;

----------------------------------------------------------------------------------
	if (compparms->numrlvls > JPC_MAXRLVLS) {
		goto error;

----------------------------------------------------------------------------------
	if (prtflag) {
		for (i = 0; i < compparms->numrlvls; ++i) {

----------------------------------------------------------------------------------
			if (jpc_getuint8(in, &tmp)) {
				goto error;
			}

----------------------------------------------------------------------------------
	if (jas_stream_eof(in)) {
		goto error;

----------------------------------------------------------------------------------
	if (compparms) {
		jpc_cox_destroycompparms(compparms);

----------------------------------------------------------------------------------
	if (jpc_putuint8(out, compparms->numdlvls) ||
	  jpc_putuint8(out, compparms->cblkwidthval) ||

----------------------------------------------------------------------------------
	if (prtflag) {
		for (i = 0; i < compparms->numrlvls; ++i) {
			if (jpc_putuint8(out,
			  ((compparms->rlvls[i].parheightval & 0xf) << 4) |
			  (compparms->rlvls[i].parwidthval & 0xf))) {
				return -1;
			}
		}
	}

----------------------------------------------------------------------------------
	if (cstate->numcomps <= 256) {
		if (jpc_getuint8(in, &tmp)) {

----------------------------------------------------------------------------------
		if (jpc_getuint16(in, &rgn->compno)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &rgn->roisty) ||
	  jpc_getuint8(in, &rgn->roishift)) {

----------------------------------------------------------------------------------
	if (cstate->numcomps <= 256) {
		if (jpc_putuint8(out, rgn->compno)) {
			return -1;
		}
	} else {

----------------------------------------------------------------------------------
		if (jpc_putuint16(out, rgn->compno)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_putuint8(out, rgn->roisty) ||
	  jpc_putuint8(out, rgn->roishift)) {

----------------------------------------------------------------------------------
	if (cstate->numcomps <= 256) {
		if (jpc_getuint8(in, &tmp)) {
			return -1;
		}
		qcc->compno = tmp;

----------------------------------------------------------------------------------
		if (jpc_getuint16(in, &qcc->compno)) {
			return -1;

----------------------------------------------------------------------------------
	if (jpc_qcx_getcompparms(&qcc->compparms, cstate, in, len)) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_eof(in)) {
		jpc_qcc_destroyparms(ms);

----------------------------------------------------------------------------------
	if (cstate->numcomps <= 256) {
		if (jpc_putuint8(out, qcc->compno)) {

----------------------------------------------------------------------------------
		if (jpc_putuint16(out, qcc->compno)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) {
		return -1;

----------------------------------------------------------------------------------
	if (compparms->stepsizes) {
		jas_free(compparms->stepsizes);

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &tmp)) {
		return -1;

----------------------------------------------------------------------------------
	switch (compparms->qntsty) {
	case JPC_QCX_SIQNT:
		compparms->numstepsizes = 1;
		break;
	case JPC_QCX_NOQNT:
		compparms->numstepsizes = (len - n);
		break;
	case JPC_QCX_SEQNT:
		/* XXX - this is a hack */
		compparms->numstepsizes = (len - n) / 2;
		break;
	}

----------------------------------------------------------------------------------
	if (compparms->numstepsizes > 3 * JPC_MAXRLVLS + 1) {
		jpc_qcx_destroycompparms(compparms);

----------------------------------------------------------------------------------
	if (compparms->numstepsizes > 0) {
		if (!(compparms->stepsizes = jas_alloc2(compparms->numstepsizes,

----------------------------------------------------------------------------------
			if (compparms->qntsty == JPC_QCX_NOQNT) {
				if (jpc_getuint8(in, &tmp)) {
					return -1;
				}
				compparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);

----------------------------------------------------------------------------------
				if (jpc_getuint16(in, &compparms->stepsizes[i])) {
					return -1;

----------------------------------------------------------------------------------
	if (jas_stream_error(in) || jas_stream_eof(in)) {
		jpc_qcx_destroycompparms(compparms);

----------------------------------------------------------------------------------
		if (compparms->qntsty == JPC_QCX_NOQNT) {
			if (jpc_putuint8(out, JPC_QCX_GETEXPN(

----------------------------------------------------------------------------------
			if (jpc_putuint16(out, compparms->stepsizes[i])) {
				return -1;
			}

----------------------------------------------------------------------------------
	if (jpc_getuint16(in, &sop->seqno)) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putuint16(out, sop->seqno)) {
		return -1;

----------------------------------------------------------------------------------
	if (ppm->data) {
		jas_free(ppm->data);

----------------------------------------------------------------------------------
	if (ms->len < 1) {
		goto error;

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &ppm->ind)) {
		goto error;

----------------------------------------------------------------------------------
	if (ppm->len > 0) {
		if (!(ppm->data = jas_malloc(ppm->len))) {

----------------------------------------------------------------------------------
		if (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (JAS_CAST(jas_uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {
		return -1;

----------------------------------------------------------------------------------
	if (ppm->len > 0) {
		fprintf(out, "data =\n");

----------------------------------------------------------------------------------
	if (ppt->data) {
		jas_free(ppt->data);

----------------------------------------------------------------------------------
	if (ms->len < 1) {
		goto error;

----------------------------------------------------------------------------------
	if (jpc_getuint8(in, &ppt->ind)) {
		goto error;

----------------------------------------------------------------------------------
	if (ppt->len > 0) {
		if (!(ppt->data = jas_malloc(ppt->len))) {

----------------------------------------------------------------------------------
		if (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (jpc_putuint8(out, ppt->ind)) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_write(out, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {
		return -1;

----------------------------------------------------------------------------------
	if (ppt->len > 0) {
		fprintf(out, "data =\n");

----------------------------------------------------------------------------------
	if (poc->pchgs) {
		jas_free(poc->pchgs);

----------------------------------------------------------------------------------
	if (!(poc->pchgs = jas_alloc2(poc->numpchgs, sizeof(jpc_pocpchg_t)))) {
		goto error;

----------------------------------------------------------------------------------
		if (jpc_getuint8(in, &pchg->rlvlnostart)) {
			goto error;

----------------------------------------------------------------------------------
		if (cstate->numcomps > 256) {
			if (jpc_getuint16(in, &pchg->compnostart)) {

----------------------------------------------------------------------------------
			if (jpc_getuint8(in, &tmp)) {
				goto error;
			};

----------------------------------------------------------------------------------
		if (jpc_getuint16(in, &pchg->lyrnoend) ||
		  jpc_getuint8(in, &pchg->rlvlnoend)) {

----------------------------------------------------------------------------------
		if (cstate->numcomps > 256) {
			if (jpc_getuint16(in, &pchg->compnoend)) {
				goto error;
			}
		} else {

----------------------------------------------------------------------------------
			if (jpc_getuint8(in, &tmp)) {
				goto error;
			}

----------------------------------------------------------------------------------
		if (jpc_getuint8(in, &pchg->prgord)) {
			goto error;

----------------------------------------------------------------------------------
		if (pchg->rlvlnostart > pchg->rlvlnoend ||
		  pchg->compnostart > pchg->compnoend) {

----------------------------------------------------------------------------------
		if (jpc_putuint8(out, pchg->rlvlnostart) ||
		  ((cstate->numcomps > 256) ?
		  jpc_putuint16(out, pchg->compnostart) :
		  jpc_putuint8(out, pchg->compnostart)) ||
		  jpc_putuint16(out, pchg->lyrnoend) ||
		  jpc_putuint8(out, pchg->rlvlnoend) ||
		  ((cstate->numcomps > 256) ?
		  jpc_putuint16(out, pchg->compnoend) :
		  jpc_putuint8(out, pchg->compnoend)) ||
		  jpc_putuint8(out, pchg->prgord)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (crg->comps) {
		jas_free(crg->comps);

----------------------------------------------------------------------------------
	if (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(jpc_crgcomp_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (jpc_getuint16(in, &comp->hoff) ||
		  jpc_getuint16(in, &comp->voff)) {

----------------------------------------------------------------------------------
		if (jpc_putuint16(out, comp->hoff) ||
		  jpc_putuint16(out, comp->voff)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (com->data) {
		jas_free(com->data);

----------------------------------------------------------------------------------
	if (jpc_getuint16(in, &com->regid)) {
		return -1;

----------------------------------------------------------------------------------
	if (com->len > 0) {
		if (!(com->data = jas_malloc(com->len))) {

----------------------------------------------------------------------------------
		if (jas_stream_read(in, com->data, com->len) != JAS_CAST(int, com->len)) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_putuint16(out, com->regid)) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_write(out, com->data, com->len) != JAS_CAST(int, com->len)) {
		return -1;

----------------------------------------------------------------------------------
		if (!isprint(com->data[i])) {
			printable = 0;

----------------------------------------------------------------------------------
	if (printable) {
		fprintf(out, "data = ");

----------------------------------------------------------------------------------
	if (unk->data) {
		jas_free(unk->data);

----------------------------------------------------------------------------------
	if (ms->len > 0) {
		if (!(unk->data = jas_alloc2(ms->len, sizeof(unsigned char)))) {

----------------------------------------------------------------------------------
		if (jas_stream_read(in, (char *) unk->data, ms->len) !=
		  JAS_CAST(int, ms->len)) {
			jas_free(unk->data);
			return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = c;

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, val & 0xff) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||
	  jas_stream_putc(out, val & 0xff) == EOF) {

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;
	}

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(in)) == EOF) {
		return -1;

----------------------------------------------------------------------------------
	if (val) {
		*val = v;

----------------------------------------------------------------------------------
	if (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||
	  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||

----------------------------------------------------------------------------------
		if (mstabent->id == id || mstabent->id < 0) {
			return mstabent;
		}

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (n < 2) {
		return -1;

----------------------------------------------------------------------------------
	if (buf[0] == (JPC_MS_SOC >> 8) && buf[1] == (JPC_MS_SOC & 0xff)) {
		return 0;

----------------------------------------------------------------------------------
		if (jpc_bitstream_putbit(out, 1) == EOF) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (jpc_bitstream_putbit(out, 0) == EOF) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (n <= 0) {
		return -1;
	} else if (n == 1) {
		ret = jpc_bitstream_putbit(out, 0);
	} else if (n == 2) {
		ret = jpc_bitstream_putbits(out, 2, 2);
	} else if (n <= 5) {
		ret = jpc_bitstream_putbits(out, 4, 0xc | (n - 3));
	} else if (n <= 36) {
		ret = jpc_bitstream_putbits(out, 9, 0x1e0 | (n - 6));
	} else if (n <= 164) {
		ret = jpc_bitstream_putbits(out, 16, 0xff80 | (n - 37));
	} else {
		/* The standard has no provision for encoding a larger value.
		In practice, however, it is highly unlikely that this
		limitation will ever be encountered. */
		return -1;
	}

----------------------------------------------------------------------------------
	if (!jpc_pi_next(pi)) {
		for (;;) {
			if (jpc_enc_encpkt(enc, out, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi),
			  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {
				return -1;
			}
			if (jpc_pi_next(pi)) {
				break;
			}
		}
	}

----------------------------------------------------------------------------------
	if (cp->tcp.csty & JPC_COD_SOP) {
		if (!(ms = jpc_ms_create(JPC_MS_SOP))) {
			return -1;
		}
		ms->parms.sop.seqno = jpc_pi_getind(tile->pi);
		if (jpc_putms(out, enc->cstate, ms)) {
			return -1;
		}
		jpc_ms_destroy(ms);
	}

----------------------------------------------------------------------------------
	if (!(outb = jpc_bitstream_sopen(out, "w+"))) {
		abort();
	}

----------------------------------------------------------------------------------
	if (jpc_bitstream_putbit(outb, 1) == EOF) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (!band->data) {
			continue;
		}

----------------------------------------------------------------------------------
		if (!prc->cblks) {
			continue;
		}

----------------------------------------------------------------------------------
			if (!lyrno) {
				leaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks);
				jpc_tagtree_setvalue(prc->nlibtree, leaf, cblk->numimsbs);
			}

----------------------------------------------------------------------------------
			if (included && (!cblk->numencpasses)) {
				assert(pass->lyrno == lyrno);
				leaf = jpc_tagtree_getleaf(prc->incltree,
				  cblk - prc->cblks);
				jpc_tagtree_setvalue(prc->incltree, leaf, pass->lyrno);
			}

----------------------------------------------------------------------------------
			if (!cblk->numencpasses) {
				leaf = jpc_tagtree_getleaf(prc->incltree,
				  cblk - prc->cblks);
				if (jpc_tagtree_encode(prc->incltree, leaf, lyrno + 1, outb) <
				  0) {
					return -1;
				}
			} else {
				if (jpc_bitstream_putbit(outb, included) == EOF) {
					return -1;
				}
			}

----------------------------------------------------------------------------------
			if (!included) {
				continue;
			}

----------------------------------------------------------------------------------
			if (!cblk->numencpasses) {
				i = 1;
				leaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks);
				for (;;) {
					if ((ret = jpc_tagtree_encode(prc->nlibtree, leaf, i,
					  outb)) < 0) {
						return -1;
					}
					if (ret) {
						break;
					}
					++i;
				}
				assert(leaf->known_ && i == leaf->value_ + 1);
			}

----------------------------------------------------------------------------------
			if (jpc_putnumnewpasses(outb, numnewpasses)) {
				return -1;
			}

----------------------------------------------------------------------------------
				if (pass->term || pass == lastpass) {
					datalen = pass->end - n;
					t1 = jpc_firstone(datalen) + 1;
					t2 = cblk->numlenbits + jpc_floorlog2(passcount);
					adjust = JAS_MAX(t1 - t2, 0);
					maxadjust = JAS_MAX(adjust, maxadjust);
					n += datalen;
					passcount = 1;
				} else {
					++passcount;
				}

----------------------------------------------------------------------------------
			if (jpc_putcommacode(outb, maxadjust)) {
				return -1;
			}

----------------------------------------------------------------------------------
				if (pass->term || pass == lastpass) {
					datalen = pass->end - n;
					assert(jpc_firstone(datalen) < cblk->numlenbits +
					  jpc_floorlog2(passcount));
					if (jpc_bitstream_putbits(outb, cblk->numlenbits +
					  jpc_floorlog2(passcount), datalen) == EOF) {
						return -1;
					}
					n += datalen;
					passcount = 1;
				} else {
					++passcount;
				}

----------------------------------------------------------------------------------
	if (cp->tcp.csty & JPC_COD_EPH) {
		if (!(ms = jpc_ms_create(JPC_MS_EPH))) {
			return -1;
		}
		if (jpc_putms(out, enc->cstate, ms)) {
			return -1;
		}
		jpc_ms_destroy(ms);
	}

----------------------------------------------------------------------------------
		if (!band->data) {
			continue;
		}

----------------------------------------------------------------------------------
		if (!prc->cblks) {
			continue;
		}

----------------------------------------------------------------------------------
			if (!pass) {
				continue;
			}

----------------------------------------------------------------------------------
			if (pass->lyrno != lyrno) {
				assert(pass->lyrno < 0 || pass->lyrno > lyrno);
				continue;
			}

----------------------------------------------------------------------------------
			if (jas_stream_copy(out, cblk->stream, lastpass->end -
			  startpass->start)) {
				return -1;
			}

----------------------------------------------------------------------------------
			if (!lvl->bands) {
				continue;

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;

----------------------------------------------------------------------------------
			if (!lvl->bands) {
				continue;

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;

----------------------------------------------------------------------------------
			if (!lvl->bands) {
				continue;

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;

----------------------------------------------------------------------------------
						if (jas_stream_rewind(cblk->stream)) {
							assert(0);

----------------------------------------------------------------------------------
						if (raflag) {
							endpasses = &cblk->passes[cblk->numpasses];

----------------------------------------------------------------------------------
	if (!(pi = jpc_pi_create0())) {
		return 0;

----------------------------------------------------------------------------------
	if (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {
		jpc_pi_destroy(pi);

----------------------------------------------------------------------------------
		if (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,
		  sizeof(jpc_pirlvl_t)))) {

----------------------------------------------------------------------------------
			if (rlvl->numprcs) {
				if (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,
				  sizeof(long)))) {
					jpc_pi_destroy(pi);
					return 0;

----------------------------------------------------------------------------------
		if (pi->maxrlvls < tcomp->numrlvls) {
			pi->maxrlvls = tcomp->numrlvls;

----------------------------------------------------------------------------------
	if (!((areg) & 0x8000)) { \
		if ((areg) < state->qeval) { \
			(areg) = state->qeval; \
		} else { \
			(creg) += state->qeval; \
		} \
		*(curctx) = state->nmps; \
		jpc_mqenc_renorme((areg), (creg), (ctreg), (enc)); \
	} else { \
		(creg) += state->qeval; \
	} \

----------------------------------------------------------------------------------
	if ((areg) < state->qeval) { \
		(creg) += state->qeval; \
	} else { \
		(areg) = state->qeval; \
	} \

----------------------------------------------------------------------------------
		if (!--(ctreg)) { \
			jpc_mqenc_byteout((areg), (creg), (ctreg), (enc)); \
		} \

----------------------------------------------------------------------------------
	if ((enc)->outbuf != 0xff) { \
		if ((creg) & 0x8000000) { \
			if (++((enc)->outbuf) == 0xff) { \
				(creg) &= 0x7ffffff; \
				jpc_mqenc_byteout2(enc); \
				enc->outbuf = ((creg) >> 20) & 0xff; \
				(creg) &= 0xfffff; \
				(ctreg) = 7; \
			} else { \
				jpc_mqenc_byteout2(enc); \
				enc->outbuf = ((creg) >> 19) & 0xff; \
				(creg) &= 0x7ffff; \
				(ctreg) = 8; \
			} \
		} else { \
			jpc_mqenc_byteout2(enc); \
			(enc)->outbuf = ((creg) >> 19) & 0xff; \
			(creg) &= 0x7ffff; \
			(ctreg) = 8; \
		} \
	} else { \
		jpc_mqenc_byteout2(enc); \
		(enc)->outbuf = ((creg) >> 20) & 0xff; \
		(creg) &= 0xfffff; \
		(ctreg) = 7; \
	} \

----------------------------------------------------------------------------------
	if (enc->outbuf >= 0) { \
		if (jas_stream_putc(enc->out, (unsigned char)enc->outbuf) == EOF) { \
			enc->err |= 1; \
		} \
	} \

----------------------------------------------------------------------------------
	if (!(mqenc = jas_malloc(sizeof(jpc_mqenc_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(mqenc->ctxs = jas_alloc2(mqenc->maxctxs, sizeof(jpc_mqstate_t *)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (mqenc) {
		jpc_mqenc_destroy(mqenc);
	}

----------------------------------------------------------------------------------
	if (mqenc->ctxs) {
		jas_free(mqenc->ctxs);
	}

----------------------------------------------------------------------------------
	if (state->mps == bit) {
		/* Apply the CODEMPS algorithm as defined in the standard. */
		mqenc->areg -= state->qeval;
		if (!(mqenc->areg & 0x8000)) {
			jpc_mqenc_codemps2(mqenc);
		} else {
			mqenc->creg += state->qeval;
		}
	} else {
		/* Apply the CODELPS algorithm as defined in the standard. */
		jpc_mqenc_codelps2(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc->curctx, mqenc);
	}

----------------------------------------------------------------------------------
	if (mqenc->areg < state->qeval) {
		mqenc->areg = state->qeval;
	} else {
		mqenc->creg += state->qeval;
	}

----------------------------------------------------------------------------------
	switch (termmode) {
	case JPC_MQENC_PTERM:
		k = 11 - mqenc->ctreg + 1;
		while (k > 0) {
			mqenc->creg <<= mqenc->ctreg;
			mqenc->ctreg = 0;
			jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg,
			  mqenc);
			k -= mqenc->ctreg;
		}
		if (mqenc->outbuf != 0xff) {
			jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc);
		}
		break;
	case JPC_MQENC_DEFTERM:
		jpc_mqenc_setbits(mqenc);
		mqenc->creg <<= mqenc->ctreg;
		jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc);
		mqenc->creg <<= mqenc->ctreg;
		jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc);
		if (mqenc->outbuf != 0xff) {
			jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc);
		}
		break;
	default:
		abort();
		break;
	}

----------------------------------------------------------------------------------
	if (mqenc->creg >= tmp) {
		mqenc->creg -= 0x8000;
	}

----------------------------------------------------------------------------------
	if (!(bitstream = jpc_bitstream_alloc())) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (jpc_bitstream_align(bitstream)) {
		ret = -1;
	}

----------------------------------------------------------------------------------
	if (!(bitstream->flags_ & JPC_BITSTREAM_NOCLOSE) && bitstream->stream_) {
		if (jas_stream_close(bitstream->stream_)) {
			ret = -1;
		}
		bitstream->stream_ = 0;
	}

----------------------------------------------------------------------------------
	if (!(bitstream = jas_malloc(sizeof(jpc_bitstream_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (n < 0 || n >= 32) {
		return -1;
	}

----------------------------------------------------------------------------------
		if ((u = jpc_bitstream_getbit(bitstream)) < 0) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (n < 0 || n >= 32) {
		return EOF;
	}

----------------------------------------------------------------------------------
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}

----------------------------------------------------------------------------------
	if (bitstream->flags_ & JPC_BITSTREAM_ERR) {
		bitstream->cnt_ = 0;
		return -1;
	}

----------------------------------------------------------------------------------
	if (bitstream->flags_ & JPC_BITSTREAM_EOF) {
		bitstream->buf_ = 0x7f;
		bitstream->cnt_ = 7;
		return 1;
	}

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc((bitstream)->stream_)) == EOF) {
		bitstream->flags_ |= JPC_BITSTREAM_EOF;
		return 1;
	}

----------------------------------------------------------------------------------
	if (bitstream->openmode_ & JPC_BITSTREAM_READ) {
		/* The bit stream is open for reading. */
		/* If there are any bits buffered for reading, or the
		  previous byte forced a stuffed bit, alignment is
		  required. */
		if ((bitstream->cnt_ < 8 && bitstream->cnt_ > 0) ||
		  ((bitstream->buf_ >> 8) & 0xff) == 0xff) {
			return 1;
		}
	} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {
		/* The bit stream is open for writing. */
		/* If there are any bits buffered for writing, or the
		  previous byte forced a stuffed bit, alignment is
		  required. */
		if ((bitstream->cnt_ < 8 && bitstream->cnt_ >= 0) ||
		  ((bitstream->buf_ >> 8) & 0xff) == 0xff) {
			return 1;
		}
	} else {
		/* This should not happen.  Famous last words, eh? :-) */
		assert(0);
		return -1;
	}

----------------------------------------------------------------------------------
	if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {
		/* The bit stream is being used for writing. */
#if 1
		/* XXX - Is this really correct?  Check someday... */
		if (bitstream->cnt_ < 8) {
			return 1;
		}
#else
		if (bitstream->cnt_ < 8) {
			if (((bitstream->buf_ >> 8) & 0xff) == 0xff) {
				return 2;
			}
			return 1;
		}
#endif
		return 0;
	} else {
		/* This operation should not be invoked on a bit stream that
		  is being used for reading. */
		return -1;
	}

----------------------------------------------------------------------------------
	if (bitstream->openmode_ & JPC_BITSTREAM_READ) {
		ret = jpc_bitstream_inalign(bitstream, 0, 0);
	} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {
		ret = jpc_bitstream_outalign(bitstream, 0);
	} else {
		abort();
	}

----------------------------------------------------------------------------------
	if (bitstream->cnt_ > 0) {
		n = bitstream->cnt_;
	} else if (!bitstream->cnt_) {
		n = ((bitstream->buf_ & 0xff) == 0xff) ? 7 : 0;
	} else {
		n = 0;
	}

----------------------------------------------------------------------------------
	if (n > 0) {
		if ((u = jpc_bitstream_getbits(bitstream, n)) < 0) {
			return -1;
		}
		m += n;
		v = (v << n) | u;
	}

----------------------------------------------------------------------------------
	if ((bitstream->buf_ & 0xff) == 0xff) {
		if ((u = jpc_bitstream_getbits(bitstream, 7)) < 0) {
			return -1;
		}
		v = (v << 7) | u;
		m += 7;
	}

----------------------------------------------------------------------------------
	if (m > numfill) {
		v >>= m - numfill;
	} else {
		filldata >>= numfill - m;
		fillmask >>= numfill - m;
	}

----------------------------------------------------------------------------------
	if (((~(v ^ filldata)) & fillmask) != fillmask) {
		/* The actual fill pattern does not match the expected one. */
		return 1;
	}

----------------------------------------------------------------------------------
	if (!bitstream->cnt_) {
		if ((bitstream->buf_ & 0xff) == 0xff) {
			n = 7;
			v = filldata;
		} else {
			n = 0;
			v = 0;
		}
	} else if (bitstream->cnt_ > 0 && bitstream->cnt_ < 8) {
		n = bitstream->cnt_;
		v = filldata >> (7 - n);
	} else {
		n = 0;
		v = 0;
		return 0;
	}

----------------------------------------------------------------------------------
	if (n > 0) {
		if (jpc_bitstream_putbits(bitstream, n, v)) {
			return -1;
		}
	}

----------------------------------------------------------------------------------
	if (bitstream->cnt_ < 8) {
		assert(bitstream->cnt_ >= 0 && bitstream->cnt_ < 8);
		assert((bitstream->buf_ & 0xff) != 0xff);
		/* Force the pending byte of output to be written to the
		  underlying (character) stream. */
		if (jas_stream_putc(bitstream->stream_, bitstream->buf_ & 0xff) == EOF) {
			return -1;
		}
		bitstream->cnt_ = 8;
		bitstream->buf_ = (bitstream->buf_ << 8) & 0xffff;
	}

----------------------------------------------------------------------------------
		if (!pi->pchg) {
			++pi->pchgno;
			pi->compno = 0;
			pi->rlvlno = 0;
			pi->prcno = 0;
			pi->lyrno = 0;
			pi->prgvolfirst = true;
			if (pi->pchgno < jpc_pchglist_numpchgs(pi->pchglist)) {
				pi->pchg = jpc_pchglist_get(pi->pchglist, pi->pchgno);
			} else if (pi->pchgno == jpc_pchglist_numpchgs(pi->pchglist)) {
				pi->pchg = &pi->defaultpchg;
			} else {
				return 1;
			}
		}

----------------------------------------------------------------------------------
		switch (pchg->prgord) {
		case JPC_COD_LRCPPRG:
			ret = jpc_pi_nextlrcp(pi);
			break;
		case JPC_COD_RLCPPRG:
			ret = jpc_pi_nextrlcp(pi);
			break;
		case JPC_COD_RPCLPRG:
			ret = jpc_pi_nextrpcl(pi);
			break;
		case JPC_COD_PCRLPRG:
			ret = jpc_pi_nextpcrl(pi);
			break;
		case JPC_COD_CPRLPRG:
			ret = jpc_pi_nextcprl(pi);
			break;
		default:
			ret = -1;
			break;
		}

----------------------------------------------------------------------------------
		if (!ret) {
			pi->valid = true;
			++pi->pktno;
			return 0;
		}

----------------------------------------------------------------------------------
	if (!pi->prgvolfirst) {
		prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
		goto skip;
	} else {
		pi->prgvolfirst = false;
	}

----------------------------------------------------------------------------------
				if (pi->rlvlno >= pi->picomp->numrlvls) {
					continue;
				}

----------------------------------------------------------------------------------
					if (pi->lyrno >= *prclyrno) {
						*prclyrno = pi->lyrno;
						++(*prclyrno);
						return 0;
					}

----------------------------------------------------------------------------------
	if (!pi->prgvolfirst) {
		assert(pi->prcno < pi->pirlvl->numprcs);
		prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
		goto skip;
	} else {
		pi->prgvolfirst = 0;
	}

----------------------------------------------------------------------------------
				if (pi->rlvlno >= pi->picomp->numrlvls) {
					continue;
				}

----------------------------------------------------------------------------------
					if (pi->lyrno >= *prclyrno) {
						*prclyrno = pi->lyrno;
						++(*prclyrno);
						return 0;
					}

----------------------------------------------------------------------------------
	if (!pi->prgvolfirst) {
		goto skip;
	} else {
		pi->xstep = 0;
		pi->ystep = 0;
		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps;
		  ++compno, ++picomp) {
			for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <
			  picomp->numrlvls; ++rlvlno, ++pirlvl) {
				// Check for the potential for overflow problems.
				if (pirlvl->prcwidthexpn + picomp->numrlvls >
				  JAS_UINTFAST32_NUMBITS - 2 ||
				  pirlvl->prcheightexpn + picomp->numrlvls >
				  JAS_UINTFAST32_NUMBITS - 2) {
					return -1;
				}
				xstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
				  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));
				ystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
				  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));
				pi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);
				pi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);
			}
		}
		pi->prgvolfirst = 0;
	}

----------------------------------------------------------------------------------
					if (pi->rlvlno >= pi->picomp->numrlvls) {
						continue;
					}

----------------------------------------------------------------------------------
					if (pi->pirlvl->numprcs == 0) {
						continue;
					}

----------------------------------------------------------------------------------
					if (((pi->x == pi->xstart &&
					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))
					  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&
					  ((pi->y == pi->ystart &&
					  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))
					  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {
						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,
						  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -
						  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);

----------------------------------------------------------------------------------
							if (pi->lyrno >= *prclyrno) {
								++(*prclyrno);

----------------------------------------------------------------------------------
	if (!pi->prgvolfirst) {
		goto skip;

----------------------------------------------------------------------------------
				if (pirlvl->prcwidthexpn + picomp->numrlvls >
				  JAS_UINTFAST32_NUMBITS - 2 ||

----------------------------------------------------------------------------------
					if (pi->pirlvl->numprcs == 0) {
						continue;
					}

----------------------------------------------------------------------------------
					if (((pi->x == pi->xstart &&
					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||

----------------------------------------------------------------------------------
							if (pi->lyrno >= *prclyrno) {
								++(*prclyrno);
								return 0;

----------------------------------------------------------------------------------
	if (!pi->prgvolfirst) {
		goto skip;

----------------------------------------------------------------------------------
		if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
		  JAS_UINTFAST32_NUMBITS - 2 ||

----------------------------------------------------------------------------------
					if (pi->pirlvl->numprcs == 0) {
						continue;
					}

----------------------------------------------------------------------------------
					if (((pi->x == pi->xstart &&
					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||

----------------------------------------------------------------------------------
							if (pi->lyrno >= *prclyrno) {
								++(*prclyrno);
								return 0;

----------------------------------------------------------------------------------
	if (rlvl->prclyrnos) {
		jas_free(rlvl->prclyrnos);

----------------------------------------------------------------------------------
	if (picomp->pirlvls) {
		for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <

----------------------------------------------------------------------------------
	if (pi->picomps) {
		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps;
		  ++compno, ++picomp) {
			jpc_picomp_destroy(picomp);
		}
		jas_free(pi->picomps);

----------------------------------------------------------------------------------
	if (pi->pchglist) {
		jpc_pchglist_destroy(pi->pchglist);

----------------------------------------------------------------------------------
	if (!(pi = jas_malloc(sizeof(jpc_pi_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (!(pi->pchglist = jpc_pchglist_create())) {
		jas_free(pi);

----------------------------------------------------------------------------------
	if (!(pchglist = jas_malloc(sizeof(jpc_pchglist_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (pchgno < 0) {
		pchgno = pchglist->numpchgs;

----------------------------------------------------------------------------------
	if (pchglist->numpchgs >= pchglist->maxpchgs) {
		newmaxpchgs = pchglist->maxpchgs + 128;

----------------------------------------------------------------------------------
		if (!(newpchgs = jas_realloc2(pchglist->pchgs, newmaxpchgs,
		  sizeof(jpc_pchg_t *)))) {

----------------------------------------------------------------------------------
	if (!(newpchg = jas_malloc(sizeof(jpc_pchg_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(newpchglist = jpc_pchglist_create())) {
		return 0;

----------------------------------------------------------------------------------
		if (!(newpchg = jpc_pchg_copy(pchglist->pchgs[pchgno])) ||
		  jpc_pchglist_insert(newpchglist, -1, newpchg)) {

----------------------------------------------------------------------------------
	if (pchglist->pchgs) {
		for (pchgno = 0; pchgno < pchglist->numpchgs; ++pchgno) {
			jpc_pchg_destroy(pchglist->pchgs[pchgno]);
		}
		jas_free(pchglist->pchgs);

----------------------------------------------------------------------------------
	if (!(mqdec = jas_malloc(sizeof(jpc_mqdec_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(mqdec->ctxs = jas_alloc2(mqdec->maxctxs, sizeof(jpc_mqstate_t *)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (mqdec->in) {
		jpc_mqdec_init(mqdec);
	}

----------------------------------------------------------------------------------
	if (mqdec) {
		jpc_mqdec_destroy(mqdec);
	}

----------------------------------------------------------------------------------
	if (mqdec->ctxs) {
		jas_free(mqdec->ctxs);
	}

----------------------------------------------------------------------------------
	if ((c = jas_stream_getc(mqdec->in)) == EOF) {
		/* We have encountered an I/O error or EOF. */
		c = 0xff;
		mqdec->eof = 1;
	}

----------------------------------------------------------------------------------
	if (!mqdec->eof) {
		if ((c = jas_stream_getc(mqdec->in)) == EOF) {
			mqdec->eof = 1;
			c = 0xff;
		}
		prevbuf = mqdec->inbuffer;
		mqdec->inbuffer = c;
		if (prevbuf == 0xff) {
			if (c > 0x8f) {
				mqdec->creg += 0xff00;
				mqdec->ctreg = 8;
			} else {
				mqdec->creg += c << 9;
				mqdec->ctreg = 7;
			}
		} else {
			mqdec->creg += c << 8;
			mqdec->ctreg = 8;
		}
	} else {
		mqdec->creg += 0xff00;
		mqdec->ctreg = 8;
	}

----------------------------------------------------------------------------------
	if (!(tree = jpc_tagtree_alloc())) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (!(tree->nodes_ = jas_alloc2(tree->numnodes_, sizeof(jpc_tagtreenode_t)))) {
		jpc_tagtree_destroy(tree);
		return 0;
	}

----------------------------------------------------------------------------------
				if (--k >= 0) {
					node->parent_ = parentnode;
					++node;
				}

----------------------------------------------------------------------------------
			if ((j & 1) || j == nplv[i] - 1) {
				parentnode0 = parentnode;
			} else {
				parentnode = parentnode0;
				parentnode0 += nplh[i];
			}

----------------------------------------------------------------------------------
	if (tree->nodes_) {
		jas_free(tree->nodes_);
	}

----------------------------------------------------------------------------------
	if (!(tree = jas_malloc(sizeof(jpc_tagtree_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
		if (low > node->low_) {
			/* Deferred propagation of the lower bound downward in
			  the tree. */
			node->low_ = low;
		} else {
			low = node->low_;
		}

----------------------------------------------------------------------------------
			if (low >= node->value_) {
				if (!node->known_) {
					if (jpc_bitstream_putbit(out, 1) == EOF) {
						return -1;
					}
					node->known_ = 1;
				}
				break;
			}

----------------------------------------------------------------------------------
			if (jpc_bitstream_putbit(out, 0) == EOF) {
				return -1;
			}

----------------------------------------------------------------------------------
		if (stkptr == stk) {
			break;
		}

----------------------------------------------------------------------------------
		if (low > node->low_) {
			node->low_ = low;
		} else {
			low = node->low_;
		}

----------------------------------------------------------------------------------
			if ((ret = jpc_bitstream_getbit(in)) < 0) {
				return -1;
			}

----------------------------------------------------------------------------------
			if (ret) {
				node->value_ = low;
			} else {
				++low;
			}

----------------------------------------------------------------------------------
		if (stkptr == stk) {
			break;
		}

----------------------------------------------------------------------------------
		if ((v = jpc_bitstream_getbit(in)) < 0) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (jpc_bitstream_eof(in)) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (!v) {
			break;
		}

----------------------------------------------------------------------------------
	if ((n = jpc_bitstream_getbit(in)) > 0) {
		if ((n = jpc_bitstream_getbit(in)) > 0) {
			if ((n = jpc_bitstream_getbits(in, 2)) == 3) {
				if ((n = jpc_bitstream_getbits(in, 5)) == 31) {
					if ((n = jpc_bitstream_getbits(in, 7)) >= 0) {
						n += 36 + 1;
					}
				} else if (n >= 0) {
					n += 5 + 1;
				}
			} else if (n >= 0) {
				n += 2 + 1;
			}
		} else if (!n) {
			n += 2;
		}
	} else if (!n) {
		++n;
	}

----------------------------------------------------------------------------------
	if (cp->csty & JPC_COD_SOP) {
		if (jpc_dec_lookahead(in) == JPC_MS_SOP) {
			if (!(ms = jpc_getms(in, dec->cstate))) {
				return -1;
			}
			if (jpc_ms_gettype(ms) != JPC_MS_SOP) {
				jpc_ms_destroy(ms);
				jas_eprintf("missing SOP marker segment\n");
				return -1;
			}
			jpc_ms_destroy(ms);
		}
	}

----------------------------------------------------------------------------------
	if (!(inb = jpc_bitstream_sopen(pkthdrstream, "r"))) {
		return -1;
	}

----------------------------------------------------------------------------------
	if ((present = jpc_bitstream_getbit(inb)) < 0) {
		return 1;
	}

----------------------------------------------------------------------------------
	if (present) {
		/* The packet is non-empty. */
		tcomp = &tile->tcomps[compno];
		rlvl = &tcomp->rlvls[rlvlno];
		bodylen = 0;
		for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;
		  ++bandno, ++band) {
			if (!band->data) {
				continue;
			}
			prc = &band->prcs[prcno];
			if (!prc->cblks) {
				continue;
			}
			usedcblkcnt = 0;
			for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;
			  ++cblkno, ++cblk) {
				++usedcblkcnt;
				if (!cblk->numpasses) {
					leaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);
					if ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {
						return -1;
					}
				} else {
					if ((included = jpc_bitstream_getbit(inb)) < 0) {
						return -1;
					}
				}
				JAS_DBGLOG(10, ("\n"));
				JAS_DBGLOG(10, ("included=%d ", included));
				if (!included) {
					continue;
				}
				if (!cblk->numpasses) {
					i = 1;
					leaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);
					for (;;) {
						if ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {
							return -1;
						}
						if (ret) {
							break;
						}
						++i;
					}
					cblk->numimsbs = i - 1;
					cblk->firstpassno = cblk->numimsbs * 3;
				}
				if ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {
					return -1;
				}
				JAS_DBGLOG(10, ("numnewpasses=%d ", numnewpasses));
				seg = cblk->curseg;
				savenumnewpasses = numnewpasses;
				mycounter = 0;
				if (numnewpasses > 0) {
					if ((m = jpc_getcommacode(inb)) < 0) {
						return -1;
					}
					cblk->numlenbits += m;
					JAS_DBGLOG(10, ("increment=%d ", m));
					while (numnewpasses > 0) {
						passno = cblk->firstpassno + cblk->numpasses + mycounter;
	/* XXX - the maxpasses is not set precisely but this doesn't matter... */
						maxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);
						if (!discard && !seg) {
							if (!(seg = jpc_seg_alloc())) {
								return -1;
							}
							jpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);
							if (!cblk->curseg) {
								cblk->curseg = seg;
							}
							seg->passno = passno;
							seg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);
							seg->maxpasses = maxpasses;
						}
						n = JAS_MIN(numnewpasses, maxpasses);
						mycounter += n;
						numnewpasses -= n;
						if ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {
							return -1;
						}
						JAS_DBGLOG(10, ("len=%d ", len));
						if (!discard) {
							seg->lyrno = lyrno;
							seg->numpasses += n;
							seg->cnt = len;
							seg = seg->next;
						}
						bodylen += len;
					}
				}
				cblk->numpasses += savenumnewpasses;
			}
		}

		jpc_bitstream_inalign(inb, 0, 0);

	} else {
		if (jpc_bitstream_inalign(inb, 0x7f, 0)) {
			jas_eprintf("alignment failed\n");
			return -1;
		}
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 5) {
		jas_eprintf("hdrlen=%lu bodylen=%lu \n", (unsigned long) hdrlen,
		  (unsigned long) bodylen);
	}

----------------------------------------------------------------------------------
	if (cp->csty & JPC_COD_EPH) {
		if (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {
			if (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {
				jas_eprintf("cannot get (EPH) marker segment\n");
				return -1;
			}
			if (jpc_ms_gettype(ms) != JPC_MS_EPH) {
				jpc_ms_destroy(ms);
				jas_eprintf("missing EPH marker segment\n");
				return -1;
			}
			jpc_ms_destroy(ms);
		}
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 1) {
		jas_eprintf("packet body offset=%06ld\n", (long) jas_stream_getrwcount(in));
	}

----------------------------------------------------------------------------------
	if (!discard) {
		tcomp = &tile->tcomps[compno];
		rlvl = &tcomp->rlvls[rlvlno];
		for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;
		  ++bandno, ++band) {
			if (!band->data) {
				continue;
			}
			prc = &band->prcs[prcno];
			if (!prc->cblks) {
				continue;
			}
			for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;
			  ++cblkno, ++cblk) {
				seg = cblk->curseg;
				while (seg) {
					if (!seg->stream) {
						if (!(seg->stream = jas_stream_memopen(0, 0))) {
							return -1;
						}
					}
#if 0
jas_eprintf("lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\n", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);
#endif
					if (seg->cnt > 0) {
						if (jpc_getdata(in, seg->stream, seg->cnt) < 0) {
							return -1;
						}
						seg->cnt = 0;
					}
					if (seg->numpasses >= seg->maxpasses) {
						cblk->curseg = seg->next;
					}
					seg = seg->next;
				}
			}
		}
	} else {
		if (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {
			return -1;
		}
	}

----------------------------------------------------------------------------------
		if (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {
			switch (jpc_dec_lookahead(in)) {
			case JPC_MS_EOC:
			case JPC_MS_SOT:
				return 0;
				break;
			case JPC_MS_SOP:
			case JPC_MS_EPH:
			case 0:
				break;
			default:
				return -1;
				break;
			}
		}

----------------------------------------------------------------------------------
		if ((ret = jpc_pi_next(pi))) {
			return ret;
		}

----------------------------------------------------------------------------------
		if (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {
			jas_eprintf("warning: stopping decode prematurely as requested\n");
			return 0;
		}

----------------------------------------------------------------------------------
		if (jas_getdbglevel() >= 1) {
			jas_eprintf("packet offset=%08ld prg=%d cmptno=%02d "
			  "rlvlno=%02d prcno=%03d lyrno=%02d\n", (long)
			  jas_stream_getrwcount(in), jpc_pi_prg(pi), jpc_pi_cmptno(pi),
			  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi));
		}

----------------------------------------------------------------------------------
		if (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi),
		  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {
			return -1;
		}

----------------------------------------------------------------------------------
	if (!(pi = jpc_pi_create0())) {
		return 0;

----------------------------------------------------------------------------------
	if (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {
		jpc_pi_destroy(pi);

----------------------------------------------------------------------------------
		if (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,
		  sizeof(jpc_pirlvl_t)))) {

----------------------------------------------------------------------------------
			if (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,
			  sizeof(long)))) {
				jpc_pi_destroy(pi);
				return 0;

----------------------------------------------------------------------------------
		if (pi->maxrlvls < tcomp->numrlvls) {
			pi->maxrlvls = tcomp->numrlvls;

----------------------------------------------------------------------------------
	if (jpc_getuint16(in, &x)) {
		return -1;

----------------------------------------------------------------------------------
	if (jas_stream_ungetc(in, x & 0xff) == EOF ||
	  jas_stream_ungetc(in, x >> 8) == EOF) {

----------------------------------------------------------------------------------
	if (x >= JPC_MS_INMIN && x <= JPC_MS_INMAX) {
		return x;
	}

----------------------------------------------------------------------------------
	if (absdelta < 0) {
		abort();
	}

----------------------------------------------------------------------------------
	if (scaleexpn < p) {
		abort();
	}

----------------------------------------------------------------------------------
	if (!(cp = cp_create(optstr, image))) {
		jas_eprintf("invalid JP encoder options\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(enc = jpc_enc_create(cp, out, image))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jpc_enc_encodemainhdr(enc)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jpc_enc_encodemainbody(enc)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_EOC))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		jas_eprintf("cannot write EOI marker\n");
		goto error;
	}

----------------------------------------------------------------------------------
	if (jas_stream_flush(enc->out)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (cp) {
		jpc_enc_cp_destroy(cp);
	}

----------------------------------------------------------------------------------
	if (enc) {
		jpc_enc_destroy(enc);
	}

----------------------------------------------------------------------------------
	if (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=
		  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +
		  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {
			jas_eprintf("unsupported image type\n");
			goto error;

----------------------------------------------------------------------------------
	if (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {
		goto error;

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		goto error;

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_DEBUG:
			cp->debug = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_IMGAREAOFFX:
			cp->imgareatlx = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_IMGAREAOFFY:
			cp->imgareatly = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEGRDOFFX:
			cp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEGRDOFFY:
			cp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEWIDTH:
			cp->tilewidth = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEHEIGHT:
			cp->tileheight = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_PRCWIDTH:
			prcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_PRCHEIGHT:
			prcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_CBLKWIDTH:
			tccp->cblkwidthexpn =
			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_CBLKHEIGHT:
			tccp->cblkheightexpn =
			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_MODE:
			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,
			  jas_tvparser_getval(tvp)))->id) < 0) {
				jas_eprintf("ignoring invalid mode %s\n",
				  jas_tvparser_getval(tvp));
			} else {
				tcp->intmode = (tagid == MODE_INT);
			}
			break;
		case OPT_PRG:
			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,
			  jas_tvparser_getval(tvp)))->id) < 0) {
				jas_eprintf("ignoring invalid progression order %s\n",
				  jas_tvparser_getval(tvp));
			} else {
				tcp->prg = tagid;
			}
			break;
		case OPT_NOMCT:
			enablemct = false;
			break;
		case OPT_MAXRLVLS:
			tccp->maxrlvls = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_SOP:
			cp->tcp.csty |= JPC_COD_SOP;
			break;
		case OPT_EPH:
			cp->tcp.csty |= JPC_COD_EPH;
			break;
		case OPT_LAZY:
			tccp->cblksty |= JPC_COX_LAZY;
			break;
		case OPT_TERMALL:
			tccp->cblksty |= JPC_COX_TERMALL;
			break;
		case OPT_SEGSYM:
			tccp->cblksty |= JPC_COX_SEGSYM;
			break;
		case OPT_VCAUSAL:
			tccp->cblksty |= JPC_COX_VSC;
			break;
		case OPT_RESET:
			tccp->cblksty |= JPC_COX_RESET;
			break;
		case OPT_PTERM:
			tccp->cblksty |= JPC_COX_PTERM;
			break;
		case OPT_NUMGBITS:
			cp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_RATE:
			if (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,
			  &cp->totalsize)) {
				jas_eprintf("ignoring bad rate specifier %s\n",
				  jas_tvparser_getval(tvp));
			}
			break;
		case OPT_ILYRRATES:
			if (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,
			  &ilyrrates)) {
				jas_eprintf("warning: invalid intermediate layer rates specifier ignored (%s)\n",
				  jas_tvparser_getval(tvp));
			}
			break;

		case OPT_JP2OVERHEAD:
			jp2overhead = atoi(jas_tvparser_getval(tvp));
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			 jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (cp->totalsize != UINT_FAST32_MAX) {
		cp->totalsize = (cp->totalsize > jp2overhead) ?

----------------------------------------------------------------------------------
	if (cp->imgareatlx == UINT_FAST32_MAX) {
		cp->imgareatlx = 0;

----------------------------------------------------------------------------------
		if (hsteplcm != 1) {
			jas_eprintf("warning: overriding imgareatlx value\n");

----------------------------------------------------------------------------------
	if (cp->imgareatly == UINT_FAST32_MAX) {
		cp->imgareatly = 0;

----------------------------------------------------------------------------------
		if (vsteplcm != 1) {
			jas_eprintf("warning: overriding imgareatly value\n");

----------------------------------------------------------------------------------
	if (cp->tilegrdoffx == UINT_FAST32_MAX) {
		cp->tilegrdoffx = cp->imgareatlx;

----------------------------------------------------------------------------------
	if (cp->tilegrdoffy == UINT_FAST32_MAX) {
		cp->tilegrdoffy = cp->imgareatly;

----------------------------------------------------------------------------------
	if (!cp->tilewidth) {
		cp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;

----------------------------------------------------------------------------------
	if (!cp->tileheight) {
		cp->tileheight = cp->refgrdheight - cp->tilegrdoffy;

----------------------------------------------------------------------------------
	if (cp->numcmpts == 3) {
		mctvalid = true;

----------------------------------------------------------------------------------
			if (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||
			  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||

----------------------------------------------------------------------------------
	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {
		jas_eprintf("warning: color space apparently not RGB\n");
	}

----------------------------------------------------------------------------------
	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {
		tcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);

----------------------------------------------------------------------------------
	if (prcwidthexpn != 15 || prcheightexpn != 15) {
		tccp->csty |= JPC_COX_PRT;

----------------------------------------------------------------------------------
	if (!cp->tilewidth) {
		jas_eprintf("invalid tile width %lu\n", (unsigned long)

----------------------------------------------------------------------------------
	if (!cp->tileheight) {
		jas_eprintf("invalid tile height %lu\n", (unsigned long)
		  cp->tileheight);
		goto error;

----------------------------------------------------------------------------------
	if (cp->tilegrdoffx > cp->imgareatlx ||
	  cp->tilegrdoffy > cp->imgareatly ||

----------------------------------------------------------------------------------
	if (ilyrrates && numilyrrates > 0) {
		tcp->numlyrs = numilyrrates + 1;
		if (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),

----------------------------------------------------------------------------------
	if (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {
		jas_eprintf("cannot use real mode for lossless coding\n");
		goto error;

----------------------------------------------------------------------------------
	if (prcwidthexpn > 15) {
		jas_eprintf("invalid precinct width\n");

----------------------------------------------------------------------------------
	if (prcheightexpn > 15) {
		jas_eprintf("invalid precinct height\n");

----------------------------------------------------------------------------------
	if (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {
		jas_eprintf("invalid code block width %d\n",

----------------------------------------------------------------------------------
	if (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {
		jas_eprintf("invalid code block height %d\n",
		  JPC_POW2(cp->tccp.cblkheightexpn));
		goto error;

----------------------------------------------------------------------------------
	if (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {
		jas_eprintf("code block size too large\n");

----------------------------------------------------------------------------------
	if (cp->tcp.numlyrs > 16384) {
		jas_eprintf("too many layers\n");

----------------------------------------------------------------------------------
	if (cp->tccp.maxrlvls < 1) {
		jas_eprintf("must be at least one resolution level\n");

----------------------------------------------------------------------------------
	if (cp->tccp.numgbits > 8) {
		jas_eprintf("invalid number of guard bits\n");

----------------------------------------------------------------------------------
	if (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {
		jas_eprintf("warning: specified rate is unreasonably large (%lu > %lu)\n", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);

----------------------------------------------------------------------------------
	if (tcp->numlyrs > 1) {
		/* The intermediate layers rates must increase monotonically. */

----------------------------------------------------------------------------------
			if (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {
				jas_eprintf("intermediate layer rates must increase monotonically\n");

----------------------------------------------------------------------------------
		if (cp->totalsize != UINT_FAST32_MAX) {
			for (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {

----------------------------------------------------------------------------------
				if (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)
				  / cp->rawsize) {
					jas_eprintf("warning: intermediate layer rates must be less than overall rate\n");
					goto error;

----------------------------------------------------------------------------------
	if (ilyrrates) {
		jas_free(ilyrrates);

----------------------------------------------------------------------------------
	if (ilyrrates) {
		jas_free(ilyrrates);

----------------------------------------------------------------------------------
	if (tvp) {
		jas_tvparser_destroy(tvp);

----------------------------------------------------------------------------------
	if (cp) {
		jpc_enc_cp_destroy(cp);

----------------------------------------------------------------------------------
	if (cp->ccps) {
		if (cp->tcp.ilyrrates) {

----------------------------------------------------------------------------------
	if (strchr(s, 'B')) {
		*size = atoi(s);
	} else {

----------------------------------------------------------------------------------
		if (f < 0) {
			*size = 0;
		} else if (f > 1.0) {

----------------------------------------------------------------------------------
	if (!(enc = jas_malloc(sizeof(jpc_enc_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(enc->cstate = jpc_cstate_create())) {
		goto error;

----------------------------------------------------------------------------------
	if (enc) {
		jpc_enc_destroy(enc);

----------------------------------------------------------------------------------
	if (enc->curtile) {
		jpc_enc_tile_destroy(enc->curtile);

----------------------------------------------------------------------------------
	if (enc->cp) {
		jpc_enc_cp_destroy(enc->cp);

----------------------------------------------------------------------------------
	if (enc->cstate) {
		jpc_cstate_destroy(enc->cstate);

----------------------------------------------------------------------------------
	if (enc->tmpstream) {
		jas_stream_close(enc->tmpstream);

----------------------------------------------------------------------------------
	if (n >= 11) {
		m = (stepsize >> (n - 11)) & 0x7ff;

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		jas_eprintf("cannot write SOC marker\n");

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		jas_eprintf("cannot write SIZ marker\n");

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {
		return -1;

----------------------------------------------------------------------------------
	if (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {
		abort();

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		jas_eprintf("cannot write COM marker\n");

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		jas_eprintf("cannot write CRG marker\n");

----------------------------------------------------------------------------------
			if (!tcp->intmode) {
				absstepsize = jpc_fix_div(jpc_inttofix(1 <<

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (tccp->csty & JPC_COX_PRT) {
		for (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		jas_eprintf("cannot write COD marker\n");
		return -1;

----------------------------------------------------------------------------------
	if (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {
		return -1;

----------------------------------------------------------------------------------
	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
		return -1;

----------------------------------------------------------------------------------
		if (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {
			return -1;

----------------------------------------------------------------------------------
		if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
			return -1;

----------------------------------------------------------------------------------
	if (enc->cp->totalsize != UINT_FAST32_MAX) {
		uint_fast32_t overhead;

----------------------------------------------------------------------------------
		if (!(enc->curtile = jpc_enc_tile_create(enc->cp, enc->image, tileno))) {
			abort();

----------------------------------------------------------------------------------
		if (jas_getdbglevel() >= 10) {
			jpc_enc_dump(enc);

----------------------------------------------------------------------------------
			if (!cp->ccps[cmptno].sgnd) {
				adjust = 1 << (cp->ccps[cmptno].prec - 1);

----------------------------------------------------------------------------------
		if (!tile->intmode) {
				endcomps = &tile->tcmpts[tile->numtcmpts];

----------------------------------------------------------------------------------
		switch (tile->mctid) {
		case JPC_MCT_RCT:
assert(jas_image_numcmpts(enc->image) == 3);
			jpc_rct(tile->tcmpts[0].data, tile->tcmpts[1].data,
			  tile->tcmpts[2].data);
			break;
		case JPC_MCT_ICT:
assert(jas_image_numcmpts(enc->image) == 3);
			jpc_ict(tile->tcmpts[0].data, tile->tcmpts[1].data,
			  tile->tcmpts[2].data);
			break;
		default:
			break;
		}

----------------------------------------------------------------------------------
				if (!lvl->bands) {
					absbandno += rlvlno ? 3 : 1;

----------------------------------------------------------------------------------
					if (!band->data) {
						++absbandno;

----------------------------------------------------------------------------------
							if (mag > mxmag) {
								mxmag = mag;

----------------------------------------------------------------------------------
					if (tile->intmode) {
						actualnumbps = jpc_firstone(mxmag) + 1;

----------------------------------------------------------------------------------
					if (numgbits > mingbits) {
						mingbits = numgbits;

----------------------------------------------------------------------------------
					if (!tile->intmode) {
						band->absstepsize = jpc_fix_div(jpc_inttofix(1

----------------------------------------------------------------------------------
					if ((!tile->intmode) && band->data) {
						jpc_quantize(band->data, band->absstepsize);
					}

----------------------------------------------------------------------------------
			if (!tile->intmode) {
				jas_matrix_divpow2(comp->data, JPC_FIX_FRACBITS - JPC_NUMEXTRABITS);

----------------------------------------------------------------------------------
			if (mingbits > cp->tccp.numgbits) {
				jas_eprintf("error: too few guard bits (need at least %d)\n",

----------------------------------------------------------------------------------
		if (!(enc->tmpstream = jas_stream_memopen(0, 0))) {
			jas_eprintf("cannot open tmp file\n");
			return -1;

----------------------------------------------------------------------------------
		if (!(enc->mrk = jpc_ms_create(JPC_MS_SOT))) {
			return -1;

----------------------------------------------------------------------------------
		if (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {
			jas_eprintf("cannot write SOT marker\n");

----------------------------------------------------------------------------------
			if (comp->numrlvls != tccp->maxrlvls) {
				if (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {

----------------------------------------------------------------------------------
				if (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {
					return -1;
				}

----------------------------------------------------------------------------------
			if (JAS_CAST(int, ccps->numstepsizes) == comp->numstepsizes) {
				samestepsizes = 1;

----------------------------------------------------------------------------------
					if (ccps->stepsizes[bandno] != comp->stepsizes[bandno]) {
						samestepsizes = 0;

----------------------------------------------------------------------------------
			if (!samestepsizes) {
				if (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {

----------------------------------------------------------------------------------
				if (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {
					return -1;
				}

----------------------------------------------------------------------------------
		if (!(enc->mrk = jpc_ms_create(JPC_MS_SOD))) {
			return -1;

----------------------------------------------------------------------------------
		if (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {
			jas_eprintf("cannot write SOD marker\n");

----------------------------------------------------------------------------------
		if (jpc_enc_enccblks(enc)) {
			abort();

----------------------------------------------------------------------------------
		if (cp->totalsize != UINT_FAST32_MAX) {
			tile->lyrsizes[tile->numlyrs - 1] = (rho * enc->mainbodysize);

----------------------------------------------------------------------------------
			if (tile->lyrsizes[lyrno] != UINT_FAST32_MAX) {
				if (JAS_CAST(uint_fast32_t, tilehdrlen) <= tile->lyrsizes[lyrno]) {

----------------------------------------------------------------------------------
		if (rateallocate(enc, tile->numlyrs, tile->lyrsizes)) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (jpc_enc_encodetiledata(enc)) {
			jas_eprintf("dotile failed\n");

----------------------------------------------------------------------------------
		if (jas_stream_seek(enc->tmpstream, 6, SEEK_SET) < 0) {
			return -1;

----------------------------------------------------------------------------------
		if (jas_stream_seek(enc->tmpstream, 0, SEEK_SET) < 0) {
			return -1;

----------------------------------------------------------------------------------
		if (jpc_putdata(enc->out, enc->tmpstream, -1)) {
			return -1;

----------------------------------------------------------------------------------
	if (jpc_enc_encpkts(enc, enc->tmpstream)) {
		return -1;

----------------------------------------------------------------------------------
	if (stepsize == jpc_inttofix(1)) {
		return;

----------------------------------------------------------------------------------
	if (t < 0) {
		t = jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));

----------------------------------------------------------------------------------
			if (pass0) {
				dd -= pass0->cumwmsedec;

----------------------------------------------------------------------------------
			if (dd <= 0) {
				pass1->rdslope = JPC_BADRDSLOPE;

----------------------------------------------------------------------------------
				if (pass1 >= pass2) {
					pass2 = &pass1[1];

----------------------------------------------------------------------------------
			if (pass1 < pass2 && pass1->rdslope <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (!dr) {
				assert(pass0);

----------------------------------------------------------------------------------
			if (pass0 && slope >= slope0) {
				pass0->rdslope = 0;

----------------------------------------------------------------------------------
			if (pass1 >= pass2) {
				pass2 = &pass1[1];

----------------------------------------------------------------------------------
if (pass0->rdslope > 0.0) {
		jas_eprintf("pass %02d nmsedec=%lf dec=%lf end=%d %lf\n", pass0 - cblk->passes,

----------------------------------------------------------------------------------
				if (!rlvl->bands) {
					continue;
				}

----------------------------------------------------------------------------------
					if (!band->data) {
						continue;

----------------------------------------------------------------------------------
						if (!prc->cblks) {
							continue;

----------------------------------------------------------------------------------
		if (cumlens[lyrno - 1] > cumlens[lyrno]) {
			abort();

----------------------------------------------------------------------------------
	if (!(out = jas_stream_memopen(0, 0))) {
		return -1;

----------------------------------------------------------------------------------
			if (!lvl->bands) {
				continue;

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;

----------------------------------------------------------------------------------
							if (pass->rdslope > 0) {
								if (pass->rdslope < mnrdslope) {

----------------------------------------------------------------------------------
								if (pass->rdslope > mxrdslope) {
									mxrdslope = pass->rdslope;
								}

----------------------------------------------------------------------------------
			if (cumlen == UINT_FAST32_MAX) {
				/* Only the last layer can be free of a rate

----------------------------------------------------------------------------------
					if (!lvl->bands) {
						continue;

----------------------------------------------------------------------------------
						if (!band->data) {
							continue;

----------------------------------------------------------------------------------
							if (!prc->cblks) {
								continue;

----------------------------------------------------------------------------------
								if (cblk->curpass) {
									endpasses = &cblk->passes[cblk->numpasses];

----------------------------------------------------------------------------------
										if (pass->rdslope >= thresh) {
											pass1 = &pass[1];

----------------------------------------------------------------------------------
					if (!lvl->bands) {
						continue;

----------------------------------------------------------------------------------
						if (jpc_enc_encpkt(enc, out, comp - tile->tcmpts,
						  lvl - comp->rlvls, prcno, lyrno)) {

----------------------------------------------------------------------------------
			if (pos > cumlen) {
				/* The rate is too high. */
				lo = thresh;

----------------------------------------------------------------------------------
				if (!success || thresh < goodthresh) {
					goodthresh = thresh;

----------------------------------------------------------------------------------
			if (jas_stream_seek(out, oldpos, SEEK_SET) < 0) {
				abort();

----------------------------------------------------------------------------------
		if (!success) {
			jas_eprintf("warning: empty layer generated\n");

----------------------------------------------------------------------------------
				if (!lvl->bands) {
					continue;

----------------------------------------------------------------------------------
					if (!band->data) {
						continue;

----------------------------------------------------------------------------------
						if (!prc->cblks) {
							continue;

----------------------------------------------------------------------------------
							if (cblk->curpass) {
								endpasses = &cblk->passes[cblk->numpasses];

----------------------------------------------------------------------------------
								if (success) {
									for (pass = cblk->curpass; pass !=

----------------------------------------------------------------------------------
										if (pass->rdslope >= goodthresh) {
											pass1 = &pass[1];
										}

----------------------------------------------------------------------------------
				if (!lvl->bands) {
					continue;

----------------------------------------------------------------------------------
					if (jpc_enc_encpkt(enc, out, comp - tile->tcmpts,
					  lvl - comp->rlvls, prcno, lyrno)) {

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 5) {
		dump_layeringinfo(enc);
	}

----------------------------------------------------------------------------------
	if (!(tile = jas_malloc(sizeof(jpc_enc_tile_t)))) {
		goto error;

----------------------------------------------------------------------------------
	if (!(tile->lyrsizes = jas_alloc2(tile->numlyrs,
	  sizeof(uint_fast32_t)))) {

----------------------------------------------------------------------------------
	if (!(tile->tcmpts = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_tcmpt_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (!tcmpt_create(tcmpt, cp, image, tile)) {
			goto error;

----------------------------------------------------------------------------------
	switch (tile->mctid) {
	case JPC_MCT_RCT:
		tile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0));
		tile->tcmpts[1].synweight = jpc_dbltofix(sqrt(0.6875));
		tile->tcmpts[2].synweight = jpc_dbltofix(sqrt(0.6875));
		break;
	case JPC_MCT_ICT:
		tile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0000));
		tile->tcmpts[1].synweight = jpc_dbltofix(sqrt(3.2584));
		tile->tcmpts[2].synweight = jpc_dbltofix(sqrt(2.4755));
		break;
	default:
	case JPC_MCT_NONE:
		for (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;
		  ++cmptno, ++tcmpt) {
			tcmpt->synweight = JPC_FIX_ONE;
		}
		break;
	}

----------------------------------------------------------------------------------
	if (!(tile->pi = jpc_enc_pi_create(cp, tile))) {
		goto error;

----------------------------------------------------------------------------------
	if (tile) {
		jpc_enc_tile_destroy(tile);

----------------------------------------------------------------------------------
	if (tile->tcmpts) {
		for (cmptno = 0, tcmpt = tile->tcmpts; cmptno <

----------------------------------------------------------------------------------
	if (tile->lyrsizes) {
		jas_free(tile->lyrsizes);
	}

----------------------------------------------------------------------------------
	if (tile->pi) {
		jpc_pi_destroy(tile->pi);

----------------------------------------------------------------------------------
	if (!(tcmpt->data = jas_seq2d_create(tlx, tly, brx, bry))) {
		goto error;

----------------------------------------------------------------------------------
	if (jas_image_readcmpt(image, cmptno, tlx - cmpttlx, tly - cmpttly,
	  brx - tlx, bry - tly, tcmpt->data)) {

----------------------------------------------------------------------------------
	if (!(tcmpt->tsfb = jpc_cod_gettsfb(tcmpt->qmfbid, tcmpt->numrlvls - 1))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(tcmpt->rlvls = jas_alloc2(tcmpt->numrlvls, sizeof(jpc_enc_rlvl_t)))) {
		goto error;

----------------------------------------------------------------------------------
		if (!rlvl_create(rlvl, cp, tcmpt, bandinfos)) {
			goto error;

----------------------------------------------------------------------------------
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;

----------------------------------------------------------------------------------
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}

----------------------------------------------------------------------------------
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);

----------------------------------------------------------------------------------
	if (rlvl->tlx >= rlvl->brx || rlvl->tly >= rlvl->bry) {
		rlvl->numhprcs = 0;

----------------------------------------------------------------------------------
	if (!rlvlno) {
		rlvl->cbgwidthexpn = rlvl->prcwidthexpn;

----------------------------------------------------------------------------------
	if (!(rlvl->bands = jas_alloc2(rlvl->numbands, sizeof(jpc_enc_band_t)))) {
		goto error;

----------------------------------------------------------------------------------
		if (!band_create(band, cp, rlvl, bandinfos)) {
			goto error;

----------------------------------------------------------------------------------
	if (rlvl->bands) {
		for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;

----------------------------------------------------------------------------------
if (bandinfo->xstart != bandinfo->xend && bandinfo->ystart != bandinfo->yend) {
	if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {
		goto error;
	}
	jas_seq2d_bindsub(band->data, tcmpt->data, bandinfo->locxstart,

----------------------------------------------------------------------------------
if (band->data) {
	if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_enc_prc_t)))) {
		goto error;
	}
	for (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno,

----------------------------------------------------------------------------------
		if (!prc_create(prc, cp, band)) {
			goto error;
		}

----------------------------------------------------------------------------------
	if (band->prcs) {
		rlvl = band->rlvl;

----------------------------------------------------------------------------------
	if (band->data) {
		jas_seq2d_destroy(band->data);

----------------------------------------------------------------------------------
if (!rlvlno) {
	tlcbgtlx = tlprctlx;

----------------------------------------------------------------------------------
	if (prc->tlx < prc->brx && prc->tly < prc->bry) {
		/* The precinct contains at least one code block. */

----------------------------------------------------------------------------------
		if (!(prc->incltree = jpc_tagtree_create(prc->numhcblks,
		  prc->numvcblks))) {

----------------------------------------------------------------------------------
		if (!(prc->nlibtree = jpc_tagtree_create(prc->numhcblks,
		  prc->numvcblks))) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (!(prc->savincltree = jpc_tagtree_create(prc->numhcblks,
		  prc->numvcblks))) {

----------------------------------------------------------------------------------
		if (!(prc->savnlibtree = jpc_tagtree_create(prc->numhcblks,
		  prc->numvcblks))) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_enc_cblk_t)))) {
			goto error;

----------------------------------------------------------------------------------
			if (!cblk_create(cblk, cp, prc)) {
				goto error;

----------------------------------------------------------------------------------
	if (prc->cblks) {
		for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;

----------------------------------------------------------------------------------
	if (prc->incltree) {
		jpc_tagtree_destroy(prc->incltree);
	}

----------------------------------------------------------------------------------
	if (prc->nlibtree) {
		jpc_tagtree_destroy(prc->nlibtree);

----------------------------------------------------------------------------------
	if (prc->savincltree) {
		jpc_tagtree_destroy(prc->savincltree);

----------------------------------------------------------------------------------
	if (prc->savnlibtree) {
		jpc_tagtree_destroy(prc->savnlibtree);

----------------------------------------------------------------------------------
	if (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {
		goto error;

----------------------------------------------------------------------------------
	if (cblk->passes) {
		for (passno = 0, pass = cblk->passes; passno < cblk->numpasses;

----------------------------------------------------------------------------------
	if (cblk->stream) {
		jas_stream_close(cblk->stream);
	}

----------------------------------------------------------------------------------
	if (cblk->mqenc) {
		jpc_mqenc_destroy(cblk->mqenc);

----------------------------------------------------------------------------------
	if (cblk->data) {
		jas_seq2d_destroy(cblk->data);

----------------------------------------------------------------------------------
	if (cblk->flags) {
		jas_seq2d_destroy(cblk->flags);

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 100) { \
		jas_eprintf("index = %ld; passtype = %s; symtype = %s; sym = %d\n", t1dec_cnt, passtypename, symtypename, v); \
		++t1dec_cnt; \
	} \

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 100) { \
		jas_eprintf("index = %ld; passtype = %s; symtype = %s; sym = %d\n", t1dec_cnt, passtypename, symtypename, v); \
		++t1dec_cnt; \
	} \

----------------------------------------------------------------------------------
			if (!rlvl->bands) {
				continue;
			}

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;
				}

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;
					}

----------------------------------------------------------------------------------
						if (jpc_dec_decodecblk(dec, tile, tcomp,
						  band, cblk, 1, JPC_MAXLYRS)) {
							return -1;
						}

----------------------------------------------------------------------------------
	if (!cblk->flags) {
		/* Note: matrix is assumed to be zeroed */

----------------------------------------------------------------------------------
		if (!(cblk->flags = jas_matrix_create(jas_matrix_numrows(cblk->data) +
		  2, jas_matrix_numcols(cblk->data) + 2))) {

----------------------------------------------------------------------------------
		if (seg->type == JPC_SEG_MQ) {
			if (!cblk->mqdec) {
				if (!(cblk->mqdec = jpc_mqdec_create(JPC_NUMCTXS, 0))) {
					return -1;
				}
				jpc_mqdec_setctxs(cblk->mqdec, JPC_NUMCTXS, jpc_mqctxs);

----------------------------------------------------------------------------------
			if (!cblk->nulldec) {
				if (!(cblk->nulldec = jpc_bitstream_sopen(seg->stream, "r"))) {

----------------------------------------------------------------------------------
			if (cblk->numimsbs > band->numbps) {
				ccp = &tile->cp->ccps[compno];
				if (ccp->roishift <= 0) {

----------------------------------------------------------------------------------
					if (cblk->numimsbs < ccp->roishift - band->numbps) {
						jas_eprintf("warning: corrupt code stream\n");
					}

----------------------------------------------------------------------------------
if (bpno < 0) {
	goto premature_exit;

----------------------------------------------------------------------------------
			switch (passtype) {
			case JPC_SIGPASS:
				ret = (seg->type == JPC_SEG_MQ) ? dec_sigpass(dec,
				  cblk->mqdec, bpno, band->orient,
				  (tile->cp->ccps[compno].cblkctx & JPC_COX_VSC) != 0,
				  cblk->flags, cblk->data) :
				  dec_rawsigpass(dec, cblk->nulldec, bpno,
				  (tile->cp->ccps[compno].cblkctx & JPC_COX_VSC) != 0,
				  cblk->flags, cblk->data);
				break;
			case JPC_REFPASS:
				ret = (seg->type == JPC_SEG_MQ) ?
				  dec_refpass(dec, cblk->mqdec, bpno,
				  (tile->cp->ccps[compno].cblkctx & JPC_COX_VSC) != 0,
				  cblk->flags, cblk->data) :
				  dec_rawrefpass(dec, cblk->nulldec, bpno,
				  (tile->cp->ccps[compno].cblkctx & JPC_COX_VSC) != 0,
				  cblk->flags, cblk->data);
				break;
			case JPC_CLNPASS:
				assert(seg->type == JPC_SEG_MQ);
				ret = dec_clnpass(dec, cblk->mqdec, bpno,
				  band->orient, (tile->cp->ccps[compno].cblkctx &
				  JPC_COX_VSC) != 0, (tile->cp->ccps[compno].cblkctx &
				  JPC_COX_SEGSYM) != 0, cblk->flags,
				  cblk->data);
				break;
			default:
				ret = -1;
				break;
			}

----------------------------------------------------------------------------------
			if (tile->cp->ccps[compno].cblkctx & JPC_COX_RESET) {
				jpc_mqdec_setctxs(cblk->mqdec, JPC_NUMCTXS, jpc_mqctxs);

----------------------------------------------------------------------------------
			if (ret) {
				jas_eprintf("coding pass failed passtype=%d segtype=%d\n", passtype, seg->type);

----------------------------------------------------------------------------------
		if (seg->type == JPC_SEG_MQ) {
/* Note: dont destroy mq decoder because context info will be lost */

----------------------------------------------------------------------------------
			if (tile->cp->ccps[compno].cblkctx & JPC_COX_PTERM) {
				fillmask = 0x7f;

----------------------------------------------------------------------------------
			if ((ret = jpc_bitstream_inalign(cblk->nulldec, fillmask,
			  filldata)) < 0) {

----------------------------------------------------------------------------------
	if ((f & JPC_OTHSIGMSK) && !(f & (JPC_SIG | JPC_VISIT))) { \
		jpc_mqdec_setcurctx((mqdec), JPC_GETZCCTXNO(f, (orient))); \
		JPC_T1D_GETBIT((mqdec), v, "SIG", "ZC"); \

----------------------------------------------------------------------------------
		if (v) { \
			jpc_mqdec_setcurctx((mqdec), JPC_GETSCCTXNO(f)); \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
	if ((f & JPC_OTHSIGMSK) && !(f & (JPC_SIG | JPC_VISIT))) { \
		JPC_T1D_RAWGETBIT(in, v, "SIG", "ZC"); \

----------------------------------------------------------------------------------
		if (v < 0) { \
			return -1; \

----------------------------------------------------------------------------------
		if (v) { \
			JPC_T1D_RAWGETBIT(in, v, "SIG", "SC"); \

----------------------------------------------------------------------------------
			if (v < 0) { \
				return -1; \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
	if (((*(fp)) & (JPC_SIG | JPC_VISIT)) == JPC_SIG) { \
		jpc_mqdec_setcurctx((mqdec), JPC_GETMAGCTXNO(*(fp))); \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
	if (((*(fp)) & (JPC_SIG | JPC_VISIT)) == JPC_SIG) { \
		JPC_T1D_RAWGETBIT(in, v, "REF", "MAGREF"); \

----------------------------------------------------------------------------------
		if (v < 0) { \
			return -1; \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
	if (!((f) & (JPC_SIG | JPC_VISIT))) { \
		jpc_mqdec_setcurctx((mqdec), JPC_GETZCCTXNO((f), (orient))); \

----------------------------------------------------------------------------------
		if (v) { \
plabel \

----------------------------------------------------------------------------------
			if (vscanlen >= 4 && (!((*fp) & (JPC_SIG | JPC_VISIT |
			  JPC_OTHSIGMSK))) && (fp += frowstep, !((*fp) & (JPC_SIG |

----------------------------------------------------------------------------------
				if (!v) {
					continue;
				}

----------------------------------------------------------------------------------
				switch (runlen) {
				case 0:
					goto clnpass_partial0;
					break;
				case 1:
					goto clnpass_partial1;
					break;
				case 2:
					goto clnpass_partial2;
					break;
				case 3:
					goto clnpass_partial3;
					break;
				}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
	if (segsymflag) {
		int segsymval;

----------------------------------------------------------------------------------
		if (segsymval != 0xa) {
			jas_eprintf("warning: bad segmentation symbol\n");

----------------------------------------------------------------------------------
	switch (passno % 3) {
	case 0:
		passtype = JPC_CLNPASS;
		break;
	case 1:
		passtype = JPC_SIGPASS;
		break;
	case 2:
		passtype = JPC_REFPASS;
		break;
	default:
		passtype = -1;
		assert(0);
		break;
	}

----------------------------------------------------------------------------------
	if (qmfbid == JPC_COX_INS) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (lvlno == 0) {
		assert(orient == JPC_TSFB_LL);
		return 0;
	} else {
		switch (orient) {
		case JPC_TSFB_LH:
		case JPC_TSFB_HL:
			return 1;
			break;
		case JPC_TSFB_HH:
			return 2;
			break;
		default:
			abort();
			break;
		}
	}

----------------------------------------------------------------------------------
	if (bypass) {
		passtype = JPC_PASSTYPE(passno);
		if (passtype == JPC_CLNPASS) {
			return JPC_SEG_MQ;
		}
		return ((passno < firstpassno + 10) ? JPC_SEG_MQ : JPC_SEG_RAW);
	} else {
		return JPC_SEG_MQ;
	}

----------------------------------------------------------------------------------
	if (termall) {
		ret = 1;
	} else if (bypass) {
		if (passno < firstpassno + 10) {
			ret = 10 - (passno - firstpassno);
		} else {
			passtype = JPC_PASSTYPE(passno);
			switch (passtype) {
			case JPC_SIGPASS:
				ret = 2;
				break;
			case JPC_REFPASS:
				ret = 1;
				break;
			case JPC_CLNPASS:
				ret = 1;
				break;
			default:
				ret = -1;
				assert(0);
				break;
			}
		}
	} else {
		ret = JPC_PREC * 3 - 2;
	}

----------------------------------------------------------------------------------
	if (passno - firstpassno == numpasses - 1) {
		ret = 1;
	} else {
		n = JPC_SEGPASSCNT(passno, firstpassno, numpasses, lazy, termall);
		ret = (n <= 1) ? 1 : 0;
	}

----------------------------------------------------------------------------------
		if (i & (1 << (JPC_NMSEDEC_BITS - 1))) {
			v = t - 1.5;
		} else {
			v = t - 0.5;
		}

----------------------------------------------------------------------------------
	switch (orient) {
	case JPC_TSFB_HL:
		t = h;
		h = v;
		v = t;
	case JPC_TSFB_LL:
	case JPC_TSFB_LH:
		if (!h) {
			if (!v) {
				if (!d) {
					n = 0;
				} else if (d == 1) {
					n = 1;
				} else {
					n = 2;
				}
			} else if (v == 1) {
				n = 3;
			} else {
				n = 4;
			}
		} else if (h == 1) {
			if (!v) {
				if (!d) {
					n = 5;
				} else {
					n = 6;
				}
			} else {
				n = 7;
			}
		} else {
			n = 8;
		}
		break;
	case JPC_TSFB_HH:
		hv = h + v;
		if (!d) {
			if (!hv) {
				n = 0;
			} else if (hv == 1) {
				n = 1;
			} else {
				n = 2;
			}
		} else if (d == 1) {
			if (!hv) {
				n = 3;
			} else if (hv == 1) {
				n = 4;
			} else {
				n = 5;
			}
		} else if (d == 2) {
			if (!hv) {
				n = 6;
			} else {
				n = 7;
			}
		} else {
			n = 8;
		}
		break;
	}

----------------------------------------------------------------------------------
	if (!hc && !vc) {
		n = 0;
	} else {
		n = (!(hc > 0 || (!hc && vc > 0)));
	}

----------------------------------------------------------------------------------
	if (hc < 0) {
		hc = -hc;
		vc = -vc;
	}

----------------------------------------------------------------------------------
	if (!hc) {
		if (vc == -1) {
			n = 1;
		} else if (!vc) {
			n = 0;
		} else {
			n = 1;
		}
	} else if (hc == 1) {
		if (vc == -1) {
			n = 2;
		} else if (!vc) {
			n = 3;
		} else {
			n = 4;
		}
	}

----------------------------------------------------------------------------------
	if (!(f & JPC_REFINE)) {
		n = (f & (JPC_OTHSIGMSK)) ? 1 : 0;
	} else {
		n = 2;
	}

----------------------------------------------------------------------------------
		switch (i) {
		case JPC_UCTXNO:
			ctx->ind = 46;
			break;
		case JPC_ZCCTXNO:
			ctx->ind = 4;
			break;
		case JPC_AGGCTXNO:
			ctx->ind = 3;
			break;
		default:
			ctx->ind = 0;
			break;
		}

----------------------------------------------------------------------------------
	if (n < 0) {
		a = 0.5;
		n = -n;
	} else {
		a = 2.0;
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide in this case. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (numcols >= 2) {
		hstartcol = (numcols + 1 - parity) >> 1;
		// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numcols - hstartcol);
		m = numcols - hstartcol;

		/* Save the samples destined for the highpass channel. */
		n = m;
		dstptr = buf;
		srcptr = &a[1 - parity];
		while (n-- > 0) {
			*dstptr = *srcptr;
			++dstptr;
			srcptr += 2;
		}
		/* Copy the appropriate samples into the lowpass channel. */
		dstptr = &a[1 - parity];
		srcptr = &a[2 - parity];
		n = numcols - m - (!parity);
		while (n-- > 0) {
			*dstptr = *srcptr;
			++dstptr;
			srcptr += 2;
		}
		/* Copy the saved samples into the highpass channel. */
		dstptr = &a[hstartcol];
		srcptr = buf;
		n = m;
		while (n-- > 0) {
			*dstptr = *srcptr;
			++dstptr;
			++srcptr;
		}
	}

----------------------------------------------------------------------------------
	if (buf != splitbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide in this case. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (numrows >= 2) {
		hstartrow = (numrows + 1 - parity) >> 1;
		// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);
		m = numrows - hstartrow;

		/* Save the samples destined for the highpass channel. */
		n = m;
		dstptr = buf;
		srcptr = &a[(1 - parity) * stride];
		while (n-- > 0) {
			*dstptr = *srcptr;
			++dstptr;
			srcptr += stride << 1;
		}
		/* Copy the appropriate samples into the lowpass channel. */
		dstptr = &a[(1 - parity) * stride];
		srcptr = &a[(2 - parity) * stride];
		n = numrows - m - (!parity);
		while (n-- > 0) {
			*dstptr = *srcptr;
			dstptr += stride;
			srcptr += stride << 1;
		}
		/* Copy the saved samples into the highpass channel. */
		dstptr = &a[hstartrow * stride];
		srcptr = buf;
		n = m;
		while (n-- > 0) {
			*dstptr = *srcptr;
			dstptr += stride;
			++srcptr;
		}
	}

----------------------------------------------------------------------------------
	if (buf != splitbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,
		  sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide in this case. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (numrows >= 2) {
		hstartrow = (numrows + 1 - parity) >> 1;
		// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);
		m = numrows - hstartrow;

		/* Save the samples destined for the highpass channel. */
		n = m;
		dstptr = buf;
		srcptr = &a[(1 - parity) * stride];
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += JPC_QMFB_COLGRPSIZE;
			srcptr += stride << 1;
		}
		/* Copy the appropriate samples into the lowpass channel. */
		dstptr = &a[(1 - parity) * stride];
		srcptr = &a[(2 - parity) * stride];
		n = numrows - m - (!parity);
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += stride;
			srcptr += stride << 1;
		}
		/* Copy the saved samples into the highpass channel. */
		dstptr = &a[hstartrow * stride];
		srcptr = buf;
		n = m;
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += stride;
			srcptr += JPC_QMFB_COLGRPSIZE;
		}
	}

----------------------------------------------------------------------------------
	if (buf != splitbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_SPLITBUFSIZE) {
		if (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide in this case. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (numrows >= 2) {
		hstartcol = (numrows + 1 - parity) >> 1;
		// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);
		m = numrows - hstartcol;

		/* Save the samples destined for the highpass channel. */
		n = m;
		dstptr = buf;
		srcptr = &a[(1 - parity) * stride];
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < numcols; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += numcols;
			srcptr += stride << 1;
		}
		/* Copy the appropriate samples into the lowpass channel. */
		dstptr = &a[(1 - parity) * stride];
		srcptr = &a[(2 - parity) * stride];
		n = numrows - m - (!parity);
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < numcols; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += stride;
			srcptr += stride << 1;
		}
		/* Copy the saved samples into the highpass channel. */
		dstptr = &a[hstartcol * stride];
		srcptr = buf;
		n = m;
		while (n-- > 0) {
			dstptr2 = dstptr;
			srcptr2 = srcptr;
			for (i = 0; i < numcols; ++i) {
				*dstptr2 = *srcptr2;
				++dstptr2;
				++srcptr2;
			}
			dstptr += stride;
			srcptr += numcols;
		}
	}

----------------------------------------------------------------------------------
	if (buf != splitbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_JOINBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (buf != joinbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_JOINBUFSIZE) {
		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (buf != joinbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_JOINBUFSIZE) {
		if (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,
		  sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (buf != joinbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (bufsize > QMFB_JOINBUFSIZE) {
		if (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {
			/* We have no choice but to commit suicide. */
			abort();
		}
	}

----------------------------------------------------------------------------------
	if (buf != joinbuf) {
		jas_free(buf);
	}

----------------------------------------------------------------------------------
	if (numcols > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			hptr[0] -= lptr[0];
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			//hptr[0] -= (lptr[0] + lptr[1]) >> 1;
			hptr[0] -= jpc_fix_asr(lptr[0] + lptr[1], 1);
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			hptr[0] -= lptr[0];
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			//lptr[0] += (hptr[0] + 1) >> 1;
			lptr[0] += jpc_fix_asr(hptr[0] + 1, 1);
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			//lptr[0] += (hptr[0] + hptr[1] + 2) >> 2;
			lptr[0] += jpc_fix_asr(hptr[0] + hptr[1] + 2, 2);
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			//lptr[0] += (hptr[0] + 1) >> 1;
			lptr[0] += jpc_fix_asr(hptr[0] + 1, 1);
		}

	} else {

		if (parity) {
			lptr = &a[0];
			//lptr[0] <<= 1;
			lptr[0] = jpc_fix_asl(lptr[0], 1);
		}

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			hptr[0] -= lptr[0];
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			//hptr[0] -= (lptr[0] + lptr[stride]) >> 1;
			hptr[0] -= jpc_fix_asr(lptr[0] + lptr[stride], 1);
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			hptr[0] -= lptr[0];
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			//lptr[0] += (hptr[0] + 1) >> 1;
			lptr[0] += jpc_fix_asr(hptr[0] + 1, 1);
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			//lptr[0] += (hptr[0] + hptr[stride] + 2) >> 2;
			lptr[0] += jpc_fix_asr(hptr[0] + hptr[stride] + 2, 2);
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			//lptr[0] += (hptr[0] + 1) >> 1;
			lptr[0] += jpc_fix_asr(hptr[0] + 1, 1);
		}

	} else {

		if (parity) {
			lptr = &a[0];
			//lptr[0] <<= 1;
			lptr[0] = jpc_fix_asl(lptr[0], 1);
		}

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] -= lptr2[0];
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//hptr2[0] -= (lptr2[0] + lptr2[stride]) >> 1;
				hptr2[0] -= jpc_fix_asr(lptr2[0] + lptr2[stride], 1);
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] -= lptr2[0];
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] += (hptr2[0] + 1) >> 1;
				lptr2[0] += jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] += (hptr2[0] + hptr2[stride] + 2) >> 2;
				lptr2[0] += jpc_fix_asr(hptr2[0] + hptr2[stride] + 2, 2);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] += (hptr2[0] + 1) >> 1;
				lptr2[0] += jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
		}

	} else {

		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] <<= 1;
				lptr2[0] = jpc_fix_asl(lptr2[0], 1);
				++lptr2;
			}
		}

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				hptr2[0] -= lptr2[0];
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//hptr2[0] -= (lptr2[0] + lptr2[stride]) >> 1;
				hptr2[0] -= jpc_fix_asr(lptr2[0] + lptr2[stride], 1);
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				hptr2[0] -= lptr2[0];
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] += (hptr2[0] + 1) >> 1;
				lptr2[0] += jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] += (hptr2[0] + hptr2[stride] + 2) >> 2;
				lptr2[0] += jpc_fix_asr(hptr2[0] + hptr2[stride] + 2, 2);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] += (hptr2[0] + 1) >> 1;
				lptr2[0] += jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
		}

	} else {

		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] <<= 1;
				lptr2[0] = jpc_fix_asl(lptr2[0], 1);
				++lptr2;
			}
		}

	}

----------------------------------------------------------------------------------
	if (numcols > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			//lptr[0] -= (hptr[0] + 1) >> 1;
			lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			//lptr[0] -= (hptr[0] + hptr[1] + 2) >> 2;
			lptr[0] -= jpc_fix_asr(hptr[0] + hptr[1] + 2, 2);
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			//lptr[0] -= (hptr[0] + 1) >> 1;
			lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			hptr[0] += lptr[0];
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			//hptr[0] += (lptr[0] + lptr[1]) >> 1;
			hptr[0] += jpc_fix_asr(lptr[0] + lptr[1], 1);
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			hptr[0] += lptr[0];
		}

	} else {

		if (parity) {
			lptr = &a[0];
			//lptr[0] >>= 1;
			lptr[0] = jpc_fix_asr(lptr[0], 1);
		}

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			//lptr[0] -= (hptr[0] + 1) >> 1;
			lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			//lptr[0] -= (hptr[0] + hptr[stride] + 2) >> 2;
			lptr[0] -= jpc_fix_asr(hptr[0] + hptr[stride] + 2, 2);
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			//lptr[0] -= (hptr[0] + 1) >> 1;
			lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			hptr[0] += lptr[0];
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			//hptr[0] += (lptr[0] + lptr[stride]) >> 1;
			hptr[0] += jpc_fix_asr(lptr[0] + lptr[stride], 1);
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			hptr[0] += lptr[0];
		}

	} else {

		if (parity) {
			lptr = &a[0];
			//lptr[0] >>= 1;
			lptr[0] = jpc_fix_asr(lptr[0], 1);
		}

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] -= (hptr2[0] + 1) >> 1;
				lptr2[0] -= jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] -= (hptr2[0] + hptr2[stride] + 2) >> 2;
				lptr2[0] -= jpc_fix_asr(hptr2[0] + hptr2[stride] + 2, 2);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] -= (hptr2[0] + 1) >> 1;
				lptr2[0] -= jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] += lptr2[0];
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//hptr2[0] += (lptr2[0] + lptr2[stride]) >> 1;
				hptr2[0] += jpc_fix_asr(lptr2[0] + lptr2[stride], 1);
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] += lptr2[0];
				++lptr2;
				++hptr2;
			}
		}

	} else {

		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] >>= 1;
				lptr2[0] = jpc_fix_asr(lptr2[0], 1);
				++lptr2;
			}
		}

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] -= (hptr2[0] + 1) >> 1;
				lptr2[0] -= jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] -= (hptr2[0] + hptr2[stride] + 2) >> 2;
				lptr2[0] -= jpc_fix_asr(hptr2[0] + hptr2[stride] + 2, 2);
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] -= (hptr2[0] + 1) >> 1;
				lptr2[0] -= jpc_fix_asr(hptr2[0] + 1, 1);
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				hptr2[0] += lptr2[0];
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				//hptr2[0] += (lptr2[0] + lptr2[stride]) >> 1;
				hptr2[0] += jpc_fix_asr(lptr2[0] + lptr2[stride], 1);
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				hptr2[0] += lptr2[0];
				++lptr2;
				++hptr2;
			}
		}

	} else {

		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] >>= 1;
				lptr2[0] = jpc_fix_asr(lptr2[0], 1);
				++lptr2;
			}
		}

	}

----------------------------------------------------------------------------------
	if (maxcols < numcols) {
		jpc_qmfb_split_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
		jpc_ft_fwdlift_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
	}

----------------------------------------------------------------------------------
	if (maxcols < numcols) {
		jpc_ft_invlift_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
		jpc_qmfb_join_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
	}

----------------------------------------------------------------------------------
	if (numcols > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			jpc_fix_pluseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
			  lptr[0]));
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			jpc_fix_pluseq(hptr[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
			  jpc_fix_add(lptr[0], lptr[1])));
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			jpc_fix_pluseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
			  lptr[0]));
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			jpc_fix_pluseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr[0]));
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			jpc_fix_pluseq(lptr[0], jpc_fix_mul(jpc_dbltofix(BETA),
			  jpc_fix_add(hptr[0], hptr[1])));
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			jpc_fix_pluseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr[0]));
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			jpc_fix_pluseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
			  lptr[0]));
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			jpc_fix_pluseq(hptr[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
			  jpc_fix_add(lptr[0], lptr[1])));
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			jpc_fix_pluseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
			  lptr[0]));
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			jpc_fix_pluseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
			  hptr[0]));
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			jpc_fix_pluseq(lptr[0], jpc_fix_mul(jpc_dbltofix(DELTA),
			  jpc_fix_add(hptr[0], hptr[1])));
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			jpc_fix_pluseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
			  hptr[0]));
		}

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr[0] = jpc_fix_mul(lptr[0], jpc_dbltofix(LGAIN));
			++lptr;
		}
		hptr = &a[llen];
		n = numcols - llen;
		while (n-- > 0) {
			hptr[0] = jpc_fix_mul(hptr[0], jpc_dbltofix(HGAIN));
			++hptr;
		}
#endif

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr = &a[0];
			//lptr[0] <<= 1;
			lptr[0] = jpc_fix_asl(lptr[0], 1);
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
				  lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
				  lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(BETA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
				  lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
				  lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(DELTA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr2 = lptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				lptr2[0] = jpc_fix_mul(lptr2[0], jpc_dbltofix(LGAIN));
				++lptr2;
			}
			lptr += stride;
		}
		hptr = &a[llen * stride];
		n = numrows - llen;
		while (n-- > 0) {
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] = jpc_fix_mul(hptr2[0], jpc_dbltofix(HGAIN));
				++hptr2;
			}
			hptr += stride;
		}
#endif

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] <<= 1;
				lptr2[0] = jpc_fix_asl(lptr2[0], 1);
				++lptr2;
			}
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
				  lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
				  lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(BETA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
				  lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
				  lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(DELTA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr2 = lptr;
			for (i = 0; i < numcols; ++i) {
				lptr2[0] = jpc_fix_mul(lptr2[0], jpc_dbltofix(LGAIN));
				++lptr2;
			}
			lptr += stride;
		}
		hptr = &a[llen * stride];
		n = numrows - llen;
		while (n-- > 0) {
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				hptr2[0] = jpc_fix_mul(hptr2[0], jpc_dbltofix(HGAIN));
				++hptr2;
			}
			hptr += stride;
		}
#endif

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] <<= 1;
				lptr2[0] = jpc_fix_asl(lptr2[0], 1);
				++lptr2;
			}
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
			  lptr2[0]));
			++hptr2;
			++lptr2;
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
			  jpc_fix_add(lptr2[0], lptr2[stride])));
			++lptr2;
			++hptr2;
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
			  lptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr2[0]));
			++lptr2;
			++hptr2;
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(BETA),
			  jpc_fix_add(hptr2[0], hptr2[stride])));
			++lptr2;
			++hptr2;
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
			  lptr2[0]));
			++hptr2;
			++lptr2;
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
			  jpc_fix_add(lptr2[0], lptr2[stride])));
			++lptr2;
			++hptr2;
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
			  lptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
			  hptr2[0]));
			++lptr2;
			++hptr2;
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(DELTA),
			  jpc_fix_add(hptr2[0], hptr2[stride])));
			++lptr2;
			++hptr2;
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_pluseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
			  hptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr2 = lptr;
			lptr2[0] = jpc_fix_mul(lptr2[0], jpc_dbltofix(LGAIN));
			++lptr2;
			lptr += stride;
		}
		hptr = &a[llen * stride];
		n = numrows - llen;
		while (n-- > 0) {
			hptr2 = hptr;
			hptr2[0] = jpc_fix_mul(hptr2[0], jpc_dbltofix(HGAIN));
			++hptr2;
			hptr += stride;
		}
#endif

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr2 = &a[0];
			//lptr2[0] <<= 1;
			lptr2[0] = jpc_fix_asl(lptr2[0], 1);
			++lptr2;
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numcols > 1) {

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr[0] = jpc_fix_mul(lptr[0], jpc_dbltofix(1.0 / LGAIN));
			++lptr;
		}
		hptr = &a[llen];
		n = numcols - llen;
		while (n-- > 0) {
			hptr[0] = jpc_fix_mul(hptr[0], jpc_dbltofix(1.0 / HGAIN));
			++hptr;
		}
#endif

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			jpc_fix_minuseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
			  hptr[0]));
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			jpc_fix_minuseq(lptr[0], jpc_fix_mul(jpc_dbltofix(DELTA),
			  jpc_fix_add(hptr[0], hptr[1])));
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			jpc_fix_minuseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * DELTA),
			  hptr[0]));
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			jpc_fix_minuseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
			  lptr[0]));
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			jpc_fix_minuseq(hptr[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
			  jpc_fix_add(lptr[0], lptr[1])));
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			jpc_fix_minuseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * GAMMA),
			  lptr[0]));
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (!parity) {
			jpc_fix_minuseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr[0]));
			++lptr;
		}
		n = llen - (!parity) - (parity != (numcols & 1));
		while (n-- > 0) {
			jpc_fix_minuseq(lptr[0], jpc_fix_mul(jpc_dbltofix(BETA),
			  jpc_fix_add(hptr[0], hptr[1])));
			++lptr;
			++hptr;
		}
		if (parity != (numcols & 1)) {
			jpc_fix_minuseq(lptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr[0]));
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen];
		if (parity) {
			jpc_fix_minuseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
			  lptr[0]));
			++hptr;
		}
		n = numcols - llen - parity - (parity == (numcols & 1));
		while (n-- > 0) {
			jpc_fix_minuseq(hptr[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
			  jpc_fix_add(lptr[0], lptr[1])));
			++hptr;
			++lptr;
		}
		if (parity == (numcols & 1)) {
			jpc_fix_minuseq(hptr[0], jpc_fix_mul(jpc_dbltofix(2.0 * ALPHA),
			  lptr[0]));
		}

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr = &a[0];
			//lptr[0] >>= 1;
			lptr[0] = jpc_fix_asr(lptr[0], 1);
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr2 = lptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				lptr2[0] = jpc_fix_mul(lptr2[0], jpc_dbltofix(1.0 / LGAIN));
				++lptr2;
			}
			lptr += stride;
		}
		hptr = &a[llen * stride];
		n = numrows - llen;
		while (n-- > 0) {
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				hptr2[0] = jpc_fix_mul(hptr2[0], jpc_dbltofix(1.0 / HGAIN));
				++hptr2;
			}
			hptr += stride;
		}
#endif

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  DELTA), hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(DELTA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  DELTA), hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  GAMMA), lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  GAMMA), lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(BETA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  ALPHA), lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  ALPHA), lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {
				//lptr2[0] >>= 1;
				lptr2[0] = jpc_fix_asr(lptr2[0], 1);
				++lptr2;
			}
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr2 = lptr;
			for (i = 0; i < numcols; ++i) {
				lptr2[0] = jpc_fix_mul(lptr2[0], jpc_dbltofix(1.0 / LGAIN));
				++lptr2;
			}
			lptr += stride;
		}
		hptr = &a[llen * stride];
		n = numrows - llen;
		while (n-- > 0) {
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				hptr2[0] = jpc_fix_mul(hptr2[0], jpc_dbltofix(1.0 / HGAIN));
				++hptr2;
			}
			hptr += stride;
		}
#endif

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  DELTA), hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(DELTA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  DELTA), hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  GAMMA), lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  GAMMA), lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(BETA),
				  jpc_fix_add(hptr2[0], hptr2[stride])));
				++lptr2;
				++hptr2;
			}
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
				  hptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  ALPHA), lptr2[0]));
				++hptr2;
				++lptr2;
			}
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
				  jpc_fix_add(lptr2[0], lptr2[stride])));
				++lptr2;
				++hptr2;
			}
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			for (i = 0; i < numcols; ++i) {
				jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
				  ALPHA), lptr2[0]));
				++lptr2;
				++hptr2;
			}
		}

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr2 = &a[0];
			for (i = 0; i < numcols; ++i) {
				//lptr2[0] >>= 1;
				lptr2[0] = jpc_fix_asr(lptr2[0], 1);
				++lptr2;
			}
		}
#endif

	}

----------------------------------------------------------------------------------
	if (numrows > 1) {

		/* Apply the scaling step. */
#if defined(WT_DOSCALE)
		lptr = &a[0];
		n = llen;
		while (n-- > 0) {
			lptr2 = lptr;
			lptr2[0] = jpc_fix_mul(lptr2[0], jpc_dbltofix(1.0 / LGAIN));
			++lptr2;
			lptr += stride;
		}
		hptr = &a[llen * stride];
		n = numrows - llen;
		while (n-- > 0) {
			hptr2 = hptr;
			hptr2[0] = jpc_fix_mul(hptr2[0], jpc_dbltofix(1.0 / HGAIN));
			++hptr2;
			hptr += stride;
		}
#endif

		/* Apply the first lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
			  DELTA), hptr2[0]));
			++lptr2;
			++hptr2;
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(DELTA),
			  jpc_fix_add(hptr2[0], hptr2[stride])));
			++lptr2;
			++hptr2;
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
			  DELTA), hptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the second lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
			  GAMMA), lptr2[0]));
			++hptr2;
			++lptr2;
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(GAMMA),
			  jpc_fix_add(lptr2[0], lptr2[stride])));
			++lptr2;
			++hptr2;
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
			  GAMMA), lptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the third lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (!parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr2[0]));
			++lptr2;
			++hptr2;
			lptr += stride;
		}
		n = llen - (!parity) - (parity != (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(BETA),
			  jpc_fix_add(hptr2[0], hptr2[stride])));
			++lptr2;
			++hptr2;
			lptr += stride;
			hptr += stride;
		}
		if (parity != (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(lptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 * BETA),
			  hptr2[0]));
			++lptr2;
			++hptr2;
		}

		/* Apply the fourth lifting step. */
		lptr = &a[0];
		hptr = &a[llen * stride];
		if (parity) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
			  ALPHA), lptr2[0]));
			++hptr2;
			++lptr2;
			hptr += stride;
		}
		n = numrows - llen - parity - (parity == (numrows & 1));
		while (n-- > 0) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(ALPHA),
			  jpc_fix_add(lptr2[0], lptr2[stride])));
			++lptr2;
			++hptr2;
			hptr += stride;
			lptr += stride;
		}
		if (parity == (numrows & 1)) {
			lptr2 = lptr;
			hptr2 = hptr;
			jpc_fix_minuseq(hptr2[0], jpc_fix_mul(jpc_dbltofix(2.0 *
			  ALPHA), lptr2[0]));
			++lptr2;
			++hptr2;
		}

	} else {

#if defined(WT_LENONE)
		if (parity) {
			lptr2 = &a[0];
			//lptr2[0] >>= 1;
			lptr2[0] = jpc_fix_asr(lptr2[0], 1);
			++lptr2;
		}
#endif

	}

----------------------------------------------------------------------------------
	if (maxcols < numcols) {
		jpc_qmfb_split_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
		jpc_ns_fwdlift_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
	}

----------------------------------------------------------------------------------
	if (maxcols < numcols) {
		jpc_ns_invlift_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
		jpc_qmfb_join_colres(startptr, numrows, numcols - maxcols, stride,
		  rowparity);
	}

----------------------------------------------------------------------------------
	if ((cp = strtok(buf, delim))) {
		++n;
		while ((cp = strtok(0, delim))) {
			if (cp != '\0') {
				++n;
			}
		}
	}

----------------------------------------------------------------------------------
	if (n) {
		if (!(vs = jas_alloc2(n, sizeof(double)))) {
			return -1;
		}

		strncpy(buf, s, sizeof(buf));
		buf[sizeof(buf) - 1] = '\0';
		n = 0;
		if ((cp = strtok(buf, delim))) {
			vs[n] = atof(cp);
			++n;
			while ((cp = strtok(0, delim))) {
				if (cp != '\0') {
					vs[n] = atof(cp);
					++n;
				}
			}
		}
	} else {
		vs = 0;
	}

----------------------------------------------------------------------------------
	if (!(z = jas_seq_create(jas_seq_start(x) * m, (jas_seq_end(x) - 1) * m + 1)))
		return 0;

----------------------------------------------------------------------------------
			if (k < jas_seq_start(x) || k >= jas_seq_end(x)) {
				v = JPC_FIX_ZERO;
			} else {
				v = jas_seq_get(x, k);
			}

----------------------------------------------------------------------------------
	if (!(tsfb = malloc(sizeof(jpc_tsfb_t))))
		return 0;

----------------------------------------------------------------------------------
	if (numlvls > 0) {
		switch (qmfbid) {
		case JPC_COX_INS:
			tsfb->qmfb = &jpc_ns_qmfb2d;
			break;
		default:
		case JPC_COX_RFT:
			tsfb->qmfb = &jpc_ft_qmfb2d;
			break;
		}
	} else {
		tsfb->qmfb = 0;
	}

----------------------------------------------------------------------------------
	if (width > 0 && height > 0) {
		if ((*tsfb->qmfb->analyze)(a, xstart, ystart, width, height, stride))
			return -1;
		if (numlvls > 0) {
			if (jpc_tsfb_analyze2(tsfb, a, JPC_CEILDIVPOW2(xstart,
			  1), JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(
			  xstart + width, 1) - JPC_CEILDIVPOW2(xstart, 1),
			  JPC_CEILDIVPOW2(ystart + height, 1) -
			  JPC_CEILDIVPOW2(ystart, 1), stride, numlvls - 1)) {
				return -1;
			}
		}
	}

----------------------------------------------------------------------------------
	if (numlvls > 0) {
		if (jpc_tsfb_synthesize2(tsfb, a, JPC_CEILDIVPOW2(xstart, 1),
		  JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(xstart + width,
		  1) - JPC_CEILDIVPOW2(xstart, 1), JPC_CEILDIVPOW2(ystart +
		  height, 1) - JPC_CEILDIVPOW2(ystart, 1), stride, numlvls -
		  1)) {
			return -1;
		}
	}

----------------------------------------------------------------------------------
	if (width > 0 && height > 0) {
		if ((*tsfb->qmfb->synthesize)(a, xstart, ystart, width, height, stride)) {
			return -1;
		}
	}

----------------------------------------------------------------------------------
	if (tsfb->numlvls > 0) {
		jpc_tsfb_getbands2(tsfb, xstart, ystart, xstart, ystart, xend, yend,
		  &band, tsfb->numlvls);
	} else {

		band->xstart = xstart;
		band->ystart = ystart;
		band->xend = xend;
		band->yend = yend;
		band->locxstart = xstart;
		band->locystart = ystart;
		band->locxend = band->locxstart + band->xend - band->xstart;
		band->locyend = band->locystart + band->yend - band->ystart;
		band->orient = JPC_TSFB_LL;
		band->synenergywt = JPC_FIX_ONE;
		++band;
	}

----------------------------------------------------------------------------------
	if (numlvls > 0) {

		jpc_tsfb_getbands2(tsfb, locxstart, locystart, newxstart, newystart,
		  newxend, newyend, bands, numlvls - 1);

		band = *bands;
		band->xstart = JPC_FLOORDIVPOW2(xstart, 1);
		band->ystart = newystart;
		band->xend = JPC_FLOORDIVPOW2(xend, 1);
		band->yend = newyend;
		band->locxstart = locxstart + newxend - newxstart;
		band->locystart = locystart;
		band->locxend = band->locxstart + band->xend - band->xstart;
		band->locyend = band->locystart + band->yend - band->ystart;
		band->orient = JPC_TSFB_HL;
		band->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[
		  tsfb->numlvls - numlvls] * tsfb->qmfb->lpenergywts[
		  tsfb->numlvls - numlvls]);
		++(*bands);

		band = *bands;
		band->xstart = newxstart;
		band->ystart = JPC_FLOORDIVPOW2(ystart, 1);
		band->xend = newxend;
		band->yend = JPC_FLOORDIVPOW2(yend, 1);
		band->locxstart = locxstart;
		band->locystart = locystart + newyend - newystart;
		band->locxend = band->locxstart + band->xend - band->xstart;
		band->locyend = band->locystart + band->yend - band->ystart;
		band->orient = JPC_TSFB_LH;
		band->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[
		  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[
		  tsfb->numlvls - numlvls]);
		++(*bands);

		band = *bands;
		band->xstart = JPC_FLOORDIVPOW2(xstart, 1);
		band->ystart = JPC_FLOORDIVPOW2(ystart, 1);
		band->xend = JPC_FLOORDIVPOW2(xend, 1);
		band->yend = JPC_FLOORDIVPOW2(yend, 1);
		band->locxstart = locxstart + newxend - newxstart;
		band->locystart = locystart + newyend - newystart;
		band->locxend = band->locxstart + band->xend - band->xstart;
		band->locyend = band->locystart + band->yend - band->ystart;
		band->orient = JPC_TSFB_HH;
		band->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[
		  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[
		  tsfb->numlvls - numlvls]);
		++(*bands);

	} else {

		band = *bands;
		band->xstart = xstart;
		band->ystart = ystart;
		band->xend = xend;
		band->yend = yend;
		band->locxstart = locxstart;
		band->locystart = locystart;
		band->locxend = band->locxstart + band->xend - band->xstart;
		band->locyend = band->locystart + band->yend - band->ystart;
		band->orient = JPC_TSFB_LL;
		band->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[
		  tsfb->numlvls - numlvls - 1] * tsfb->qmfb->lpenergywts[
		  tsfb->numlvls - numlvls - 1]);
		++(*bands);

	}

----------------------------------------------------------------------------------
			if (!lvl->bands) {
				continue;
			}

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;
				}

----------------------------------------------------------------------------------
					if (!prc->cblks) {
						continue;
					}

----------------------------------------------------------------------------------
								if (v > mx) {
									mx = v;
								}

----------------------------------------------------------------------------------
						if (mx > bmx) {
							bmx = mx;
						}

----------------------------------------------------------------------------------
						if (jpc_enc_enccblk(enc, cblk->stream, tcmpt, band, cblk)) {
							return -1;
						}

----------------------------------------------------------------------------------
	if (cblk->numpasses > 0) {
		cblk->passes = jas_alloc2(cblk->numpasses, sizeof(jpc_enc_pass_t));
		assert(cblk->passes);
	} else {
		cblk->passes = 0;
	}

----------------------------------------------------------------------------------
if (pass == endpasses - 1) {
assert(pass->term == 1);
	pass->term = 1;
}

----------------------------------------------------------------------------------
		if (pass->type == JPC_SEG_MQ) {
			/* NOP */
		} else {
			assert(pass->type == JPC_SEG_RAW);
			if (!bout) {
				bout = jpc_bitstream_sopen(cblk->stream, "w");
				assert(bout);
			}
		}

----------------------------------------------------------------------------------
		if (pass->term) {
			termmode = ((tcmpt->cblksty & JPC_COX_PTERM) ?
			  JPC_MQENC_PTERM : JPC_MQENC_DEFTERM) + 1;
		} else {
			termmode = 0;
		}

----------------------------------------------------------------------------------
		switch (passtype) {
		case JPC_SIGPASS:
			ret = (pass->type == JPC_SEG_MQ) ? jpc_encsigpass(cblk->mqenc,
			  bitpos, band->orient, vcausal, cblk->flags,
			  cblk->data, termmode, &pass->nmsedec) :
			  jpc_encrawsigpass(bout, bitpos, vcausal, cblk->flags,
			  cblk->data, termmode, &pass->nmsedec);
			break;
		case JPC_REFPASS:
			ret = (pass->type == JPC_SEG_MQ) ? jpc_encrefpass(cblk->mqenc,
			  bitpos, vcausal, cblk->flags, cblk->data, termmode,
			  &pass->nmsedec) : jpc_encrawrefpass(bout, bitpos,
			  vcausal, cblk->flags, cblk->data, termmode,
			  &pass->nmsedec);
			break;
		case JPC_CLNPASS:
			assert(pass->type == JPC_SEG_MQ);
			ret = jpc_encclnpass(cblk->mqenc, bitpos, band->orient,
			  vcausal, segsym, cblk->flags, cblk->data, termmode,
			  &pass->nmsedec);
			break;
		default:
			assert(0);
			break;
		}

----------------------------------------------------------------------------------
		if (pass->type == JPC_SEG_MQ) {
			if (pass->term) {
				jpc_mqenc_init(cblk->mqenc);
			}
			jpc_mqenc_getstate(cblk->mqenc, &pass->mqencstate);
			pass->end = jas_stream_tell(cblk->stream);
			if (tcmpt->cblksty & JPC_COX_RESET) {
				jpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);
			}
		} else {
			if (pass->term) {
				if (jpc_bitstream_pending(bout)) {
					jpc_bitstream_outalign(bout, 0x2a);
				}
				jpc_bitstream_close(bout);
				bout = 0;
				pass->end = jas_stream_tell(cblk->stream);
			} else {
				pass->end = jas_stream_tell(cblk->stream) +
				  jpc_bitstream_pending(bout);
/* NOTE - This will not work.  need to adjust by # of pending output bytes */
			}
		}

----------------------------------------------------------------------------------
		if (pass != cblk->passes) {
			pass->cumwmsedec += pass[-1].cumwmsedec;
		}

----------------------------------------------------------------------------------
		if (passtype == JPC_CLNPASS) {
			--bitpos;
		}

----------------------------------------------------------------------------------
		if (pass->start < n) {
			pass->start = n;
		}

----------------------------------------------------------------------------------
		if (pass->end < n) {
			pass->end = n;
		}

----------------------------------------------------------------------------------
		if (!pass->term) {
			termpass = pass;
			while (termpass - pass < cblk->numpasses &&
			  !termpass->term) {
				++termpass;
			}
			if (pass->type == JPC_SEG_MQ) {
				t = (pass->mqencstate.lastbyte == 0xff) ? 1 : 0;
				if (pass->mqencstate.ctreg >= 5) {
					adjust = 4 + t;
				} else {
					adjust = 5 + t;
				}
				pass->end += adjust;
			}
			if (pass->end > termpass->end) {
				pass->end = termpass->end;
			}
			if ((c = getthebyte(cblk->stream, pass->end - 1)) == EOF) {
				abort();
			}
			if (c == 0xff) {
				++pass->end;
			}
			n = JAS_MAX(n, pass->end);
		} else {
			n = JAS_MAX(n, pass->end);
		}

----------------------------------------------------------------------------------
	if (bout) {
		jpc_bitstream_close(bout);
	}

----------------------------------------------------------------------------------
	if ((f & JPC_OTHSIGMSK) && !(f & (JPC_SIG | JPC_VISIT))) { \
		v = (JAS_ABS(*(dp)) & (one)) ? 1 : 0; \
		jpc_mqenc_setcurctx(mqenc, JPC_GETZCCTXNO(f, (orient))); \
		jpc_mqenc_putbit(mqenc, v); \
		if (v) { \
			*(nmsedec) += JPC_GETSIGNMSEDEC(JAS_ABS(*(dp)), (bitpos) + JPC_NUMEXTRABITS); \
			v = ((*(dp) < 0) ? 1 : 0); \
			jpc_mqenc_setcurctx(mqenc, JPC_GETSCCTXNO(f)); \
			jpc_mqenc_putbit(mqenc, v ^ JPC_GETSPB(f)); \
			JPC_UPDATEFLAGS4(fp, frowstep, v, vcausalflag); \
			*(fp) |= JPC_SIG; \
		} \
		*(fp) |= JPC_VISIT; \
	} \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
	if (term) {
		jpc_mqenc_flush(mqenc, term - 1);
	}

----------------------------------------------------------------------------------
	if ((f & JPC_OTHSIGMSK) && !(f & (JPC_SIG | JPC_VISIT))) { \
		v = (JAS_ABS(*(dp)) & (one)) ? 1 : 0; \
		if ((jpc_bitstream_putbit((out), v)) == EOF) { \
			return -1; \
		} \
		if (v) { \
			*(nmsedec) += JPC_GETSIGNMSEDEC(JAS_ABS(*(dp)), (bitpos) + JPC_NUMEXTRABITS); \
			v = ((*(dp) < 0) ? 1 : 0); \
			if (jpc_bitstream_putbit(out, v) == EOF) { \
				return -1; \
			} \
			JPC_UPDATEFLAGS4(fp, frowstep, v, vcausalflag); \
			*(fp) |= JPC_SIG; \
		} \
		*(fp) |= JPC_VISIT; \
	} \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
	if (term) {
		jpc_bitstream_outalign(out, 0x2a);
	}

----------------------------------------------------------------------------------
	if (((*(fp)) & (JPC_SIG | JPC_VISIT)) == JPC_SIG) { \
		(d) = *(dp); \
		*(nmsedec) += JPC_GETREFNMSEDEC(JAS_ABS(d), (bitpos) + JPC_NUMEXTRABITS); \
		jpc_mqenc_setcurctx((mqenc), JPC_GETMAGCTXNO(*(fp))); \
		v = (JAS_ABS(d) & (one)) ? 1 : 0; \
		jpc_mqenc_putbit((mqenc), v); \
		*(fp) |= JPC_REFINE; \
	} \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
	if (term) {
		jpc_mqenc_flush(mqenc, term - 1);
	}

----------------------------------------------------------------------------------
	if (((*(fp)) & (JPC_SIG | JPC_VISIT)) == JPC_SIG) { \
		d = *(dp); \
		*(nmsedec) += JPC_GETREFNMSEDEC(JAS_ABS(d), (bitpos) + JPC_NUMEXTRABITS); \
		v = (JAS_ABS(d) & (one)) ? 1 : 0; \
		if (jpc_bitstream_putbit((out), v) == EOF) { \
			return -1; \
		} \
		*(fp) |= JPC_REFINE; \
	} \

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;
			}

----------------------------------------------------------------------------------
	if (term) {
		jpc_bitstream_outalign(out, 0x2a);
	}

----------------------------------------------------------------------------------
	if (!(f & (JPC_SIG | JPC_VISIT))) { \
		jpc_mqenc_setcurctx(mqenc, JPC_GETZCCTXNO(f, (orient))); \
		v = (JAS_ABS(*(dp)) & (one)) ? 1 : 0; \
		jpc_mqenc_putbit((mqenc), v); \
		if (v) { \
label2 \
			f = *(fp); \
			/* Coefficient is significant. */ \
			*(nmsedec) += JPC_GETSIGNMSEDEC(JAS_ABS(*(dp)), (bitpos) + JPC_NUMEXTRABITS); \
			jpc_mqenc_setcurctx((mqenc), JPC_GETSCCTXNO(f)); \
			v = ((*(dp) < 0) ? 1 : 0); \
			jpc_mqenc_putbit((mqenc), v ^ JPC_GETSPB(f)); \
			JPC_UPDATEFLAGS4((fp), (frowstep), v, vcausalflag); \
			*(fp) |= JPC_SIG; \
		} \
	} \

----------------------------------------------------------------------------------
			if (vscanlen >= 4 && !((*fp) & (JPC_SIG | JPC_VISIT |
			  JPC_OTHSIGMSK)) && (fp += frowstep, !((*fp) & (JPC_SIG |
			  JPC_VISIT | JPC_OTHSIGMSK))) && (fp += frowstep, !((*fp) &
			  (JPC_SIG | JPC_VISIT | JPC_OTHSIGMSK))) && (fp += frowstep,
			  !((*fp) & (JPC_SIG | JPC_VISIT | JPC_OTHSIGMSK)))) {
				dp = dvscanstart;
				for (k = 0; k < vscanlen; ++k) {

----------------------------------------------------------------------------------
					if (v) {
						break;
					}

----------------------------------------------------------------------------------
				if (runlen >= 4) {
					jpc_mqenc_setcurctx(mqenc, JPC_AGGCTXNO);

----------------------------------------------------------------------------------
				switch (runlen) {
				case 0:
					goto clnpass_partial0;
					break;
				case 1:
					goto clnpass_partial1;
					break;
				case 2:
					goto clnpass_partial2;
					break;
				case 3:
					goto clnpass_partial3;
					break;
				}

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
			if (--k <= 0) {
				continue;

----------------------------------------------------------------------------------
	if (segsymflag) {
		jpc_mqenc_setcurctx(mqenc, JPC_UCTXNO);

----------------------------------------------------------------------------------
	if (term) {
		jpc_mqenc_flush(mqenc, term - 1);

----------------------------------------------------------------------------------
	if (!(opts = jpc_dec_opts_create(optstr))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(dec = jpc_dec_create(opts, in))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jpc_dec_decode(dec)) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (jas_image_numcmpts(dec->image) >= 3) {
		jas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(dec->image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(dec->image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(dec->image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(dec->image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}

----------------------------------------------------------------------------------
	if (opts) {
		jpc_dec_opts_destroy(opts);
	}

----------------------------------------------------------------------------------
	if (dec) {
		jpc_dec_destroy(dec);
	}

----------------------------------------------------------------------------------
	if (!(opts = jas_malloc(sizeof(jpc_dec_importopts_t)))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) {
		goto error;
	}

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_MAXLYRS:
			opts->maxlyrs = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_DEBUG:
			opts->debug = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_MAXPKTS:
			opts->maxpkts = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_MAXSAMPLES:
			opts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);
			break;
		default:
			jas_eprintf("warning: ignoring invalid option %s\n",
			  jas_tvparser_gettag(tvp));
			break;
		}

----------------------------------------------------------------------------------
	if (opts) {
		jpc_dec_opts_destroy(opts);
	}

----------------------------------------------------------------------------------
		if (mstabent->id == id) {
			break;
		}

----------------------------------------------------------------------------------
	if (!(cstate = jpc_cstate_create())) {
		return -1;
	}

----------------------------------------------------------------------------------
		if (!(ms = jpc_getms(dec->in, cstate))) {
			jas_eprintf("cannot get marker segment\n");
			return -1;
		}

----------------------------------------------------------------------------------
		if (!(dec->state & mstabent->validstates)) {
			jas_eprintf("unexpected marker segment type\n");
			jpc_ms_destroy(ms);
			return -1;
		}

----------------------------------------------------------------------------------
		if (mstabent->action) {
			ret = (*mstabent->action)(dec, ms);
		} else {
			/* No explicit action is required. */
			ret = 0;
		}

----------------------------------------------------------------------------------
		if (ret < 0) {
			return -1;
		} else if (ret > 0) {
			break;
		}

----------------------------------------------------------------------------------
	if (dec->state == JPC_MH) {

		if (!(compinfos = jas_alloc2(dec->numcomps,
		  sizeof(jas_image_cmptparm_t)))) {
			abort();
		}
		for (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;
		  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {
			compinfo->tlx = 0;
			compinfo->tly = 0;
			compinfo->prec = cmpt->prec;
			compinfo->sgnd = cmpt->sgnd;
			compinfo->width = cmpt->width;
			compinfo->height = cmpt->height;
			compinfo->hstep = cmpt->hstep;
			compinfo->vstep = cmpt->vstep;
		}

		if (!(dec->image = jas_image_create(dec->numcomps, compinfos,
		  JAS_CLRSPC_UNKNOWN))) {
			jas_free(compinfos);
			return -1;
		}
		jas_free(compinfos);

		/* Is the packet header information stored in PPM marker segments in
		  the main header? */
		if (dec->ppmstab) {
			/* Convert the PPM marker segment data into a collection of streams
			  (one stream per tile-part). */
			if (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {
				abort();
			}
			jpc_ppxstab_destroy(dec->ppmstab);
			dec->ppmstab = 0;
		}
	}

----------------------------------------------------------------------------------
	if (sot->len > 0) {
		dec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -
		  4 + sot->len;
	} else {
		dec->curtileendoff = 0;
	}

----------------------------------------------------------------------------------
	if (JAS_CAST(int, sot->tileno) >= dec->numtiles) {
		jas_eprintf("invalid tile number in SOT marker segment\n");
		return -1;
	}

----------------------------------------------------------------------------------
	if (sot->partno != tile->partno) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (tile->numparts > 0 && sot->partno >= tile->numparts) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!tile->numparts && sot->numparts > 0) {
		tile->numparts = sot->numparts;
	}

----------------------------------------------------------------------------------
	switch (tile->state) {
	case JPC_TILE_INIT:
		/* This is the first tile-part for this tile. */
		tile->state = JPC_TILE_ACTIVE;
		assert(!tile->cp);
		if (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {
			return -1;
		}
		jpc_dec_cp_resetflags(dec->cp);
		break;
	default:
		if (sot->numparts == sot->partno - 1) {
			tile->state = JPC_TILE_ACTIVELAST;
		}
		break;
	}

----------------------------------------------------------------------------------
	if (!(tile = dec->curtile)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!tile->partno) {
		if (!jpc_dec_cp_isvalid(tile->cp)) {
			return -1;
		}
		jpc_dec_cp_prepare(tile->cp);
		if (jpc_dec_tileinit(dec, tile)) {
			return -1;
		}
	}

----------------------------------------------------------------------------------
	if (dec->pkthdrstreams) {
		/* Get the stream containing the packet header data for this
		  tile-part. */
		if (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {
			return -1;
		}
	}

----------------------------------------------------------------------------------
	if (tile->pptstab) {
		if (!tile->pkthdrstream) {
			if (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {
				return -1;
			}
		}
		pos = jas_stream_tell(tile->pkthdrstream);
		jas_stream_seek(tile->pkthdrstream, 0, SEEK_END);
		if (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {
			return -1;
		}
		jas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);
		jpc_ppxstab_destroy(tile->pptstab);
		tile->pptstab = 0;
	}

----------------------------------------------------------------------------------
	if (jas_getdbglevel() >= 10) {
		jpc_dec_dump(dec, stderr);
	}

----------------------------------------------------------------------------------
	if (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :
	  dec->in, dec->in)) {
		jas_eprintf("jpc_dec_decodepkts failed\n");
		return -1;

----------------------------------------------------------------------------------
	if (dec->curtileendoff > 0) {
		long curoff;

----------------------------------------------------------------------------------
		if (curoff < dec->curtileendoff) {
			n = dec->curtileendoff - curoff;

----------------------------------------------------------------------------------
				if (jas_stream_getc(dec->in) == EOF) {
					jas_eprintf("read error\n");

----------------------------------------------------------------------------------
	if (tile->numparts > 0 && tile->partno == tile->numparts - 1) {
		if (jpc_dec_tiledecode(dec, tile)) {

----------------------------------------------------------------------------------
	if (cp->mctid == JPC_MCT_ICT) {
		tile->realmode = 1;
	}

----------------------------------------------------------------------------------
		if (ccp->qmfbid == JPC_COX_INS) {
			tile->realmode = 1;

----------------------------------------------------------------------------------
		if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,
		  sizeof(jpc_dec_rlvl_t)))) {

----------------------------------------------------------------------------------
		if (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,
		  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),
		  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,
		  cmpt->vstep)))) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,
		  tcomp->numrlvls - 1))) {

----------------------------------------------------------------------------------
			if (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {
				rlvl->bands = 0;
				rlvl->numprcs = 0;

----------------------------------------------------------------------------------
			if (!rlvlno) {
				tlcbgxstart = tlprcxstart;

----------------------------------------------------------------------------------
			if (!(rlvl->bands = jas_alloc2(rlvl->numbands,
			  sizeof(jpc_dec_band_t)))) {

----------------------------------------------------------------------------------
				if (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {
					continue;
				}

----------------------------------------------------------------------------------
				if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {
					return -1;

----------------------------------------------------------------------------------
				if (!(band->prcs = jas_alloc2(rlvl->numprcs,
				  sizeof(jpc_dec_prc_t)))) {

----------------------------------------------------------------------------------
					if (prc->xend > prc->xstart && prc->yend > prc->ystart) {
						tlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,
						  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;
						tlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,

----------------------------------------------------------------------------------
						if (!(prc->incltagtree = jpc_tagtree_create(
						  prc->numhcblks, prc->numvcblks))) {
							return -1;
						}

----------------------------------------------------------------------------------
						if (!(prc->numimsbstagtree = jpc_tagtree_create(
						  prc->numhcblks, prc->numvcblks))) {

----------------------------------------------------------------------------------
						if (!(prc->cblks = jas_alloc2(prc->numcblks,
						  sizeof(jpc_dec_cblk_t)))) {
							return -1;
						}

----------------------------------------------------------------------------------
							if (tmpxend > tmpxstart && tmpyend > tmpystart) {
								cblk->firstpassno = -1;

----------------------------------------------------------------------------------
								if (!(cblk->data = jas_seq2d_create(0, 0, 0,
								  0))) {

----------------------------------------------------------------------------------
							if (cblkxstart >= cbgxend) {
								cblkxstart = cbgxstart;
								cblkystart += 1 << rlvl->cblkheightexpn;

----------------------------------------------------------------------------------
					if (cbgxstart >= brcbgxend) {
						cbgxstart = tlcbgxstart;

----------------------------------------------------------------------------------
	if (!(tile->pi = jpc_dec_pi_create(dec, tile))) {
		return -1;

----------------------------------------------------------------------------------
	if (tile->tcomps) {


----------------------------------------------------------------------------------
				if (!rlvl->bands) {
					continue;

----------------------------------------------------------------------------------
					if (band->prcs) {
						for (prcno = 0, prc = band->prcs; prcno <

----------------------------------------------------------------------------------
							if (!prc->cblks) {
								continue;
							}

----------------------------------------------------------------------------------
								if (cblk->mqdec) {
									jpc_mqdec_destroy(cblk->mqdec);

----------------------------------------------------------------------------------
								if (cblk->nulldec) {
									jpc_bitstream_close(cblk->nulldec);

----------------------------------------------------------------------------------
								if (cblk->flags) {
									jas_matrix_destroy(cblk->flags);

----------------------------------------------------------------------------------
							if (prc->incltagtree) {
								jpc_tagtree_destroy(prc->incltagtree);

----------------------------------------------------------------------------------
							if (prc->numimsbstagtree) {
								jpc_tagtree_destroy(prc->numimsbstagtree);

----------------------------------------------------------------------------------
							if (prc->cblks) {
								jas_free(prc->cblks);

----------------------------------------------------------------------------------
					if (band->data) {
						jas_matrix_destroy(band->data);

----------------------------------------------------------------------------------
					if (band->prcs) {
						jas_free(band->prcs);

----------------------------------------------------------------------------------
				if (rlvl->bands) {
					jas_free(rlvl->bands);

----------------------------------------------------------------------------------
			if (tcomp->rlvls) {
				jas_free(tcomp->rlvls);

----------------------------------------------------------------------------------
			if (tcomp->data) {
				jas_matrix_destroy(tcomp->data);

----------------------------------------------------------------------------------
			if (tcomp->tsfb) {
				jpc_tsfb_destroy(tcomp->tsfb);

----------------------------------------------------------------------------------
	if (tile->cp) {
		jpc_dec_cp_destroy(tile->cp);

----------------------------------------------------------------------------------
	if (tile->tcomps) {
		jas_free(tile->tcomps);

----------------------------------------------------------------------------------
	if (tile->pi) {
		jpc_pi_destroy(tile->pi);

----------------------------------------------------------------------------------
	if (tile->pkthdrstream) {
		jas_stream_close(tile->pkthdrstream);

----------------------------------------------------------------------------------
	if (tile->pptstab) {
		jpc_ppxstab_destroy(tile->pptstab);

----------------------------------------------------------------------------------
	if (jpc_dec_decodecblks(dec, tile)) {
		jas_eprintf("jpc_dec_decodecblks failed\n");

----------------------------------------------------------------------------------
			if (!rlvl->bands) {
				continue;

----------------------------------------------------------------------------------
				if (!band->data) {
					continue;

----------------------------------------------------------------------------------
				if (tile->realmode) {
					jas_matrix_asl(band->data, JPC_FIX_FRACBITS);

----------------------------------------------------------------------------------
	switch (tile->cp->mctid) {
	case JPC_MCT_RCT:
		if (dec->numcomps < 3) {
			jas_eprintf("RCT requires at least three components\n");
			return -1;
		}
		if (!jas_image_cmpt_domains_same(dec->image)) {
			jas_eprintf("RCT requires all components have the same domain\n");
			return -1;
		}
		jpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,
		  tile->tcomps[2].data);
		break;
	case JPC_MCT_ICT:
		if (dec->numcomps < 3) {
			jas_eprintf("ICT requires at least three components\n");
			return -1;
		}
		if (!jas_image_cmpt_domains_same(dec->image)) {
			jas_eprintf("RCT requires all components have the same domain\n");
			return -1;
		}
		jpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,
		  tile->tcomps[2].data);
		break;
	}

----------------------------------------------------------------------------------
	if (tile->realmode) {
		for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;

----------------------------------------------------------------------------------
		if (jas_image_writecmpt(dec->image, compno, tcomp->xstart -
		  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -
		  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(
		  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {
			jas_eprintf("write component failed\n");
			return -1;

----------------------------------------------------------------------------------
		if (tile->state == JPC_TILE_ACTIVE) {
			if (jpc_dec_tiledecode(dec, tile)) {

----------------------------------------------------------------------------------
		if (tile->state != JPC_TILE_DONE) {
			jpc_dec_tilefini(dec, tile);
		}

----------------------------------------------------------------------------------
	if (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {
		return -1;

----------------------------------------------------------------------------------
	if (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (!jas_safe_size_mul(cmpt->width, cmpt->height, &num_samples_delta)) {
			jas_eprintf("image too large\n");

----------------------------------------------------------------------------------
		if (!jas_safe_size_add(num_samples, num_samples_delta, &num_samples)) {
			jas_eprintf("image too large\n");

----------------------------------------------------------------------------------
	if (dec->max_samples > 0 && num_samples > dec->max_samples) {
		jas_eprintf("maximum number of samples exceeded (%zu > %zu)\n",

----------------------------------------------------------------------------------
	if (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {
		return -1;

----------------------------------------------------------------------------------
		if (!(tile->tcomps = jas_alloc2(dec->numcomps,
		  sizeof(jpc_dec_tcomp_t)))) {

----------------------------------------------------------------------------------
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcod(dec->cp, cod);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno != 0) {
			return -1;
		}
		jpc_dec_cp_setfromcod(tile->cp, cod);
		break;
	}

----------------------------------------------------------------------------------
	if (JAS_CAST(int, coc->compno) >= dec->numcomps) {
		jas_eprintf("invalid component number in COC marker segment\n");
		return -1;

----------------------------------------------------------------------------------
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}

----------------------------------------------------------------------------------
	if (JAS_CAST(int, rgn->compno) >= dec->numcomps) {
		jas_eprintf("invalid component number in RGN marker segment\n");

----------------------------------------------------------------------------------
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromrgn(dec->cp, rgn);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromrgn(tile->cp, rgn);
		break;
	}

----------------------------------------------------------------------------------
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcd(dec->cp, qcd);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcd(tile->cp, qcd);
		break;
	}

----------------------------------------------------------------------------------
	if (JAS_CAST(int, qcc->compno) >= dec->numcomps) {
		jas_eprintf("invalid component number in QCC marker segment\n");

----------------------------------------------------------------------------------
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}

----------------------------------------------------------------------------------
	switch (dec->state) {
	case JPC_MH:
		if (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {
			return -1;
		}
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (!tile->partno) {
			if (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {
				return -1;
			}
		} else {
			jpc_pi_addpchgfrompoc(tile->pi, poc);
		}
		break;
	}

----------------------------------------------------------------------------------
	if (!dec->ppmstab) {
		if (!(dec->ppmstab = jpc_ppxstab_create())) {

----------------------------------------------------------------------------------
	if (!(ppmstabent = jpc_ppxstabent_create())) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {
		return -1;

----------------------------------------------------------------------------------
	if (!tile->pptstab) {
		if (!(tile->pptstab = jpc_ppxstab_create())) {

----------------------------------------------------------------------------------
	if (!(pptstabent = jpc_ppxstabent_create())) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {
		return -1;

----------------------------------------------------------------------------------
	if (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {
		goto error;

----------------------------------------------------------------------------------
	if (!(cp->pchglist = jpc_pchglist_create())) {
		goto error;

----------------------------------------------------------------------------------
	if (cp) {
		jpc_dec_cp_destroy(cp);

----------------------------------------------------------------------------------
	if (!(newcp = jpc_dec_cp_create(cp->numcomps))) {
		return 0;

----------------------------------------------------------------------------------
	if (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {
		jas_free(newcp);

----------------------------------------------------------------------------------
	if (cp->ccps) {
		jas_free(cp->ccps);

----------------------------------------------------------------------------------
	if (cp->pchglist) {
		jpc_pchglist_destroy(cp->pchglist);

----------------------------------------------------------------------------------
	if (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {
		return 0;

----------------------------------------------------------------------------------
		if ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *
		  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&

----------------------------------------------------------------------------------
		if (!(ccp->csty & JPC_COX_PRT)) {
			for (i = 0; i < JPC_MAXRLVLS; ++i) {
				ccp->prcwidthexpns[i] = 15;
				ccp->prcheightexpns[i] = 15;

----------------------------------------------------------------------------------
		if (ccp->qsty == JPC_QCX_SIQNT) {
			calcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);

----------------------------------------------------------------------------------
	if (cod->mctrans) {
		cp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);

----------------------------------------------------------------------------------
	if ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {
		ccp->numrlvls = compparms->numdlvls + 1;

----------------------------------------------------------------------------------
	if ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {
		ccp->flags |= flags | JPC_QSET;

----------------------------------------------------------------------------------
		if (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {
			return -1;

----------------------------------------------------------------------------------
		if (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {
			return -1;

----------------------------------------------------------------------------------
	if (reset) {
		while (jpc_pchglist_numpchgs(cp->pchglist) > 0) {

----------------------------------------------------------------------------------
		if (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {
			return -1;

----------------------------------------------------------------------------------
	if (absstepsize == jpc_inttofix(1)) {
		return;

----------------------------------------------------------------------------------
			if (t) {
				t = jpc_fix_mul(t, absstepsize);

----------------------------------------------------------------------------------
	if (roishift < 0) {
		/* We could instead return an error here. */

----------------------------------------------------------------------------------
	if (roishift == 0 && bgshift == 0) {
		return;

----------------------------------------------------------------------------------
			if (mag >= thresh) {
				/* We are dealing with ROI data. */

----------------------------------------------------------------------------------
				if (mag & (~mask)) {
					if (!warn) {

----------------------------------------------------------------------------------
	if (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);

----------------------------------------------------------------------------------
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);

----------------------------------------------------------------------------------
	if (dec->image) {
		jas_image_destroy(dec->image);

----------------------------------------------------------------------------------
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);

----------------------------------------------------------------------------------
	if (dec->cmpts) {
		jas_free(dec->cmpts);

----------------------------------------------------------------------------------
	if (dec->tiles) {
		jas_free(dec->tiles);

----------------------------------------------------------------------------------
	if (prev) {
		prev->next = node;

----------------------------------------------------------------------------------
	if (next) {
		next->prev = node;

----------------------------------------------------------------------------------
	if (prev) {
		prev->next = next;

----------------------------------------------------------------------------------
	if (next) {
		next->prev = prev;

----------------------------------------------------------------------------------
	if (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (seg->stream) {
		jas_stream_close(seg->stream);

----------------------------------------------------------------------------------
					if (!band->data) {
						fprintf(out, "band has no data (null pointer)\n");

----------------------------------------------------------------------------------
	if (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,
	  sizeof(jas_stream_t *)))) {

----------------------------------------------------------------------------------
	if (streamlist->numstreams >= streamlist->maxstreams) {
		newmaxstreams = streamlist->maxstreams + 1024;
		if (!(newstreams = jas_realloc2(streamlist->streams,

----------------------------------------------------------------------------------
	if (streamno != streamlist->numstreams) {
		/* Can only handle insertion at start of list. */
		return -1;

----------------------------------------------------------------------------------
	if (streamno >= streamlist->numstreams) {
		abort();

----------------------------------------------------------------------------------
	if (streamlist->streams) {
		for (streamno = 0; streamno < streamlist->numstreams;

----------------------------------------------------------------------------------
	if (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (tab->ents) {
		jas_free(tab->ents);

----------------------------------------------------------------------------------
	if (tab->maxents < maxents) {
		newents = (tab->ents) ? jas_realloc2(tab->ents, maxents,

----------------------------------------------------------------------------------
		if (!newents) {
			return -1;
		}

----------------------------------------------------------------------------------
		if (tab->ents[i]->ind > ent->ind) {
			break;

----------------------------------------------------------------------------------
	if (tab->numents >= tab->maxents) {
		if (jpc_ppxstab_grow(tab, tab->maxents + 128)) {

----------------------------------------------------------------------------------
	if (!(streams = jpc_streamlist_create())) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!tab->numents) {
		return streams;

----------------------------------------------------------------------------------
		if (datacnt < 4) {
			goto error;

----------------------------------------------------------------------------------
		if (!(stream = jas_stream_memopen(0, 0))) {
			goto error;

----------------------------------------------------------------------------------
		if (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),
		  stream)) {

----------------------------------------------------------------------------------
			if (!datacnt) {
				if (++entno >= tab->numents) {
					goto error;
				}
				ent = tab->ents[entno];

----------------------------------------------------------------------------------
			if (jas_stream_write(stream, dataptr, n) != n) {
				goto error;

----------------------------------------------------------------------------------
		if (!datacnt) {
			if (++entno >= tab->numents) {

----------------------------------------------------------------------------------
	if (streams) {
		jpc_streamlist_destroy(streams);
	}

----------------------------------------------------------------------------------
		if (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {
			return -1;

----------------------------------------------------------------------------------
	if (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (ent->data) {
		jas_free(ent->data);

----------------------------------------------------------------------------------
	if (!(hdr = mif_hdr_get(in))) {
		goto error;
	}

----------------------------------------------------------------------------------
	if (!(image = jas_image_create0())) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (!tmpstream) {
			jas_eprintf("cannot open component file %s\n", cmpt->data);
			goto error;
		}

----------------------------------------------------------------------------------
		if (!(tmpimage = jas_image_decode(tmpstream, -1, "allow_trunc=1"))) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (tmpstream != in) {
			jas_stream_close(tmpstream);
			tmpstream = 0;
		}

----------------------------------------------------------------------------------
		if (!cmpt->width) {
			cmpt->width = jas_image_cmptwidth(tmpimage, 0);
		}

----------------------------------------------------------------------------------
		if (!cmpt->height) {
			cmpt->height = jas_image_cmptwidth(tmpimage, 0);
		}

----------------------------------------------------------------------------------
		if (!cmpt->prec) {
			cmpt->prec = jas_image_cmptprec(tmpimage, 0);
		}

----------------------------------------------------------------------------------
		if (cmpt->sgnd < 0) {
			cmpt->sgnd = jas_image_cmptsgnd(tmpimage, 0);
		}

----------------------------------------------------------------------------------
		if (jas_image_addcmpt(image, jas_image_numcmpts(image), &cmptparm)) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (!(data = jas_seq2d_create(0, 0, cmpt->width, cmpt->height))) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (jas_image_readcmpt(tmpimage, 0, 0, 0, cmpt->width, cmpt->height,
		  data)) {
			goto error;
		}

----------------------------------------------------------------------------------
		if (cmpt->sgnd) {
			bias = 1 << (cmpt->prec - 1);

----------------------------------------------------------------------------------
		if (jas_image_writecmpt(image, jas_image_numcmpts(image) - 1, 0, 0,
		  cmpt->width, cmpt->height, data)) {

----------------------------------------------------------------------------------
	if (image) {
		jas_image_destroy(image);
	}

----------------------------------------------------------------------------------
	if (hdr) {
		mif_hdr_destroy(hdr);

----------------------------------------------------------------------------------
	if (tmpstream && tmpstream != in) {
		jas_stream_close(tmpstream);

----------------------------------------------------------------------------------
	if (tmpimage) {
		jas_image_destroy(tmpimage);

----------------------------------------------------------------------------------
	if (data) {
		jas_seq2d_destroy(data);

----------------------------------------------------------------------------------
	if (optstr && *optstr != '\0') {
		jas_eprintf("warning: ignoring unsupported options\n");

----------------------------------------------------------------------------------
	if ((fmt = jas_image_strtofmt("pnm")) < 0) {
		jas_eprintf("error: PNM support required\n");

----------------------------------------------------------------------------------
	if (!(hdr = mif_makehdrfromimage(image))) {
		goto error;

----------------------------------------------------------------------------------
	if (mif_hdr_put(hdr, out)) {
		goto error;

----------------------------------------------------------------------------------
		if (!cmpt->data) {
			if (!(tmpimage = jas_image_create0())) {

----------------------------------------------------------------------------------
			if (jas_image_addcmpt(tmpimage, jas_image_numcmpts(tmpimage),
			  &cmptparm)) {
				goto error;
			}

----------------------------------------------------------------------------------
			if (!(data = jas_seq2d_create(0, 0, cmpt->width, cmpt->height))) {
				goto error;

----------------------------------------------------------------------------------
			if (jas_image_readcmpt(image, cmptno, 0, 0, cmpt->width,
			  cmpt->height, data)) {

----------------------------------------------------------------------------------
			if (cmpt->sgnd) {
				bias = 1 << (cmpt->prec - 1);
				for (y = 0; y < cmpt->height; ++y) {

----------------------------------------------------------------------------------
			if (jas_image_writecmpt(tmpimage, 0, 0, 0, cmpt->width,
			  cmpt->height, data)) {
				goto error;
			}

----------------------------------------------------------------------------------
			if (jas_image_encode(tmpimage, out, fmt, 0)) {
				goto error;

----------------------------------------------------------------------------------
	if (hdr) {
		mif_hdr_destroy(hdr);

----------------------------------------------------------------------------------
	if (tmpimage) {
		jas_image_destroy(tmpimage);

----------------------------------------------------------------------------------
	if (data) {
		jas_seq2d_destroy(data);

----------------------------------------------------------------------------------
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;

----------------------------------------------------------------------------------
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;

----------------------------------------------------------------------------------
	if (n < MIF_MAGICLEN) {
		return -1;

----------------------------------------------------------------------------------
	if (magic != MIF_MAGIC) {
		return -1;

----------------------------------------------------------------------------------
	if (!(hdr = jas_malloc(sizeof(mif_hdr_t)))) {
		return 0;

----------------------------------------------------------------------------------
	if (mif_hdr_growcmpts(hdr, maxcmpts)) {
		mif_hdr_destroy(hdr);

----------------------------------------------------------------------------------
	if (hdr->cmpts) {
		for (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {

----------------------------------------------------------------------------------
	if (!newcmpts) {
		return -1;
	}

----------------------------------------------------------------------------------
	if (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {
		goto error;

----------------------------------------------------------------------------------
	if (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &
	  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=

----------------------------------------------------------------------------------
	if (!(hdr = mif_hdr_create(0))) {
		goto error;
	}

----------------------------------------------------------------------------------
		if (!mif_getline(in, buf, sizeof(buf))) {
			jas_eprintf("mif_getline failed\n");

----------------------------------------------------------------------------------
		if (buf[0] == '\0') {
			continue;

----------------------------------------------------------------------------------
		if (!(tvp = jas_tvparser_create(buf))) {
			jas_eprintf("jas_tvparser_create failed\n");

----------------------------------------------------------------------------------
		if (jas_tvparser_next(tvp)) {
			jas_eprintf("cannot get record type\n");

----------------------------------------------------------------------------------
		switch (id) {
		case MIF_CMPT:
			if (mif_process_cmpt(hdr, buf)) {
				jas_eprintf("cannot get component information\n");
				goto error;
			}
			break;
		case MIF_END:
			done = 1;
			break;
		default:
			jas_eprintf("invalid header information: %s\n", buf);
			goto error;
			break;
		}

----------------------------------------------------------------------------------
	if (hdr) {
		mif_hdr_destroy(hdr);

----------------------------------------------------------------------------------
	if (tvp) {
		jas_tvparser_destroy(tvp);

----------------------------------------------------------------------------------
	if (!(cmpt = mif_cmpt_create())) {
		jas_eprintf("cannot create component\n");

----------------------------------------------------------------------------------
	if (!(tvp = jas_tvparser_create(buf))) {
		jas_eprintf("cannot create parser\n");

----------------------------------------------------------------------------------
	if ((id = jas_tvparser_next(tvp))) {
		// This should never happen.

----------------------------------------------------------------------------------
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				goto error;
			}
			break;
		default:
			jas_eprintf("invalid component information: %s\n", buf);
			goto error;
			break;
		}

----------------------------------------------------------------------------------
	if (!cmpt->sampperx || !cmpt->samppery) {
		goto error;

----------------------------------------------------------------------------------
	if (!cmpt->width || !cmpt->height || !cmpt->prec || cmpt->sgnd < 0) {
		goto error;

----------------------------------------------------------------------------------
	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
		jas_eprintf("cannot add component\n");

----------------------------------------------------------------------------------
	if (cmpt) {
		mif_cmpt_destroy(cmpt);

----------------------------------------------------------------------------------
	if (tvp) {
		jas_tvparser_destroy(tvp);

----------------------------------------------------------------------------------
		if (cmpt->data) {
			jas_stream_printf(out, " data=%s", cmpt->data);

----------------------------------------------------------------------------------
	if (hdr->numcmpts >= hdr->maxcmpts) {
		if (mif_hdr_growcmpts(hdr, hdr->numcmpts + 128)) {

----------------------------------------------------------------------------------
	if (!(cmpt = jas_malloc(sizeof(mif_cmpt_t)))) {
		return 0;
	}

----------------------------------------------------------------------------------
	if (cmpt->data) {
		jas_free(cmpt->data);

----------------------------------------------------------------------------------
		if ((c = mif_getc(stream)) == EOF) {
			break;

----------------------------------------------------------------------------------
		if (c == '\n') {
			break;

----------------------------------------------------------------------------------
	if (!(bufptr = strchr(buf, '\n'))) {
		return 0;

----------------------------------------------------------------------------------
		switch (c = jas_stream_getc(in)) {
		case EOF:
			done = true;
			break;
		case '#':
			for (;;) {
				if ((c = jas_stream_getc(in)) == EOF) {
					done = true;
					break;
				}	
				if (c == '\n') {
					done = true;
					break;
				}
			}
			break;
		case '\\':
			if (jas_stream_peekc(in) == '\n') {
				jas_stream_getc(in);
			}
			break;
		default:
			done = true;
			break;
		}

----------------------------------------------------------------------------------
	if (!(hdr = mif_hdr_create(jas_image_numcmpts(image)))) {
		return 0;

----------------------------------------------------------------------------------
		if (!(hdr->cmpts[cmptno] = jas_malloc(sizeof(mif_cmpt_t)))) {
			goto error;

----------------------------------------------------------------------------------
		if (hdr->cmpts[cmptno]) {
			jas_free(hdr->cmpts[cmptno]);

----------------------------------------------------------------------------------
	if (hdr) {
		jas_free(hdr);

----------------------------------------------------------------------------------
